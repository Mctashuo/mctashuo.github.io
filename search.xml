<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2019%2F02%2F19%2FACM%2Foffer%2F%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; int lenp = pre.size(); int lenv = vin.size(); if(lenp != lenv || lenp == 0 || lenv == 0) return NULL; p = pre; v = vin; return ConstructBinaryTree(0,lenp-1,0,lenv-1); &#125; TreeNode * ConstructBinaryTree(int startPre,int endPre,int startIn,int endIn) &#123; int rootValue = p[startPre]; TreeNode *root = new TreeNode(rootValue); if(startPre == endPre) &#123; if(startIn == endIn &amp;&amp; p[startPre] == v[startIn]) return root; else return NULL; &#125; int rootIn = startIn; while(rootIn &lt;= endIn &amp;&amp; v[rootIn] != rootValue) rootIn++; if(rootIn == endIn &amp;&amp; v[rootIn] != rootValue) return NULL; int leftLength = rootIn - startIn; int leftPreOrderEnd = startPre + leftLength; if(leftLength &gt; 0) root-&gt;left = ConstructBinaryTree(startPre + 1,leftPreOrderEnd,startIn,rootIn - 1); if(leftLength &lt; endPre - startPre) root-&gt;right = ConstructBinaryTree(leftPreOrderEnd + 1,endPre,rootIn+1,endIn); return root; &#125;private: vector&lt;int&gt; p; vector&lt;int&gt; v;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2019%2F02%2F19%2FACM%2Foffer%2F%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。12345678910111213141516171819202122232425262728/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; result; stack&lt;int&gt; s; if(NULL == head) return result; while(head) &#123; s.push(head-&gt;val); head = head-&gt;next; &#125; while(!s.empty())&#123; result.push_back(s.top()); s.pop(); &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[替换空格]]></title>
    <url>%2F2019%2F02%2F19%2FACM%2Foffer%2F%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。123456789101112131415161718192021222324252627282930class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int count = 0; int i; int len = strlen(str); i = 0; while(i &lt; len)&#123; if(str[i] == ' ') count++; i++; &#125; int new_len = len + count * 2; str[new_len] = '\0'; len = len - 1; for(i = new_len - 1;i &gt;= 0;i--) &#123; if(str[len] == ' ')&#123; str[i--] = '0'; str[i--] = '2'; str[i] = '%'; len--; &#125; else &#123; str[i] = str[len]; len--; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F2019%2F02%2F19%2FACM%2Foffer%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。123456789101112131415161718192021class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row = array.size(); int col = array[0].size(); if(row == 0 || col == 0) return false; int i,j; i = 0,j = col - 1; while(i &lt; row &amp;&amp; j &gt;= 0) &#123; if(array[i][j] &lt; target) i++; else if(array[i][j] &gt; target) j--; else return true; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[14. longest-common-prefix]]></title>
    <url>%2F2019%2F02%2F17%2FACM%2Fleetcode%2F14.longest-common-prefix%2F</url>
    <content type="text"><![CDATA[Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: Input: [“flower”,”flow”,”flight”]Output: “fl”Example 2: Input: [“dog”,”racecar”,”car”]Output: “”Explanation: There is no common prefix among the input strings.Note: All given inputs are in lowercase letters a-z.垂直搜索123456789101112131415class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() == 0) return ""; for(int i = 0,len=strs[0].size();i &lt; len;i++) &#123; char c = strs[0][i]; for(int j = strs.size() - 1;j &gt; 0;j--) &#123; if((int)strs[j].size() &lt; i || strs[j][i] != c) return strs[j].substr(0,i); &#125; &#125; return strs[0]; &#125;&#125;; 参考链接]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不能继承的类]]></title>
    <url>%2F2019%2F02%2F16%2FACM%2Foffer%2F%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[用C++设计一个不能被继承的类构造函数设为私有函数，缺点只能得到位于堆上的实例123456789101112class Class &#123;public: static Class * GetInstance() &#123; return new Class(); &#125; static void DeleteInstance(Class * pInstance) &#123; delete pInstance; &#125;private: Class() &#123;&#125; ~Class() &#123;&#125;&#125; 利用虚拟继承,可移植性不好，最新的GCC可能不支持模板参数类型作为友元类型1234567891011template&lt;typename T&gt; class MakeSealed &#123; friend T;private: MakeSealed() &#123;&#125; ~MakeSealed() &#123;&#125;&#125;;class SealedClass2:virtual public MakeSealed&lt;SealedClass2&gt; &#123;public: SealedClass2() &#123;&#125; ~SealedClass2() &#123;&#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不用加减乘除做加法]]></title>
    <url>%2F2019%2F02%2F16%2FACM%2Foffer%2F%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。1234567891011121314class Solution &#123;public: int Add(int num1, int num2) &#123; int sum,carry; do &#123; sum = num1 ^ num2; carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; num2 = carry; &#125;while(carry != 0); return sum; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[求1+2+...+n]]></title>
    <url>%2F2019%2F02%2F16%2FACM%2Foffer%2F%E6%B1%821%2B2%2B...%2Bn%2F</url>
    <content type="text"><![CDATA[求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。除高斯公式外只能用循环和递归 利用构造函数1234567891011121314151617181920212223242526272829class Temp &#123;private: static int N; static int sum;public: Temp() &#123; N++; sum += N; &#125; static void Reset() &#123; N = 0; sum = 0; &#125; static int getRes() &#123; return sum; &#125;&#125;;int Temp::N = 0;int Temp::sum = 0;class Solution &#123;public: int Sum_Solution(int n) &#123; Temp::Reset(); Temp *t = new Temp[n]; delete []t; t = NULL; return Temp::getRes(); &#125;&#125;; 利用虚函数来构造123456789101112131415161718192021222324class A;A* Array[2];class A&#123;public: virtual int getSum(int n) &#123; return 0; &#125;&#125;;class B: public A &#123;public: virtual int getSum(int n) &#123; return Array[!!n]-&gt;getSum(n-1) + n; &#125;&#125;;class Solution &#123;public: int Sum_Solution(int n) &#123; A a; B b; Array[0] = &amp;a; Array[1] = &amp;b; return Array[1]-&gt;getSum(n); &#125;&#125;; 函数指针1234567891011121314typedef int (*fun)(int);int terminate(int n) &#123; return 0;&#125;int getSum(int n) &#123; static fun f[2] = &#123;terminate,getSum&#125;; return n + f[!!n](n-1);&#125;class Solution &#123;public: int Sum_Solution(int n) &#123; return getSum(n); &#125;&#125;; 作用模板类型求解cpp]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[扑克牌的顺子]]></title>
    <url>%2F2019%2F02%2F15%2FACM%2Foffer%2F%E6%89%91%E5%85%8B%E5%A4%84%E7%89%8C%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[从扑克牌中随机抽5张牌，判断是不是一个顺子，大小五可以看成任意数字1234567891011121314151617181920class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; int len = numbers.size(); if(len != 5) return false; sort(numbers.begin(),numbers.end()); int numberZero = 0; for(int i = 0;i &lt; len &amp;&amp; numbers[i]==0;++i) numberZero++; int gap = 0; for(int i = numberZero;i &lt; len - 1;i++) &#123; if(numbers[i] == numbers[i+1]) return false; if(numbers[i+1] - numbers[i] &gt; 1) gap += (numbers[i+1] - numbers[i] -1); &#125; return gap &lt;= numberZero; &#125;&#125;; 或14哈希]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[翻转单词序列]]></title>
    <url>%2F2019%2F02%2F09%2FACM%2Foffer%2F%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？123456789101112131415161718192021222324252627class Solution &#123;public: string ReverseSentence(string str) &#123; int len = str.size(); if(len &lt;= 0) return str; reverse(str,0,len-1); for(int i = 0;i &lt; len;i++) &#123; if(str[i] != ' ') &#123; int j = i; while(j &lt; len &amp;&amp; str[j] != ' ') j++; reverse(str,i,j-1); i = j; &#125; &#125; return str; &#125; void reverse(string &amp;str,int i,int j) &#123; while(i &lt; j) &#123; char tmp = str[i]; str[i] = str[j]; str[j] = tmp; i++;j--; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[左旋字符串]]></title>
    <url>%2F2019%2F02%2F07%2FACM%2Foffer%2F%E5%B7%A6%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！1234567891011121314151617181920class Solution &#123;public: string LeftRotateString(string str, int n) &#123; int len = str.size(); if(len &lt;= 0) return str; reverse(str,0,len-1); reverse(str,0,len-n-1); reverse(str,len-n,len-1); return str; &#125; void reverse(string &amp;str,int i,int j) &#123; while(i &lt; j) &#123; char tmp = str[i]; str[i] = str[j]; str[j] = tmp; i++;j--; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[和为S的两个数字]]></title>
    <url>%2F2019%2F02%2F07%2FACM%2Foffer%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; int len = array.size(); vector&lt;int&gt; res; if(len == 0) return res; int left = 0,right = len - 1; int cur = array[left] + array[right]; while(left &lt; right) &#123; if(cur &lt; sum) left++; else if(cur &gt; sum) right--; else &#123; res.push_back(array[left]); res.push_back(array[right]); return res; &#125; cur = array[left] + array[right]; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[和为S的连续正数序列]]></title>
    <url>%2F2019%2F02%2F07%2FACM%2Foffer%2F%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; res; if(sum &lt; 3) return res; int left = 1,right = 2; int cur = left + right; int mid = (sum + 1) / 2; list&lt;int&gt; ls &#123;left,right&#125;; while(right &lt;= mid) &#123; if(cur == sum) &#123; vector&lt;int&gt; tmp(ls.begin(),ls.end()); res.push_back(tmp); &#125; while(cur &gt; sum &amp;&amp; right &lt;= mid) &#123; cur -= left; left++; ls.pop_front(); if(cur == sum) &#123; vector&lt;int&gt; tmp(ls.begin(),ls.end()); res.push_back(tmp); &#125; &#125; right++; cur += right; ls.push_back(right); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数字]]></title>
    <url>%2F2019%2F02%2F06%2FACM%2Foffer%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。使用异或的方法1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int len = data.size(); if(len &lt; 2) return; int resultExcusiveOR = 0; for(int d:data) &#123; resultExcusiveOR ^= d; &#125; unsigned indexOfBit = FindIndexOf1(resultExcusiveOR); *num1 = *num2 = 0; for(int d:data) &#123; if(isBit1(indexOfBit,d)) *num1 ^= d; else *num2 ^= d; &#125; &#125; unsigned int FindIndexOf1(int indexOf1) &#123; int index = 0; while(((indexOf1 &amp; 1) == 0) &amp;&amp; (index &lt; (8 * sizeof(int)))) &#123; indexOf1 = indexOf1 &gt;&gt; 1; index++; &#125; return index; &#125; bool isBit1(int indexOf1,int num) &#123; num = num &gt;&gt; 1; return (num &amp; 1); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F02%2F04%2FACM%2Foffer%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[输入一棵二叉树，判断该二叉树是否是平衡二叉树。leetcode 110简洁写法，会重复遍历节点12345678910111213141516171819202122class Solution &#123;public: bool IsBalanced_Solution(TreeNode* pRoot) &#123; if(!pRoot) return true; int left,right; left = TreeDepth(pRoot-&gt;left); right = TreeDepth(pRoot-&gt;right); int dif = (left - right); if(dif &gt; 1 || dif &lt; -1) return false; return IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right); &#125; int TreeDepth(TreeNode * pRoot) &#123; if(!pRoot) return 0; int left,right; left = 1 + TreeDepth(pRoot-&gt;left); right = 1 + TreeDepth(pRoot-&gt;right); return max(left,right); &#125;&#125;; 后序遍历，避免重复遍历节点12345678910111213141516171819202122class Solution &#123;public: bool IsBalanced_Solution(TreeNode* pRoot) &#123; int depth = 0; return IsBalanced(pRoot,depth); &#125; bool IsBalanced(TreeNode *pRoot,int &amp;depth) &#123; if(!pRoot) &#123; depth = 0; return true; &#125; int left,right; if(IsBalanced(pRoot-&gt;left,left) &amp;&amp; IsBalanced(pRoot-&gt;right,right)) &#123; int dif = left - right; if(dif &gt;= -1 &amp;&amp; dif &lt;= 1) &#123; depth = 1 + max(left,right); return true; &#125; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F02%2F02%2FACM%2Foffer%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。123456789101112131415161718192021/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(!pRoot) return 0; int left,right; left = TreeDepth(pRoot-&gt;left) + 1; right = TreeDepth(pRoot-&gt;right) + 1; return max(left,right); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F02%2F02%2FACM%2Foffer%2F%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[统计一个数字在排序数组中出现的次数。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int len = data.size(); if(len == 0) return 0; int firstK = GetFirstK(data,0,len-1,k); if(firstK == -1) return 0; int lastK = GetLastK(data,firstK,len-1,k); return lastK - firstK + 1; &#125; int GetFirstK(vector&lt;int&gt; &amp;data,int start, int end,int k) &#123; int mData,mid; while(start &lt;= end) &#123; mid = (start + end) / 2; mData = data[mid]; if(k == mData) &#123; if(data[mid-1] != k) return mid; else end = mid - 1; &#125; else if(mData &lt; k) &#123; start = mid + 1; &#125; else end = mid - 1; &#125; if(mData != k) return -1; return mid; &#125; int GetLastK(vector&lt;int&gt; &amp;data,int start, int end, int k) &#123; int mData,mid; while(start &lt;= end) &#123; mid = (start + end) / 2; mData = data[mid]; if(mData == k) &#123; if(data[mid + 1] != k) return mid; else start = mid + 1; &#125; else if(mData &lt; k) start = mid + 1; else end = mid - 1; &#125; if(mData != k) return -1; return mid; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个链表的第一个公共结点]]></title>
    <url>%2F2019%2F02%2F02%2FACM%2Foffer%2F%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[输入两个链表，找出它们的第一个公共结点。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; if(!pHead1 || !pHead2) return NULL; ListNode * pCur1 = pHead1; ListNode * pCur2 = pHead2; int shortLen = 0; while(pCur1 &amp;&amp; pCur2) &#123; pCur1 = pCur1-&gt;next; pCur2 = pCur2-&gt;next; shortLen++; &#125; int longLen = shortLen; bool flag = false; if(pCur1) flag = true; while(pCur1) &#123; pCur1 = pCur1-&gt;next; longLen++; &#125; while(pCur2) &#123; pCur2 = pCur2-&gt;next; longLen++; &#125; pCur1 = pHead1; pCur2 = pHead2; int len = longLen - shortLen; if(flag) &#123; while(len--) &#123; pCur1 = pCur1-&gt;next; &#125; &#125; else &#123; while(len--) &#123; pCur2 = pCur2-&gt;next; &#125; &#125; while(shortLen--) &#123; if(pCur1 == pCur2) return pCur1; else &#123; pCur1 = pCur1-&gt;next; pCur2 = pCur2-&gt;next; &#125; &#125; return NULL; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中的逆序对]]></title>
    <url>%2F2019%2F02%2F02%2FACM%2Foffer%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007输入描述:题目保证输入的数组中没有的相同的数字 数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例1输入1,2,3,4,5,6,7,0输出71234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int len = data.size(); if(len &lt;= 0) return 0; int mid = (len - 1) / 2; return InversePairsCore(data,0,mid,len-1); &#125; int InversePairsCore(vector&lt;int&gt; &amp; data, int low, int mid, int high) &#123; if(low == high) return 0; int left = InversePairsCore(data,low,(low+mid) / 2,mid); int right = InversePairsCore(data,mid+1,(mid + 1 + high) / 2,high); int tmp[high - low + 1]; int i = low,j = mid + 1,size = 0,count = 0; while(i &lt;= mid &amp;&amp; j &lt;= high) &#123; if(data[i] &lt; data[j]) tmp[size++] = data[i++]; else &#123; tmp[size++] = data[j++]; count += mid - i + 1; count %= 1000000007; &#125; &#125; while(i &lt;= mid) tmp[size++] = data[i++]; while(j &lt;= high) tmp[size++] = data[j++]; for(i = 0;i &lt; size;i++) &#123; data[i+low] = tmp[i]; &#125; return (left + right + count) % 1000000007; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一个只出现一次的字符]]></title>
    <url>%2F2019%2F02%2F01%2FACM%2Foffer%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 空间换时间1234567891011121314151617class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; int len = str.size(); if(len == 0) return -1; vector&lt;int&gt; ha(256,0); for(int i = 0;i &lt; len;i++) &#123; ha[str[i]]++; &#125; for(int i = 0;i &lt; len;i++) &#123; if(ha[str[i]] == 1) return i; &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[丑数]]></title>
    <url>%2F2019%2F02%2F01%2FACM%2Foffer%2F%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。空间换时间12345678910111213141516171819202122232425262728293031class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) return 0; int pUglyNumbers[index]; pUglyNumbers[0] = 1; int nextUglyIndex = 1; int *pMultiply2 = pUglyNumbers; int *pMultiply3 = pUglyNumbers; int *pMultiply5 = pUglyNumbers; while(nextUglyIndex &lt; index) &#123; int mn = getMin(*pMultiply2 * 2,*pMultiply3 * 3,*pMultiply5 * 5); pUglyNumbers[nextUglyIndex] = mn; while(*pMultiply2 * 2 &lt;= pUglyNumbers[nextUglyIndex]) ++pMultiply2; while(*pMultiply3 * 3 &lt;= pUglyNumbers[nextUglyIndex]) ++pMultiply3; while(*pMultiply5 * 5 &lt;= pUglyNumbers[nextUglyIndex]) ++pMultiply5; nextUglyIndex++; &#125; return pUglyNumbers[nextUglyIndex-1]; &#125; int getMin(int number1,int number2,int number3) &#123; int mn = min(number1,number2); mn = min(mn,number3); return mn; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[整数中1出现的次数(从1到n整数中1出现的次数)]]></title>
    <url>%2F2019%2F01%2F30%2FACM%2Foffer%2F%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。分位数计算，连续计算1从最高位到最底位的个数12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; if(n &lt; 0) return 0; char strN[50]; sprintf(strN,"%d",n); return NumberOf1(strN); &#125; int NumberOf1(const char * strN) &#123; if(!strN || *strN &lt; '0' || *strN &gt; '9' || *strN == '\0') return 0; int first = *strN - '0'; int length = strlen(strN); if(first == 0 &amp;&amp; length == 1) return 0; if(first &gt; 0 &amp;&amp; length == 1) return 1; int numFirstDigit = 0; if(first &gt; 1) numFirstDigit = powerBase10(length - 1); else if (first == 1) numFirstDigit = atoi(strN + 1) + 1; int numOtherDigit = first * (length - 1) * powerBase10(length - 2); int numRecursive = NumberOf1(strN + 1); return numFirstDigit + numOtherDigit + numRecursive; &#125; int powerBase10(unsigned int n) &#123; int res = 1; for(int i = 0;i &lt; n;i++) &#123; res *= 10; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连续子数组的最大和]]></title>
    <url>%2F2019%2F01%2F30%2FACM%2Foffer%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)利用数组的特点或dp1234567891011121314151617181920class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int len = array.size(); if(len &lt;= 0) return 0; int result = INT_MIN; int cur = 0; for(int tmp:array) &#123; if(cur &lt;= 0) &#123; cur = tmp; &#125; else cur += tmp; if(cur &gt; result) result = cur; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最小的k个数]]></title>
    <url>%2F2019%2F01%2F28%2FACM%2Foffer%2F%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。partition方法1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); if(len == 0 || len &lt; k || k &lt;= 0) &#123; input.clear(); return input; &#125; int start = 0; int end = len-1; int index = partition(input,start,end); k -= 1; while(index != k) &#123; if(index &gt; k) &#123; end = index-1; index = partition(input,start,end); &#125; else &#123; start = index + 1; index = partition(input,start,end); &#125; &#125; input.resize(k+1); return input; &#125; int partition(vector&lt;int&gt; &amp;a,int i,int j) &#123; if(i == j) &#123; return i; &#125; int rnd = rand() % (j - i) + i; swap(a[i],a[rnd]); int tmp = a[i]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt;= tmp) j--; a[i] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt;= tmp) i++; a[j] = a[i]; &#125; a[i] = tmp; return i; &#125;&#125;; 海量数据处理可用123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); if(len == 0 || k &lt;= 0 || k &gt; len) &#123; input.resize(0); return input; &#125; multiset&lt;int,greater&lt;int&gt; &gt; ms; for(auto i:input) &#123; if(ms.size() &lt; k) ms.insert(i); else &#123; auto tmp = ms.begin(); if((*tmp) &gt; i) &#123; ms.erase(tmp); ms.insert(i); &#125; &#125; &#125; vector&lt;int&gt; res(ms.begin(),ms.end()); return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F01%2F26%2FACM%2Foffer%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。利用数组的特点1234567891011121314151617181920212223242526class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int count = 0; int result = 0; for(int number:numbers) &#123; if(count == 0) &#123; result = number; count++; &#125; else if(result != number) count--; else if(result == number) count++; &#125; return check(numbers,result)?result:0; &#125; bool check(vector&lt;int&gt; &amp;numbers,int result) &#123; int times = 0; for(int number:numbers) &#123; if(result == number) times++; &#125; return 2 * times &gt; numbers.size(); &#125;&#125;; 借鉴快排partition12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int len = numbers.size(); if(len == 0) return 0; int start = 0,end = len-1; int middle = len&gt;&gt;1; int index = partition(numbers,start,end); while(index != middle) &#123; if(index &lt; middle) &#123; start = index + 1; index = partition(numbers,start,end); &#125; else &#123; end = index - 1; index = partition(numbers,start,end); &#125; &#125; if(check(numbers,numbers[middle])) return numbers[middle]; return 0; &#125; bool check(vector&lt;int&gt; &amp;numbers,int result) &#123; int times = 0; for(int number:numbers) &#123; if(result == number) times++; &#125; return 2 * times &gt; numbers.size(); &#125; int partition(vector&lt;int&gt; &amp;numbers,int i,int j) &#123; if(i == j) return i; int rnd = rand() % (j - i) + i; swap(numbers[rnd],numbers[i]); int tmp = numbers[i]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; numbers[j] &gt;= tmp) &#123; j--; &#125; numbers[i] = numbers[j]; while(i &lt; j &amp;&amp; numbers[i] &lt;= tmp) &#123; i++; &#125; numbers[j] = numbers[i]; &#125; numbers[i] = tmp; return i; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树与双向链表]]></title>
    <url>%2F2019%2F01%2F24%2FACM%2Foffer%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。123456789101112131415161718192021222324252627282930313233343536/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; if(!pRootOfTree) return pRootOfTree; TreeNode * pLast = NULL; ConvertNode(pRootOfTree,&amp;pLast); TreeNode *pHead = pRootOfTree; while(pHead &amp;&amp; pHead-&gt;left) &#123; pHead = pHead-&gt;left; &#125; return pHead; &#125; void ConvertNode(TreeNode * pRoot,TreeNode ** pLast) &#123; if(!pRoot) return; if(pRoot-&gt;left) ConvertNode(pRoot-&gt;left,pLast); pRoot-&gt;left = *pLast; if(*pLast) (*pLast)-&gt;right = pRoot; *pLast = pRoot; if(pRoot-&gt;right) ConvertNode(pRoot-&gt;right,pLast); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[复杂链表的复制]]></title>
    <url>%2F2019%2F01%2F23%2FACM%2Foffer%2F%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）空间换时间双O(n)123456789101112131415161718192021222324252627282930313233/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(!pHead) return pHead; unordered_map&lt;RandomListNode*,RandomListNode *&gt; um; auto old_head = pHead; while(pHead) &#123; auto pNew = new RandomListNode(pHead-&gt;label); um[pHead] = pNew; pHead = pHead-&gt;next; &#125; pHead = old_head; while(pHead) &#123; auto pCur = um[pHead]; pCur-&gt;next = um[pHead-&gt;next]; pCur-&gt;random = um[pHead-&gt;random]; pHead = pHead-&gt;next; &#125; return um[old_head]; &#125;&#125;; 时间O(n),空间O(1)123456789101112131415161718192021222324252627282930313233343536373839/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(!pHead) return pHead; auto old_head = pHead; while(pHead) &#123; auto pNode = new RandomListNode(pHead-&gt;label); pNode-&gt;next = pHead-&gt;next; pHead-&gt;next = pNode; pHead = pNode-&gt;next; &#125; pHead = old_head; while(pHead) &#123; auto pNode = pHead-&gt;next; if(pHead-&gt;random) pNode-&gt;random = pHead-&gt;random-&gt;next; pHead = pNode-&gt;next; &#125; pHead = old_head; auto new_head = pHead-&gt;next; while(pHead) &#123; auto pNode = pHead-&gt;next; pHead-&gt;next = pNode-&gt;next; pHead = pHead-&gt;next; if(pHead) pNode-&gt;next = pHead-&gt;next; &#125; return new_head; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树中和为某一值的路径]]></title>
    <url>%2F2019%2F01%2F21%2FACM%2Foffer%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径前序遍历，过程中记录信息12345678910111213141516171819202122232425262728293031323334/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int expNum; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; vector&lt;vector&lt;int&gt; &gt; res; if(!root) return res; vector&lt;int&gt; path; expNum = expectNumber; int sums = 0; Find(res,path,root,sums); return res; &#125; void Find(vector&lt;vector&lt;int&gt; &gt; &amp; res,vector&lt;int&gt; &amp;path,TreeNode *root,int &amp;sums) &#123; path.push_back(root-&gt;val); sums += root-&gt;val; if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sums == expNum) &#123; res.push_back(path); &#125; if(root-&gt;left) Find(res,path,root-&gt;left,sums); if(root-&gt;right) Find(res,path,root-&gt;right,sums); path.pop_back(); sums -= root-&gt;val; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[974.subarray-sums-divisible-by-k]]></title>
    <url>%2F2019%2F01%2F16%2FACM%2Fleetcode%2F974.subarray-sums-divisible-by-k%2F</url>
    <content type="text"><![CDATA[Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K. Example 1: Input: A = [4,5,0,-2,-3,1], K = 5Output: 7Explanation: There are 7 subarrays with a sum divisible by K = 5:[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] Note:1231 &lt;= A.length &lt;= 30000-10000 &lt;= A[i] &lt;= 100002 &lt;= K &lt;= 10000 前缀和12345678910111213141516171819class Solution &#123;public: int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) &#123; int len = A.size(); if(len == 0) return 0; unordered_map&lt;int,int&gt; um; int ans = 0,sums = 0; um[0] = 1; for(int a:A) &#123; sums = (sums + a) % K; if(sums &lt; 0) sums += K; ans += um[sums]++; &#125; return ans; &#125;&#125;; 加速123456789101112131415class Solution &#123;public: int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) &#123; vector&lt;int&gt; mod(K + 1, 0); int cur = 0; mod[0] = 1; int ans = 0; for (int num : A) &#123; cur = (((cur + num) % K) + K) % K; ans += mod[cur]; mod[cur] ++; &#125; return ans; &#125;&#125;; 123456789101112131415161718class Solution: def subarraysDivByK(self, A, K): """ :type A: List[int] :type K: int :rtype: int """ ln = len(A) if ln == 0: return 0 ans = sums = 0 um = &#123;0:1&#125; for a in A: sums = (sums + a) % K if sums in um: ans += um[sums] um[sums] = um.get(sums,0) + 1 return ans]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[525.Contiguous Array]]></title>
    <url>%2F2019%2F01%2F15%2FACM%2Fleetcode%2F525.contiguous-array%2F</url>
    <content type="text"><![CDATA[Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1:Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.Example 2:Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.Note: The length of the given binary array will not exceed 50,000.123456789101112131415161718192021class Solution &#123;public: int findMaxLength(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len == 0) return 0; unordered_map&lt;int,int&gt; um; int sum = 0,ans = 0; um[0] = 0; for(int i = 1;i &lt;= len;i++) &#123; sum += nums[i-1]?1:-1; if(um.count(sum)) &#123; ans = max(ans,i - um[sum]); &#125; else &#123; um[sum] = i; &#125; &#125; return ans; &#125;&#125;; 123456789101112131415161718192021class Solution: def findMaxLength(self, nums): """ :type nums: List[int] :rtype: int """ ln = len(nums) if len == 0: return 0 sum = ans = 0 um=&#123;0:0&#125; for i in range(1,ln+1): if nums[i-1] == 0: sum += -1; else: sum += 1; if sum in um: ans = max(ans,i - um[sum]) else: um[sum] = i; return ans;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[146.lru-cache]]></title>
    <url>%2F2019%2F01%2F07%2FACM%2Fleetcode%2F146.lru-cache%2F</url>
    <content type="text"><![CDATA[Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity? Example: 1LRUCache cache = new LRUCache( 2 /* capacity */ ); cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4理解实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class LRUCache &#123;private: struct DNode &#123; int key; int value; DNode *pre; DNode *post; &#125;; int capacity; unordered_map&lt;int,DNode *&gt; um; DNode * head,*tail;public: LRUCache(int capacity):capacity&#123;capacity&#125; &#123; DNode dh = DNode(); DNode dt = DNode(); head = &amp;dh; tail = &amp;dt; head-&gt;post = tail; tail-&gt;pre = head; &#125; int get(int key) &#123; if(um.find(key) == um.end()) return -1; int val = um[key]-&gt;value; moveToHead(um[key]); return val; &#125; void put(int key, int value) &#123; if(get(key) != -1) &#123; um[key]-&gt;value = value; return; &#125; if(um.size() == capacity) &#123; popTail(); &#125; DNode *d = new DNode(); d-&gt;key = key; d-&gt;value = value; um[key] = d; addNode(d); &#125; void moveToHead(DNode *d) &#123; DNode *tmp1 = d-&gt;pre; DNode *tmp2 = d-&gt;post; tmp1-&gt;post = tmp2; tmp2-&gt;pre = tmp1; addNode(d); &#125; void addNode(DNode *d) &#123; head-&gt;post-&gt;pre = d; d-&gt;post = head-&gt;post; d-&gt;pre = head; head-&gt;post = d; &#125; void popTail() &#123; um.erase(tail-&gt;pre-&gt;key); DNode * tmp = tail-&gt;pre; tail-&gt;pre = tmp-&gt;pre; tmp-&gt;pre-&gt;post = tail; delete tmp; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ 简化版本123456789101112131415161718192021222324252627282930313233343536class LRUCache &#123;public: int capacity; unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; um; list&lt;pair&lt;int,int&gt;&gt; ls; LRUCache(int capacity):capacity&#123;capacity&#125; &#123; &#125; int get(int key) &#123; if(um.find(key) == um.end()) return -1; ls.splice(ls.begin(),ls,um[key]); return um[key]-&gt;second; &#125; void put(int key, int value) &#123; if(get(key) != -1) &#123; um[key]-&gt;second = value; return; &#125; if(um.size() == capacity) &#123; um.erase(ls.back().first); ls.pop_back(); &#125; ls.emplace_front(key,value); um[key] = ls.begin(); &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[155.Min Stack]]></title>
    <url>%2F2019%2F01%2F07%2FACM%2Fleetcode%2F155.min-stack%2F</url>
    <content type="text"><![CDATA[Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) — Push element x onto stack.pop() — Removes the element on top of the stack.top() — Get the top element.getMin() — Retrieve the minimum element in the stack.Example:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); —&gt; Returns -3.minStack.pop();minStack.top(); —&gt; Returns 0.minStack.getMin(); —&gt; Returns -2.一个栈实现，入栈时遇到更小的值先将之前的最小值入栈，再将当前值入栈。出栈时，如果栈顶是最小值出两次栈，第一次出栈后栈顶为上一次的最小值。123456789101112131415161718192021222324252627282930313233343536373839404142class MinStack &#123;public: /** initialize your data structure here. */ stack&lt;int&gt; s; int mn = INT_MAX; MinStack() &#123; &#125; void push(int x) &#123; if(x &lt;= mn) &#123; s.push(mn); mn = x; &#125; s.push(x); &#125; void pop() &#123; if(mn == s.top()) &#123; s.pop(); mn = s.top(); s.pop(); &#125; else s.pop(); &#125; int top() &#123; return s.top(); &#125; int getMin() &#123; return mn; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 二个栈实现 1234567891011121314151617181920212223242526272829303132333435363738 class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; min.push_back(INT_MAX); &#125; void push(int x) &#123; st.push_back(x); min.push_back(x &lt; min.back() ? x : min.back()); &#125; void pop() &#123; st.pop_back(); min.pop_back(); &#125; int top() &#123; return st.back(); &#125; int getMin() &#123; return min.back(); &#125;private: vector&lt;int&gt; st; vector&lt;int&gt; min;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[300.longest-increasing-subsequence]]></title>
    <url>%2F2019%2F01%2F05%2FACM%2Fleetcode%2F300.longest-increasing-subsequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18]Output: 4Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.Note: There may be more than one LIS combination, it is only necessary for you to return the length.Your algorithm should run in O(n2) complexity.Follow up: Could you improve it to O(n log n) time complexity?以a[i]结尾的最长上升子序列的长度为dp[i]1234567891011121314151617181920class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len &lt; 1) return 0; int dp[len]; int res = 1; for(int i = 0;i &lt; len;i++) &#123; dp[i] = 1; for(int j = 0;j &lt; i;j++) &#123; if(nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i],dp[j]+1); &#125; &#125; res = max(res,dp[i]); &#125; return res; &#125;&#125;; 二分加速优化1234567891011121314151617181920212223242526class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len == 0) return 0; vector&lt;int&gt; dp; for(int i = 0;i &lt; len;i++) &#123; int left = 0,right = dp.size(); while(left &lt; right) &#123; int mid = (left + right) / 2; if(dp[mid] &lt; nums[i]) left = mid + 1; else right = mid; &#125; if(right &gt;= dp.size()) dp.push_back(nums[i]); else dp[right] = nums[i]; &#125; return dp.size(); &#125;&#125;; 在二分法中，如果是右边界是超尾，则while条件中用&lt;=号否则用&lt;号stl lower_bound1234567891011121314class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; v; for(auto num:nums) &#123; auto it = lower_bound(v.begin(),v.end(),num); if(it == v.end()) v.push_back(num); else *it = num; &#125; return v.size(); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[354.russian-doll-envelopes]]></title>
    <url>%2F2019%2F01%2F05%2FACM%2Fleetcode%2F354.russian-doll-envelopes%2F</url>
    <content type="text"><![CDATA[You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note:Rotation is not allowed. Example: Input: [[5,4],[6,4],[6,7],[2,3]]Output: 3Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]). 先做一个排序，按宽度先排，再对于相同宽度的按高度排dp[i] //以i为下标可以放入的最大信封数理解版1234567891011121314151617181920class Solution &#123;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; int len = envelopes.size(); if(len == 0) return 0; int res = 0; sort(envelopes.begin(),envelopes.end()); vector&lt;int&gt; dp(len,1); for(int i = 0;i &lt; len;i++) &#123; for(int j = 0;j &lt; i;j++) &#123; if(envelopes[i].first &gt; envelopes[j].first &amp;&amp; envelopes[i].second &gt; envelopes[j].second) &#123; dp[i] = max(dp[i],dp[j] + 1); &#125; &#125; res = max(res,dp[i]); &#125; return res; &#125;&#125;; 将宽度相同的信封，高度大的排在前面,这样可以不用比较宽度相同的信封1234567891011121314151617181920212223242526class Solution &#123;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp; b) &#123; if(a.first == b.first) return a.second &gt; b.second; else return a.first &lt; b.first; &#125;); vector&lt;int&gt; dp; for(auto envelope:envelopes) &#123; int left = 0,right = dp.size(),t = envelope.second; while(left &lt; right) &#123; int mid = (left + right) / 2; if(dp[mid] &lt; t) left = mid + 1; else right = mid; &#125; if(right &gt;= dp.size()) dp.push_back(t); else dp[right] = t; &#125; return dp.size(); &#125;&#125;; 1234567891011121314151617181920class Solution &#123;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; vector&lt;int&gt; dp; sort(envelopes.begin(),envelopes.end(),[](const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp; b) &#123; if(a.first == b.first) return a.second &gt; b.second; else return a.first &lt; b.first; &#125;); for(auto envelope:envelopes) &#123; auto it = lower_bound(dp.begin(),dp.end(),envelope.second); if(it == dp.end()) dp.push_back(envelope.second); else *it = envelope.second; &#125; return dp.size(); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[69.Sqrt(x)]]></title>
    <url>%2F2018%2F12%2F26%2FACM%2Fleetcode%2F69.Sqrtx%2F</url>
    <content type="text"><![CDATA[Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4Output: 2Example 2: Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned.牛顿公式123456789101112131415class Solution &#123;public: int mySqrt(int x) &#123; double a = x; if (a &lt; 0) return 0; double tmp = a / 2; double t = a; while(fabs(tmp - t) &gt; 0) &#123; t = tmp; tmp = (tmp + a / tmp) / 2; &#125; return (int) tmp; &#125;&#125;; 123456789101112class Solution: def mySqrt(self, x): """ :type x: int :rtype: int """ if x &lt;= 1: return x r = x while r &gt; x / r: r = (r + x / r) // 2 return int(r)]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[120.Triangle]]></title>
    <url>%2F2018%2F12%2F25%2FACM%2Fleetcode%2F120.Triangle%2F</url>
    <content type="text"><![CDATA[Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.123456789101112131415class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; int height = triangle.size(); if(height == 0) return 0; vector&lt;int&gt; dp(height+1,0); for(int i = height-1;i &gt;= 0;i--) &#123; for(int j = 0,len = triangle.size();j &lt; len;j++) &#123; dp[j] = min(dp[j],dp[j+1]) + triangle[i][j]; &#125; &#125; return dp[0]; &#125;&#125;; python]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[221.maximal-square]]></title>
    <url>%2F2018%2F12%2F25%2FACM%2Fleetcode%2F221.maximal-square%2F</url>
    <content type="text"><![CDATA[Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: Input: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 Output: 412345678910111213141516171819202122class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int r = matrix.size(); if(r == 0) return 0; int c = matrix[0].size(); vector&lt;vector&lt;int&gt; &gt; dp(r,vector&lt;int&gt;(c,0)); int res = 0; for(int i = 0;i &lt; r;i++) &#123; for(int j = 0;j &lt; c;j++) &#123; if(matrix[i][j] == '1') &#123; dp[i][j] = 1; if(i &gt; 0 &amp;&amp; j &gt; 0) &#123; dp[i][j] += min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1]); &#125; &#125; res = max(res,dp[i][j]); &#125; &#125; return res * res; &#125;&#125;; 12345678910111213141516171819class Solution: def maximalSquare(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if not matrix: return 0 M = len(matrix) N = len(matrix[0]) dp = [[0] * N for _ in range(M)] res = 0 for i in range(0, M): for j in range(0, N): if matrix[i][j] == '1': dp[i][j] = 1; if i &gt; 0 and j &gt; 0: dp[i][j] += min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) res = max(dp[i][j],res) return res * res]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[best-time-to-buy-and-sell-stock]]></title>
    <url>%2F2018%2F12%2F20%2FACM%2Fleetcode%2Fbest-time-to-buy-and-sell-stock%2F</url>
    <content type="text"><![CDATA[best-time-to-buy-and-sell-stock best-time-to-buy-and-sell-stock-ii best-time-to-buy-and-sell-stock-iii best-time-to-buy-and-sell-stock-iv 121. best-time-to-buy-and-sell-stockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.Example 2: Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; int mn = INT_MAX; for(auto price:prices) &#123; mn = min(price,mn); res = max(res,price-mn); &#125; return res; &#125;&#125;; 123456789101112class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ res = 0 mn = sys.maxsize for price in prices: mn = min(mn,price) res = max(res,price-mn) return res 122.best-time-to-buy-and-sell-stock-ii参考链接Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Example 2: Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3: Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); int res = 0; for(int i = 1;i &lt; len;i++) &#123; if(prices[i] &gt; prices[i-1]) res += prices[i] - prices[i-1]; &#125; return res; &#125;&#125;; 1234567891011class Solution: def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ res = 0 for i in range(1,len(prices)): if prices[i] &gt; prices[i-1]: res += prices[i] - prices[i-1] return res; 123 best-time-to-buy-and-sell-stock-iiiSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.Example 2: Input: [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.Example 3: Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.第一版(超时)12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if(len &lt;= 0) return 0; vector&lt;vector&lt;int&gt; &gt; dp(2,vector&lt;int&gt;(len,0)); for(int i = 1;i &lt; len;i++) &#123; dp[0][i] = dp[0][i-1]; dp[1][i] = dp[1][i-1]; for(int j = 0;j &lt; i;j++) &#123; dp[0][i] = max(dp[0][i],prices[i] - prices[j]); dp[1][i] = max(dp[1][i],dp[0][j]+prices[i] - prices[j]); &#125; &#125; return dp[1][len-1]; &#125;&#125;; 主要是因为每次都去找最小值，做了大量重复工作，只需要维护一个最小值即可12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if(len &lt;= 0) return 0; vector&lt;vector&lt;int&gt; &gt; dp(2,vector&lt;int&gt;(len,0)); int mx = -prices[0]; int mx2 = -prices[0]; for(int i = 1;i &lt; len;i++) &#123; dp[0][i] = max(dp[0][i-1],mx+prices[i]); dp[1][i] = max(dp[1][i-1],mx2+prices[i]); mx = max(mx,-prices[i]); mx2 = max(mx2,dp[0][i]-prices[i]); &#125; return dp[1][len-1]; &#125;&#125;; 简化版本1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int first_buy = INT_MIN; int first_sell = 0; int second_buy = INT_MIN; int second_sell = 0; for(auto price:prices) &#123; first_buy = max(first_buy,-price); first_sell = max(first_sell,first_buy+price); second_buy = max(second_buy,first_sell-price); second_sell = max(second_sell,second_buy+price); &#125; return second_sell; &#125;&#125;; 188.best-time-to-buy-and-sell-stock-ivSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.Example 2: Input: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 内存分配错误123456789101112131415161718class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if(len &lt;= 0) return 0; vector&lt;vector&lt;int&gt; &gt; dp(k+1,vector&lt;int&gt;(len,0)); for(int q = 1;q&lt;=k;q++) &#123; for(int i = 1;i &lt; len;i++) &#123; dp[q][i] = dp[q][i-1]; for(int j = 0;j &lt; i;j++) &#123; dp[q][i] = max(dp[q][i],dp[q-1][j-1]+prices[i]-prices[j]); &#125; &#125; &#125; return dp[k][len-1]; &#125;&#125;; 简化123456789101112131415161718class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if(len &lt;= 0) return 0; vector&lt;vector&lt;int&gt; &gt; dp(k+1,vector&lt;int&gt;(len,0)); int mx; for(int q = 1;q&lt;=k;q++) &#123; mx = - prices[0]; for(int i = 1;i &lt; len;i++) &#123; dp[q][i] = max(dp[q][i-1],mx+prices[i]); mx = max(mx,dp[q-1][i-1]-prices[i]); &#125; &#125; return dp[k][len-1]; &#125; &#125;; 存在一个k=10亿的测试，最后发现当k&gt;len/2时就是第一个问题。滚动数组降低空间复杂度最终答案：1234567891011121314151617181920212223242526class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int len = prices.size(); if(len &lt;= 0) return 0; if(k &gt;= len / 2) &#123; int res = 0; for(int i = 1;i &lt; len;i++) &#123; if(prices[i] &gt; prices[i-1]) res += (prices[i] - prices[i-1]); &#125; return res; &#125; vector&lt;int&gt; dp(len,0); int mx; for(int q = 0;q &lt; k;q++) &#123; mx = -prices[0]; for(int i = 1;i &lt; len;i++) &#123; mx = max(mx,dp[i] - prices[i]); dp[i] = max(dp[i-1],mx+prices[i]); &#125; &#125; return dp[len-1]; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[236.lowest-common-ancestor-of-a-binary-tree]]></title>
    <url>%2F2018%2F12%2F20%2FACM%2Fleetcode%2F236.lowest-common-ancestor-of-a-binary-tree%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique.p and q are different and both values will exist in the binary tree.123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root || root == p || root == q) return root; auto l = lowestCommonAncestor(root-&gt;left,p,q); auto r = lowestCommonAncestor(root-&gt;right,p,q); if(l &amp;&amp; r) return root; return l?l:r; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的后序序列]]></title>
    <url>%2F2018%2F12%2F19%2FACM%2Foffer%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; int len = sequence.size(); if(len &lt;= 0) return false; return BST(sequence,0,len); &#125; bool BST(vector&lt;int&gt; &amp;sequence,int start,int len) &#123; if(len &lt;= 0) return false; int root = sequence[len-1]; int i; for(i = start;i &lt; len - 1;i++) &#123; if(sequence[i] &gt; root) break; &#125; int j; for(j = i;j &lt; len - 1;j++) &#123; if(sequence[j] &lt; root) return false; &#125; bool left = true; if(i &gt; start) left = BST(sequence,start,i); bool right = true; if(i &lt; len - 1) right = BST(sequence,i,len-1); return left &amp;&amp; right; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>offer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树遍历合集]]></title>
    <url>%2F2018%2F12%2F19%2FACM%2Fleetcode%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[144.binary-tree-preorder-traversal 94.binary-tree-inorder-traversal 145.binary-tree-postorder-traversal144.binary-tree-preorder-traversalGiven a binary tree, return the preorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3]Follow up: Recursive solution is trivial, could you do it iteratively?Recursive1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; res; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; Traversal(root); return res; &#125; void Traversal(TreeNode * root) &#123; if(!root) &#123; return; &#125; res.push_back(root-&gt;val); if(root-&gt;left) &#123; Traversal(root-&gt;left); &#125; if(root-&gt;right) &#123; Traversal(root-&gt;right); &#125; &#125;&#125;; Iteration1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode *&gt; s; s.push(root); while(!s.empty()) &#123; auto cur = s.top(); s.pop(); res.push_back(cur-&gt;val); if(cur-&gt;right) s.push(cur-&gt;right); if(cur-&gt;left) s.push(cur-&gt;left); &#125; return res; &#125;&#125;; 94. binary-tree-inorder-traversalRecursive1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; res; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; Traversal(root); return res; &#125; void Traversal(TreeNode *root) &#123; if(!root) return; if(root-&gt;left) Traversal(root-&gt;left); res.push_back(root-&gt;val); if(root-&gt;right) Traversal(root-&gt;right); &#125;&#125;; Iteration1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;TreeNode*&gt; s; auto cur = root; while(cur || !s.empty()) &#123; while(cur) &#123; s.push(cur); cur = cur-&gt;left; &#125; if(!s.empty()) &#123; cur = s.top(); s.pop(); res.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return res; &#125;&#125;; 145.binary-tree-postorder-traversalGiven a binary tree, return the postorder traversal of its nodes’ values. Example: Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1]Follow up: Recursive solution is trivial, could you do it iteratively?Recursion1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; res; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; Traversal(root); return res; &#125; void Traversal(TreeNode *root) &#123; if(!root) return; if(root-&gt;left) Traversal(root-&gt;left); if(root-&gt;right) Traversal(root-&gt;right); res.push_back(root-&gt;val); &#125;&#125;; Iteration123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(!root) return res; stack&lt;pair&lt;TreeNode*,int&gt; &gt; s; s.push(&#123;root,0&#125;); while(!s.empty()) &#123; auto paired = s.top(); s.pop(); auto cur = paired.first; int time = paired.second; if(time == 0) &#123; s.push(&#123;cur,1&#125;); if(cur-&gt;right) s.push(&#123;cur-&gt;right,0&#125;); if(cur-&gt;left) s.push(&#123;cur-&gt;left,0&#125;); &#125; else &#123; res.push_back(cur-&gt;val); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[23.merge-k-sorted-lists]]></title>
    <url>%2F2018%2F12%2F19%2FACM%2Fleetcode%2F23.merge-k-sorted-lists%2F</url>
    <content type="text"><![CDATA[Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6参考链接Solution 1:Brute Force1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; ListNode tmp(0); auto res = &amp;tmp; while(1) &#123; ListNode ** min_head = nullptr; for(auto &amp;head:lists) &#123; if(!head) continue; if(!min_head || head-&gt;val &lt; (*min_head)-&gt;val) min_head = &amp;head; &#125; if(!min_head) break; res-&gt;next = new ListNode((*min_head)-&gt;val); res = res-&gt;next; (*min_head) = (*min_head)-&gt;next; &#125; return tmp.next; &#125;&#125;; Sulotion 21234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto cmp = [](const ListNode *a,const ListNode *b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,decltype(cmp)&gt; q(cmp); for(auto list:lists) &#123; if(list) q.push(list); &#125; ListNode tmp(0); ListNode *tail = &amp;tmp; while(!q.empty()) &#123; tail-&gt;next = q.top(); q.pop(); tail = tail-&gt;next; if(tail-&gt;next) q.push(tail-&gt;next); &#125; return tmp.next; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[142.linked-list-cycle-ii]]></title>
    <url>%2F2018%2F12%2F19%2FACM%2Fleetcode%2F142.linked-list-cycle-ii%2F</url>
    <content type="text"><![CDATA[Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. Follow up:Can you solve it without using extra space?123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head) return head; auto fast = head-&gt;next; auto slow = head; while(fast != slow &amp;&amp; fast) &#123; slow = slow-&gt;next; if(fast-&gt;next) fast = fast-&gt;next-&gt;next; else return nullptr; &#125; if(!fast) return nullptr; slow = slow-&gt;next; while(slow != head) &#123; slow = slow-&gt;next; head = head-&gt;next; &#125; return head; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[lambda表达式]]></title>
    <url>%2F2018%2F12%2F18%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2Flambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[参考链接声明Lambda表达式Lambda表达式完整的声明格式如下： [capture list] (params list) mutable exception-&gt; return type { function body }各项具体含义如下 capture list：捕获外部变量列表params list：形参列表mutable指示符：用来说用是否可以修改捕获的变量exception：异常设定return type：返回类型function body：函数体此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种： 序号 格式1 [capture list] (params list) -&gt; return type {function body}2 [capture list] (params list) {function body}3 [capture list] {function body}其中： 格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。格式3中省略了参数列表，类似普通函数中的无参函数。]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148.Sort-list]]></title>
    <url>%2F2018%2F12%2F17%2FACM%2Fleetcode%2F148.Sorted-List%2F</url>
    <content type="text"><![CDATA[Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4Example 2: Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5参考链接需要使用o(1)的时间复杂度完成排序 选择归并排序 Top-Downtime:O(nlogn),space:O(nlogn) 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; auto fast = head-&gt;next; auto slow = head; while(fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; auto mid = slow-&gt;next; slow-&gt;next = NULL; return merge(sortList(head),sortList(mid)); &#125; ListNode * merge(ListNode* h1,ListNode *h2) &#123; ListNode tmp(0); auto tail = &amp;tmp; while(h1 &amp;&amp; h2) &#123; if(h1-&gt;val &gt; h2-&gt;val) swap(h1,h2); tail-&gt;next = h1; tail=tail-&gt;next; h1 = h1-&gt;next; &#125; tail-&gt;next=h1?h1:h2; return tmp.next; &#125;&#125;; Bottom-Uptime:O(nlogn),space:O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Author: Huahua// Running time: 32 msclass Solution &#123;public: ListNode* sortList(ListNode* head) &#123; // 0 or 1 element, we are done. if (!head || !head-&gt;next) return head; int len = 1; ListNode* cur = head; while (cur = cur-&gt;next) ++len; ListNode dummy(0); dummy.next = head; ListNode* l; ListNode* r; ListNode* tail; for (int n = 1; n &lt; len; n &lt;&lt;= 1) &#123; cur = dummy.next; // partial sorted head tail = &amp;dummy; while (cur) &#123; l = cur; r = split(l, n); cur = split(r, n); auto merged = merge(l, r); tail-&gt;next = merged.first; tail = merged.second; &#125; &#125; return dummy.next; &#125;private: // Splits the list into two parts, first n element and the rest. // Returns the head of the rest. ListNode* split(ListNode* head, int n) &#123; while (--n &amp;&amp; head) head = head-&gt;next; ListNode* rest = head ? head-&gt;next : nullptr; if (head) head-&gt;next = nullptr; return rest; &#125; // Merges two lists, returns the head and tail of the merged list. pair&lt;ListNode*, ListNode*&gt; merge(ListNode* l1, ListNode* l2) &#123; ListNode dummy(0); ListNode* tail = &amp;dummy; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &gt; l2-&gt;val) swap(l1, l2); tail-&gt;next = l1; l1 = l1-&gt;next; tail = tail-&gt;next; &#125; tail-&gt;next = l1 ? l1 : l2; while (tail-&gt;next) tail = tail-&gt;next; return &#123;dummy.next, tail&#125;; &#125;&#125;; why is mergesort better for linked lists]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F12%2F16%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[UML类图三层类图:第一层名称（斜体表示抽象类）第二层属性第三层方法+public-private#protected&lt;&lt;interface&gt;&gt;继承关系空心三角形和实线来表示实现接口用空心三角形+虚线来表示一个类需要“知道”另一个类，用关联来表示，关联关系用实线箭头来表示聚合表示一种弱的’拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分[DPE]。聚合关系使用空心的菱形+实线箭头来表示合成是一种强的’拥有关系’，体现了严格的部分和整体的关系，部分和整体的生命周期一样。实心菱形+实线箭头来表示依赖关系使用虚线箭头表示 简单工厂面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同性和功能的对象的抽象集合才是类 策略模式策略模式：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。封装变化点是一种很重要的思维方式策略模式和简单工厂相结合。解析：策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。优点：策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为，继承有助于析取出这些算法中的公共功能[DP]简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试[DPE]当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为，将这些行为封闭在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句[DP]策略模式就是用来封闭算法的。但在实践中，我们发现可以用它来封闭几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性[DPE]在基本的策略模式中，选择手忙脚乱具体实现的职责由客户端对象承担，并转给策略模式的Context对象 [DPE]任何需要的变化都是需要成本的。 单一职责原则就一个类而言，应该仅有一个引起它变化的原因如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抵制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离[ASD]。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责 开放-封闭原则软件实体（类，模块，函数）应该可以扩展，但是不可以修改[ASD]对于扩展是开放的，对于一更改是封闭的无论模块是多么的封闭，都会存在一些无法对之封闭的变化，既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择，他必须先猜测出最有可能发生变化种类，然后构造抽象来隔离那些变化[ASD]等到变化发生时立即采取行动。在我们最初编写代码时，假设变化不会发生，当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]面对需求，对程序的发动是通过增加新代码进行的，而不是更改现有的代码我们希望的是在工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可复用，灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意，拒绝不成熟的抽象和抽象本身一样重要。 依赖倒转原则A. 高层模块不应该依赖低层模块，两个都应该依赖抽象B. 抽象不应该依赖细节。细节应该依赖抽象针对接口编程，不要对实现编程 里氏代换原则一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。里氏代换原则(LSP):子类型必须能够替换掉它们的父类型[ASD]由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口那就是面向对象的设计，反之那就是过程化的设计了[ASD] 装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活[DP]Component是定义一个对象接口，可以给这些对象动态地添加职责，ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责，Decorator，装饰抽象类，继承了Component，从外类来扩展Component的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能[DPE] 装饰模式是复用SetComponent来对对象进行包装的。这个每个装饰对象的实现就和如何使用这个对象分离开了。每个对象只关心自己的功能，不需要关心如何被添加到对象链当中[DPE]如果只有一个ConcreteComponent类而没有抽象Component类，那么Decorator类可以是ConcreteComponent的一个子类，同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类 总结装饰模式是为已有的功能动态地添加更多功能的一种方式。当系统需要新功能的时候，是向旧的类中添加新的代码，这些新加的代码通常装饰了原有类的核心职责或主要行为。在主类加入了新的字段，新的方法或新的逻辑，从而增加了主类的复杂度，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。装饰模式却提供了一个非常好的解决文案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有我选择地，按顺序地使用装饰功能包装对象了优点：把类中的装饰功能从类中搬移去除，这样可以简化原有的类有效地把类的核心职责和装饰功能区分开了，而且这样可以去除相关类中重复的逻辑。 代理模式为共创对象提供一种代理以控制这个对象的访问代理模式的应用场景 远程代理，也就是一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实 虚拟代理，是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，以达到性能的最优化。 安全代理，用来控制真实对象访问时的权限。 智能指引，是指调用真实的对象时，代理处理另外一些事。 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。和简单工厂的比较简单工厂的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。但可能要修改代码，违反了开闭原则。工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类，而现在是修改客户端。工厂方法克服了简单工厂违背开放-封闭原则的缺点，又保持了封闭对象创建过程的优点。它们都是集中封闭了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与产品对象的耦合。工厂方法模式是简单工厂模式的进一步抽象和推广。 缺点由于使用了多态性，，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点，但缺点是由于每加一个产品，就需要加一个产品工厂的类，增加了额外的开发量。 原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。一般在初始化的信息不发生变化的情况下，克隆是最好的办法，既隐藏了对象创建的细节，又对性能是大大的提高。不用重新初始化对象，而是动态地获得对象运行时的状态。 浅复制和深复制浅复制被复制的对象的所有变量都含有与原来相同的值，而所有的对其他对象的引用都仍然指向原来的对象。深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 模板方法模式注意点，如果用了继承，并且肯定这个继承有意义，就应该要成为子类的模板，所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复。当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。AbstractClass是抽象类，其实也就是一抽象模板，定义并实现了一个模版方法，这个模版方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法ConcreteClass，实现父类所定义的一个或多个抽象方法，每一个AbstractClass都可以有什么问题多个ConcreteClass与之对应，而每一个ConcreteClass都可以给出这些抽象方法(也就是顶级逻辑的组成步骤)的不同实现，从而使得顶级逻辑的实现各不相同。 优点模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势模板方法模式就是提供了一个很好的代码复用平台。当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现，我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠 迪米特法则也叫最少知识原则迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不就当发生直接的相互作用，如果期中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类千万涉及。 外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统更加容易使用。使用场景：成一个阶段 首先，在设计初期阶段，应该要有意识的将不同的两个层分离。层与导之间建立外观Facade 其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观facade,可以提供一个简单的接口，减少它们之间的依赖。 在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了。为新系统开发一个外观Facade类，来提供设计粗糙或调试复杂的遗留代码的比较清晰简单的手足口，让新系统和Facade对象交互，Facade与贵这留代码交互所有复杂的工作 建造者模式抽象不应该依赖细节，细节应该依赖抽象将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示建造者模式是当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式 观察者模式又叫发布-订阅模式定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。 特点将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性，我们不希望为了维持一致性而例各类紧密耦合，这样会给维护，扩展和重用都带来不便 使用场景当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变，应该考虑使用观察者模式。一个抽象模型有两个方面，其中一个方面依赖于另一方面，这里用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。 不足需要”通知”的类的方法名不同或已封装好，无法继承或实现接口。 改进使用事件委托实现委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的’类’，委托的实例将代表一个具体的函数。一个委托可以搭载多个方法，所有方法被依次唤起，可以使得委托对象所搭载的方法并不需要属于同一个类。委托对象所搭载的所有方法必须具有相同的原型和形式，也就是拥有相同的参数列表和返回值类型。 抽象工厂模式工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化哪一个类抽象工厂模式，提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。AbstractProductA和AbstractProductB是两个抽象产品，ProductA1,ProductA2和ProduvtB1就是对两个抽象产品的具体分类的实现。IFactory是一个抽象工厂接口，它里面应该包含所有的产品创建的抽象方法。ConcreteFactory1和ConcreteFactory2就是具体的工厂了。通常是在运行时刻再创建一个ConcreteFactory类的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。 优点 易于交换产品系列，由于具体工厂类，在一个应用中只需要在初始化的时候出现一次，这就使得，改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置。 它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品听具体类名也被具体工厂的实现分离，不会出现在客户代码中。缺点 在增加功能时需要增加类，在使用的地方需要声明Ifactory factory = new 具体的工厂类。用简单工厂来改进抽象工厂用一个统一类来取代IFactory及其继承类用反向+抽象工厂依赖注入反向+配置文件状态模式面象对象设计其实就是希望做到代码的责任分解状态模式，当一个对象的内存状态改变时允许改变其行为，这个对象看起来像是改变了其类状态模式主要解决的是当控制一个对象状态转换条件的表达式过于复杂的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。优点将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通完定义新的子类，可以很容易地增加新的状态和转换。目的是为了消除庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State的子类之间来减少相互间的依赖。使用场景当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式。适配器模式将一个类的接口转换成客户希望的另外一个接口.Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制小范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现在的类，但是接口又与复用环境要求不一致的情况。类适配器模式通过多重继承对一个接口与另一个接口进行匹配。对象适配器使用场景使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑使用适配器模式。]]></content>
      <categories>
        <category>C++面试</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[43.trapping-rain-water]]></title>
    <url>%2F2018%2F12%2F16%2FACM%2Fleetcode%2F42.trapping-rain-water%2F</url>
    <content type="text"><![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6双指针1234567891011121314151617181920212223242526272829class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int len = height.size(); if(len &lt;= 0) return 0; int l = 0; int r = len-1; int res = 0; while(l &lt; r) &#123; int cur = min(height[l],height[r]); if(height[l] != cur) &#123; r--; while(l &lt; r &amp;&amp; height[r] &lt;= cur) &#123; res += (cur-height[r]); r--; &#125; &#125;else &#123; l++; while(l &lt; r &amp;&amp; height[l] &lt; cur) &#123; res += (cur-height[l]); l++; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[56.Merge Intervals]]></title>
    <url>%2F2018%2F12%2F15%2FACM%2Fleetcode%2F56.merge-intervals%2F</url>
    <content type="text"><![CDATA[Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Example 2: Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping.1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: static bool cmp(const Interval &amp; a,const Interval &amp; b) &#123; return a.start &lt; b.start; &#125; vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123; vector&lt;Interval&gt; res; int len = intervals.size(); if(len &lt;= 0) return res; //sort(intervals.begin(),intervals.end(),cmp); sort(intervals.begin(),intervals.end,[](const Interval &amp; a,const Interval &amp;b) &#123; return a.start&lt;b.start; &#125;); Interval cur(intervals[0].start,intervals[0].end); for(auto interval:intervals) &#123; if(interval.start &lt;= cur.end &amp;&amp; interval.end &gt;= cur.end) &#123; cur.end = interval.end; &#125; else if(interval.end &gt;= cur.end) &#123; res.push_back(cur); cur.start = interval.start; cur.end = interval.end; &#125; &#125; res.push_back(cur); return res; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[547. Friend Circles]]></title>
    <url>%2F2018%2F12%2F15%2FACM%2Fleetcode%2F547.Friend-Circles%2F</url>
    <content type="text"><![CDATA[Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students. Example 1:Input:[[1,1,0], [1,1,0], [0,0,1]]Output: 2Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.The 2nd student himself is in a friend circle. So return 2.Example 2:Input:[[1,1,0], [1,1,1], [0,1,1]]Output: 1Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.Note:N is in range [1,200].M[i][i] = 1 for all students.If M[i][j] = 1, then M[j][i] = 1. 123456789101112131415161718192021222324252627class Solution &#123;public: int N; int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) &#123; N = M.size(); char visit[N]; memset(visit,0,sizeof(visit)); int res = 0; for(int i = 0;i &lt; N;i++) &#123; if(!visit[i]) &#123; res++; dfs(visit,M,i); &#125; &#125; return res; &#125; void dfs(char *visit,vector&lt;vector&lt;int&gt; &gt; &amp;M,int x) &#123; if(visit[x]) return; visit[x] = 1; for(int i = 0;i &lt; N;i++) &#123; if(M[x][i]) dfs(visit,M,i); &#125; &#125;&#125;; 方法2：并查集```cpp]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Fair Nut and String]]></title>
    <url>%2F2018%2F12%2F14%2FACM%2Fcf%2F1084C%2F</url>
    <content type="text"><![CDATA[The Fair Nut found a string s. The string consists of lowercase Latin letters. The Nut is a curious guy, so he wants to find the number of strictly increasing sequences p1,p2,…,pk, such that: For each i (1≤i≤k), spi= ‘a’.For each i (1≤i&lt;k), there is such j that pi&lt;j&lt;pi+1 and sj= ‘b’.The Nut is upset because he doesn’t know how to find the number. Help him. This number should be calculated modulo 109+7.dp问题s[i] == a dp[i] = dp[i-1] + 1 + dp[b] (指b出现的位置)s[i] == b dp[i] = dp[i-1] 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 100010;typedef long long ll;const ll mod = 1e9 + 7;char s[maxn];int main()&#123; scanf("%s",s); int n = strlen(s); ll a = 0; ll b = 0; for(int i = 0;i &lt;= n;i++) &#123; if(s[i] == 'a') &#123; a = (a + 1 + b) % mod; &#125; else if(s[i] == 'b') &#123; b = a; &#125; &#125; printf("%lld\n",a); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>cf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排列问题合集]]></title>
    <url>%2F2018%2F12%2F14%2FACM%2Fleetcode%2F31.46.47.60.Permutation%2F</url>
    <content type="text"><![CDATA[此合集为收集到的排列问题leetcode 31,46,47,60分别为求下一个排列，无重复全排列，有重复全排列，第k个排列 Next PermtationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1参考链接Solution:Find the last acceding element x, swap with the smallest number y, y is after x that and y is greater than x.Reverse the elements after x.Time complexity: O(n)Space complexity: O(1)概括为后找升序，后找小大交换翻转可以解决重复stl中的algorithm集成算法next_permutation12345678910111213class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 2; while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) --i; if (i &gt;= 0) &#123; int j = nums.size() - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) --j; swap(nums[i], nums[j]); &#125; reverse(begin(nums) + i + 1, end(nums)); &#125;&#125;; PermutationsGiven a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]方法1：递归算法(不能解决重复)1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;vector&lt;int&gt; &gt; res; permutation(nums,size,0,res); return res; &#125; void permutation(vector&lt;int&gt; &amp; nums,int size,int n,vector&lt;vector&lt;int&gt; &gt; &amp; res) &#123; if(n == size - 1) &#123; res.push_back(nums); return; &#125; for(int i = n;i &lt; size;i++) &#123; swap(nums[i],nums[n]); permutation(nums,size,n+1,res); swap(nums[i],nums[n]); &#125; &#125;&#125;; 方法2：next_permutation(可解决重复)12345678910111213class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; sort(nums.begin(),nums.end()); res.push_back(nums); while(next_permutation(nums.begin(),nums.end())) &#123; res.push_back(nums); &#125; return res; &#125;&#125;; permutations-iiGiven a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]]方法1：递归法（需要去重)每个字符分别与它后面非重复出现的字符交换即第i个字符(前)与第j个字符(后)交换时，要求[i,j)中没有与第j个字符相等的数123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;vector&lt;int&gt; &gt; res; permutation(nums,size,0,res); return res; &#125; void permutation(vector&lt;int&gt; &amp; nums,int size,int n,vector&lt;vector&lt;int&gt; &gt; &amp; res) &#123; if(n == size - 1) &#123; res.push_back(nums); return; &#125; unordered_set&lt;int&gt; h; for(int i = n;i &lt; size;i++) &#123; if(h.count(nums[i])) continue; h.insert(nums[i]); swap(nums[i],nums[n]); permutation(nums,size,n+1,res); swap(nums[i],nums[n]); &#125; &#125;&#125;; 方法2：next_permutation123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; sort(nums.begin(),nums.end()); res.push_back(nums); while(next_permutation(nums.begin(),nums.end())) &#123; res.push_back(nums); &#125; return res; &#125;&#125;; Permutation SequenceThe set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3: “123”“132”“213”“231”“312”“321”Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive.Given k will be between 1 and n! inclusive.Example 1: Input: n = 3, k = 3Output: “213”Example 2: Input: n = 4, k = 9Output: “2314” 方法1：k次排列1234567891011class Solution &#123;public: string getPermutation(int n, int k) &#123; string num = "123456789"; num.resize(n); for(int i = 1;i &lt; k;i++) &#123; next_permutation(num.begin(),num.end()); &#125; return num; &#125;&#125;; 方法2：排列组合的规律n个数排列有n!种可能，如果已经确定第一个数则剩下的数有(n-1)!种可能以1234为例，以1开头的排列共有3!个以2开头的排列共有3!个csdn参考12345678910111213141516171819class Solution &#123;public: string getPermutation(int n, int k) &#123; string res; string num = "123456789"; vector&lt;int&gt; f(n, 1); //计算阶乘数 for (int i = 1; i &lt; n; ++i) f[i] = f[i - 1] * i; --k; for (int i = n; i &gt;= 1; --i) &#123; int j = k / f[i - 1]; k %= f[i - 1]; res.push_back(num[j]); num.erase(j, 1); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[128.longest-consecutive-sequence]]></title>
    <url>%2F2018%2F12%2F13%2FACM%2Fleetcode%2F128.longest-consecutive-sequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.IDEA Hashtable/Hashset参考链接hashset检查迭代数的左边界是否存在，如果不存在则连续检查下一个数直到不存在，计算最长长度offline算法1234567891011121314151617class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; h(nums.begin(),nums.end()); int res = 0; for(auto num:nums) &#123; int count = 0; if(!h.count(num-1)) &#123; while(h.count(num++)) &#123; count++; &#125; &#125; res = max(res,count); &#125; return res; &#125;&#125;; 方法二: hashtab 在线算法，当添加新元素进入时，可以立即算出新的结果int,len12345678910111213141516171819202122232425262728//添加新元素时分三种情况class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; h; int res = 0; for(int num:nums) &#123; if(h.count(num)) continue; auto it_l = h.find(num-1); auto it_r = h.find(num+1); int l = it_l != h.end() ? it_l-&gt;second:0; int r = it_r != h.end() ? it_r-&gt;second:0; int t = r + l +1; if(l &gt; 0 &amp;&amp; r &gt; 0) &#123; h[num-l] = h[num+r] = t; &#125;else if(l &gt; 0) &#123; h[num - l] = h[num] = t; &#125;else if(r &gt; 0) &#123; h[num + r] = h[num] = t; &#125; else h[num] = 1; res = max(res,h[num]); &#125; return res; &#125;&#125;; 简化写法12345678910111213141516171819class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; h; int res = 0; for(int num:nums) &#123; if(h.count(num)) continue; auto it_l = h.find(num-1); auto it_r = h.find(num+1); int l = it_l != h.end() ? it_l-&gt;second:0; int r = it_r != h.end() ? it_r-&gt;second:0; int t = r + l + 1; h[num - l] = h[num + r] = h[num] = t; res = max(res,h[num]); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[215.kth-largest-element-in-an-array]]></title>
    <url>%2F2018%2F12%2F12%2FACM%2Fleetcode%2F215.kth-largest-element-in-an-array%2F</url>
    <content type="text"><![CDATA[Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4Note:You may assume k is always valid, 1 ≤ k ≤ array’s length.使用随机化划分的方法123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int p = 0; int q = nums.size(); return rand_select(nums,p,q-1,q-k+1); &#125; int rand_select(vector&lt;int&gt;&amp; nums,int p,int q,int i) &#123; if(p == q) return nums[p]; int r = rand_parition(nums,p,q); int k = r-p + 1; if(k == i) return nums[r]; else if (k &lt; i) return rand_select(nums,r+1,q,i-k); else return rand_select(nums,p,r-1,i); &#125; int rand_parition(vector&lt;int&gt; &amp; nums,int p,int q) &#123; int rnd = rand()%(q-p) + p; swap(nums[rnd],nums[p]); int tmp = nums[p]; while(p &lt; q) &#123; while(p &lt; q &amp;&amp; tmp &lt;= nums[q]) &#123; q--; &#125; nums[p] = nums[q]; while(p &lt; q &amp;&amp; tmp &gt;= nums[p]) &#123; p++; &#125; nums[q] = nums[p]; &#125; nums[p] = tmp; return p; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[674.longest-continuous-increasing-subsequence]]></title>
    <url>%2F2018%2F12%2F12%2FACM%2Fleetcode%2F674.longest-continuous-increasing-subsequence%2F</url>
    <content type="text"><![CDATA[Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). Example 1:Input: [1,3,5,4,7]Output: 3Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4.Example 2:Input: [2,2,2,2,2]Output: 1Explanation: The longest continuous increasing subsequence is [2], its length is 1.Note: Length of the array will not exceed 10,000.1234567891011121314151617181920class Solution &#123;public: int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123; int end = nums.size(); if(end &lt; 1) return 0; int start = 0; int cur = 1; int res = 1; while(cur &lt; end) &#123; if(nums[cur] &lt;= nums[cur-1]) &#123; res = max(res,cur-start); start = cur; &#125; cur++; &#125; res = max(res,cur-start); return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[33.search-in-rotated-sorted-array]]></title>
    <url>%2F2018%2F12%2F12%2FACM%2Fleetcode%2F33.search-in-rotated-sorted-array%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.Your algorithm&apos;s runtime complexity must be in the order of O(log n).Example 1:Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4Example 2:Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 基本思路为二分法，旋转数组会分为排序的和不排序的，对排序的使用二分法查找，非排序的继续二分直到没有结果123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int end = nums.size()-1; int start = 0; int res = -1; while(start &lt;= end) &#123; int mid = (start + end) / 2; if(nums[mid] &gt;= nums[start]) &#123; res = BinarySearch(nums,target,start,mid); if(res != -1) return res; else start = mid + 1; &#125; else if(nums[mid] &lt; nums[start]) &#123; res = BinarySearch(nums,target,mid,end); if(res != -1) return res; else end = mid; &#125; &#125; return res; &#125; int BinarySearch(vector&lt;int&gt; &amp;nums,int target,int start,int end) &#123; while(start &lt;= end) &#123; int mid = (start + end) / 2; if(target &lt; nums[mid]) &#123; end = mid - 1; &#125; else if (target &gt; nums[mid]) start = mid + 1; else if(target == nums[mid]) return mid; &#125; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[695.max-area-of-island]]></title>
    <url>%2F2018%2F12%2F12%2FACM%2Fleetcode%2F695.max-area-of-island%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920Given a non-empty 2D array grid of 0&apos;s and 1&apos;s, an island is a group of 1&apos;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)Example 1:[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.Example 2:[[0,0,0,0,0,0,0,0]]Given the above grid, return 0.Note: The length of each dimension in the given grid does not exceed 50. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; _grid = grid; C = grid.size(); R = grid[0].size(); int res = 0; for(int i = 0; i &lt; C;i++) &#123; for(int j = 0;j &lt; R;j++) &#123; count = 0; if(_grid[i][j] == 1) &#123; dfs(i,j); &#125; res = max(res,count); &#125; &#125; return res; &#125; void dfs(int x,int y) &#123; if(x &lt; 0 || y &lt; 0 || x &gt;= C || y &gt;= R || _grid[x][y] == 0) return; _grid[x][y] = 0; count++; dfs(x,y-1); dfs(x,y+1); dfs(x-1,y); dfs(x+1,y); &#125; int count; int C; int R; vector&lt;vector&lt;int&gt; &gt; _grid;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[15.3Sum]]></title>
    <url>%2F2018%2F12%2F12%2FACM%2Fleetcode%2F15.3Sum%2F</url>
    <content type="text"><![CDATA[123456789101112131415Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; int i = 0, j, k; vector&lt;vector&lt;int&gt; &gt; result; if (nums.size() &lt; 3) return result; sort(nums.begin(), nums.end()); while(i &lt; nums.size() - 2 &amp;&amp; nums[i] &lt;= 0) &#123; j = i + 1; k = nums.size() - 1; while (j &lt; k) &#123; if (nums[j] + nums[k] == -nums[i]) &#123; vector&lt;int&gt; vecTemp = &#123;nums[i], nums[j], nums[k]&#125;; result.push_back(vecTemp); while(nums[j] == nums[++j])&#123;&#125; while(nums[k] == nums[--k])&#123;&#125; &#125; else if (nums[j] + nums[k] &gt; -nums[i]) k--; else j++; &#125; while(nums[i] == nums[++i]) &#123;&#125; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo迁移]]></title>
    <url>%2F2018%2F12%2F11%2Fhexo%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[自用迁移方法 mathjaxcsdn参考 1npm install hexo-renderer-mathjax --save search本地搜索csdn参考 1npm install hexo-generator-searchdb --save git deploy安装hexo-deployer-git 1npm install hexo-deployer-git --save next主题 1git clone https://github.com/theme-next/hexo-theme-next themes/next --depth=1]]></content>
      <categories>
        <category>hexo 迁移</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[93.Restore IP Address]]></title>
    <url>%2F2018%2F12%2F11%2FACM%2Fleetcode%2F93.Restore-IP-Address%2F</url>
    <content type="text"><![CDATA[Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: Input: “25525511135”Output: [“255.255.11.135”, “255.255.111.35”] 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; dfs(0,0,"",s); return ans; &#125; void dfs(int start,int count,string ip,string &amp;s) &#123; if(count &gt; 4) return; if(count == 4 &amp;&amp; start == s.size()) &#123; ip.resize(ip.size() -1); ans.push_back(ip); return; &#125; for(int i = 1;i &lt; 4;i++) &#123; if(start + i &gt; s.size()) break; string tmp = s.substr(start,i); if(tmp[0] == '0' &amp;&amp; tmp.size() &gt; 1) continue; if(stoi(tmp) &lt;= 255) &#123; dfs(start+i,count+1,ip+tmp+".",s); &#125; &#125; &#125; vector&lt;string&gt; ans;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.longest-substring-without-repeating-characters]]></title>
    <url>%2F2018%2F12%2F07%2FACM%2Fleetcode%2F3.longest-substring-without-repeating-characters%2F</url>
    <content type="text"><![CDATA[Given a string, find the length of the longest substring without repeating characters. 123456789101112131415161718class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int last[256];//记录字符上次出现的位置 int start=0;//当前起始 memset(last,-1,sizeof(last)); int len = s.length(); int m_max = 0; for(int i = 0;i &lt; len;i++) &#123; if(last[s[i]] &gt;= start) &#123; //重复出现 m_max = max(i-start,m_max); start = last[s[i]] + 1; &#125; last[s[i]] = i; &#125; return max(len-start,m_max); &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[747.network-delay-time]]></title>
    <url>%2F2018%2F12%2F07%2FACM%2Fleetcode%2F743.network-delay-time%2F</url>
    <content type="text"><![CDATA[There are N network nodes, labelled 1 to N. Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target. Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1. Note:N will be in the range [1, 100].K will be in the range [1, N].The length of times will be in the range [1, 6000].All edges times[i] = (u, v, w) will have 1 &lt;= u, v &lt;= N and 1 &lt;= w &lt;= 100. Dijkstra123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; priority_queue&lt;pair&lt;int,int&gt; &gt; q; vector&lt;int&gt; dis(N+1,100); int visit[N+1]&#123;0&#125;; visit[K] =1; dis[K] = 0; q.push(make_pair(0,K)); while(!q.empty()) &#123; int t = q.top().second; q.pop(); for(int i = 0;i &lt; times.size();i++) &#123; if(t == times[i][0]) &#123; int to = times[i][1]; int di = times[i][2]; if(dis[to] &gt; dis[t] + di) &#123; dis[to] = dis[t] + di; q.push(make_pair(dis[to],to)); visit[to] = 1; &#125; &#125; &#125; &#125; int res = 0; for(int i = 1;i &lt; N+1;i++) &#123; if(visit[i]==0) return -1; if(dis[i] &gt; res) res = dis[i]; &#125; return res; &#125;&#125;; Bellman-Ford1234567891011121314151617181920class Solution &#123;public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; vector&lt;int&gt; dis(N+1,101); dis[K] = 0; for(int i = 1;i &lt; N;i++) &#123; for(auto time:times) &#123; int from = time[0]; int to = time[1]; int weight = time[2]; if(dis[to] &gt; dis[from] + weight) dis[to] = dis[from] + weight; &#125; &#125; int res = *max_element(dis.begin() + 1,dis.end()); if(res == 101) return -1; return res; &#125;&#125;; Floyd-Warshall123456789101112131415161718192021222324class Solution &#123;public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; vector&lt;vector&lt;int&gt; &gt; dis(N+1,vector&lt;int&gt;(N+1,101 * 100)); for(auto time:times) &#123; dis[time[0]][time[1]] = time[2]; &#125; for(int i = 1;i &lt;= N;i++) &#123; dis[i][i] = 0; &#125; for(int k = 1;k &lt;= N;k++) &#123; for(int i = 1;i &lt;= N;i++) &#123; for(int j = 1; j &lt;= N;j++) &#123; dis[i][j] = min(dis[i][j],dis[i][k]+dis[k][j]); &#125; &#125; &#125; int res = *max_element(dis[K].begin() + 1,dis[K].end()); return res &gt;= 101 * 100? -1:res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[567. Short Permutation in a Long String]]></title>
    <url>%2F2018%2F12%2F03%2FACM%2Fleetcode%2F567.permutation-in-string%2F</url>
    <content type="text"><![CDATA[Short Permutation in a Long StringGiven two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.Example 1:Input:s1 = “ab” s2 = “eidbaooo”Output:TrueExplanation: s2 contains one permutation of s1 (“ba”).Example 2:Input:s1= “ab” s2 = “eidboaoo”Output: FalseNote:The input strings only contain lower case letters.The length of both given strings is in range [1, 10,000]. 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int len1 = s1.length(),len2 = s2.length(); if(len1 &gt; len2) return false; vector&lt;int&gt; s1_map(26,0),s2_map(26,0); for(int i = 0;i &lt; len1;i++) &#123; s1_map[s1[i] - 'a']++; s2_map[s2[i] - 'a']++; &#125; for(int i = 0;i &lt;= len2 - len1;i++) &#123; if(isMatch(s1_map,s2_map)) return true; s2_map[s2[i] - 'a']--; s2_map[s2[i+len1] - 'a']++; &#125; return false; &#125; bool isMatch(vector&lt;int&gt; &amp; s1_map,vector&lt;int&gt; &amp; s2_map) &#123; for(int i = 0;i &lt; 26;i++) &#123; if(s1_map[i] != s2_map[i]) &#123; return false; &#125; &#125; return true; &#125;&#125;; Solution Brute Force[Time Limit Exceeded] Using sorting[Time Limit Exceeded] Using Hashmap[Time Limit Exceeded] Using Array[Accepted] Sliding Window[Accepted] Optimized Sliding Window[Accepted] 参考链接]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中级网络爬虫]]></title>
    <url>%2F2018%2F11%2F20%2Fpython%2F%E4%B8%AD%E7%BA%A7%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[数据存储SQLiteMySQL MongoDb基于分布式文件存储的数据库,由C++语言编写，旨在为Web应用提供可扩展的高性能数据存储解决方案。数据库和数据表都惰性创建的 安装和配置1export PATH=/home/ubuntu/mongodb/bin:$PATH 启动1sudo ./mongod --dbpath /home/data/db 启动参数 基本概念 文档的三个特性 文档的键值对是有序的，顺序不同文档不同 文档的值可以是字符串，整数，数组以及文档等类型 文档的键是用双引号标识的字符串（常见的）键不能含有\0,用来标识结尾，.和$被保留，存在特别含义心_开关的键被保留 文档区分大小写和值类型 集合集合名不能是空字符串集合名不能含有\\0集合不能以system开关用户创建的集合不能含有保留字符 数据库默认数据库为db. 该数据库存储在data目录中，这就是为什么在data目录下创建db文件夹。MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中，在MongoDB的shell窗口中，使用show dbs命令可以查看所有的数据库，使用db命令查看当前的数据库 数据类型 创建/删除数据库1use DATABASE_NAME 如果数据库不存在，则创建数据库，否则创建切换到指定数据库，1db.dropDatabase() 删除当前数据库，使用db命令查看当前数据库名创建一个pythonSpider的数据库，接着再删除12345use pythonSpiderdb.pythonSpider.insert(&#123;&quot;url&quot;:&quot;www.google.com&quot;&#125;)db.dropDatabase() 增删改查所有存储在集合中的数据都是BSON格式插入文档1234567db.COLLECTION_NAME.insert(document)db.python.insert(&#123;title:&apos;python&apos;,desciption:&apos;动态语言&apos;,url:&apos;http://www.python.org&apos;,tags:[&apos;动态&apos;,&apos;编程&apos;,&apos;脚本&apos;],likes:10&#125;) 查询 1234db.COLLECTION_NAME.find()db.python.find()相当于select * from python 可以使用pretty()方法更加易读条件语句和操作符find()方法可以传入多个键(key),每个键以逗号隔开，来实现AND条件12db.COLLECTION_NAME.find(&#123;key:value1, key2:value2&#125;).pretty()db.python.find(&#123;&apos;likes&apos;:&#123;%gte:100&#125;,&apos;title&apos;:&apos;python&apos;&#125;).pretty() 更新文档update()方法和save()方法123456789db.collection.update( query, update, &#123; upsert:boolean multi:boolean writeConcern:document &#125;) query: 查询条件，类似where子句update: update的对象和一些更新的操作符集合upsert: 可选，这个参数的意思是如果不存在update的记录是否插入新的文档true为是默认falsemulti,可选，默认为false,只更新找到的第一条记录，如果为true，则全部更新writeConcern: 抛出异常的级别 12db.python.update(&#123;&apos;title&apos;:&apos;python&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;python爬虫&apos;&#125;&#125;)db.python.update(&#123;&apos;title&apos;:&apos;python&apos;&#125;,&#123;$set:&#123;&apos;title&apos;:&apos;python爬虫&apos;&#125;&#125;,&#123;multi:true&#125;) save()方法通过传入的文档来替换已有文档原型如下:123456db.collection.save(document,&#123; writeConcern:document&#125;) document:文档数据writeConcern: 可选，抛出异常的级别通过_id来识别 删除文档1234567db.collection.remove( query, &#123; justOne:boolean, writeConcern:document &#125;) 如果没有query条件，意味着删除所有文档 Python 操作MongoDB 导入pymongo数据库模块 12pip install pymongoimport pymongo 建立连接pymongo模块使用MongoClient对象来描述一个数据库客户端，创建对象所需的参数主要是host和port。常见的三种形式： 123client=pymongo.MongoClient()client=pymongo.MongoClient('localhost',27017)client=pymongo.MongoClient('mongodb'://localhost:27017) 获取数据库一个MongoDB实例可以支持多个独立的数据库，使用pymongo时，可以通过访问MongoClient的属性的方式来访问数据库 12db=client.papaersdb=client['pa-pers']#如果数据库名字导致属性访问方式不能用 获取一个集合 12collection=db.bookscollection=db['books'] 插入文档 12345678910111213141516book=&#123;'author':'mike','text':'my first book','tags':['爬虫','python','网络'],'date':datetime.datetime.utcnow()&#125;book_id=collection.insert(book)book=[&#123;'author':'mike','text':'my first book','tags':['爬虫','python','网络'],'date':datetime.datetime.utcnow()&#125;,&#123;'author':'sfsf', 'text':'tet', 'tage':['wfewf', 'fww','wfw'], 'date':datetime.datetime.utcnow()&#125;]&#125; 查询文档 123456collection.find_one()collection.find_one(&#123;'author':'qiye'&#125;)collection.find_one('_id':ObjectID('5734224342435235f2334'))# 常用于Web应用，可以从URL抽取id从数据库中进行查询# 多个文档for book in collection.find(): print book 修改文档MongoDB可以使用update()和save方法，和在MongoDB shell中的操作类似 1collection.update(&#123;'author',:'qiye'&#125;,&#123;"$set":&#123;"text":'python book'&#125;&#125;) 删除文档 1collection.remove(&#123;'author':'qiye'&#125;) 动态网站爬取Ajax和动态HTML 使用JavaScipt动态分析优点：快缺点：手动分析复杂 PhantomJS没有界面的浏览器，运行JavaScript脚本 Selenium自动化测试工具，支持各种浏览器，支持多语言Python+Selenium+PhantonJS的组合，PhantomJS负责渲染解析JavaSciipt,Selenium负责浏览器和与Python对接 安装Python负责做后期处理 元素选取页面操作等待Web端协议分析网页登录POST分析加密数据分析验证码IP代理Cookie登录识别终端协议分析PC客户端抓包分析APP抓包分析SCrapy架构 Scrapy引擎（Engine)。引擎负责控制数据流在系统的所有组件中流动，并在相应动作发生时触发事件 调度器(Scheduler)。调度器从引擎接收Request并将它们入队，以便之后引擎请求request时提供给引擎 下载器(Downloader)。下载器负责获取页面数据并提供给引擎，而后提供给Spider Spider。Spider是Scrapy用户编写用于分析Response并提取Item(即获取到的Item)或额外跟进的URL类。每个Spider负责处理一个特定（或一些）网站 Item Pipeline。Item Pipeline负责处理被Spider提取出来的Item。典型的处理有清理验证及持久化（例如存储到数据库中） 下载器中间件(Downloader middle) 下载器中间件是在引擎及下载器之间的特定钩子(specific hook)，处理Downloader传递给引擎的Response。其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能 Spider中间件(Spider middlewares).Spider中间件是引擎及Spider的特定钩子(specific hook),处理Spider的输入response和输出(Items及Requests)其提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能。数据流 引擎打开一个网站(open a domain)，找到处理该网站的Spider并向该Spider请求第一个要爬取的URL 引擎从Spider中获取到第一个要爬取的URL并通过调度器(Scheduler)以Request进行调度 引擎向调度器请求下一个要爬取的URL。 调度器返回下一个要爬取的URL。 一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件(返回(response)方向)发送给引擎 引擎从下载器中接收到Response并通过Spider中间件（输入方向)发送给Spider处理 Spider处理Response并返回爬取的Item及（跟进的)新的Request给引擎 引擎将（Spider返回的）爬取到的Item给Item Pipeline，将(Spider返回的)Request给调度器 （从第二步)重复直到调度器中没有更多的Request,引擎关闭该网站 爬虫模块爬虫模块是用于从单个网站或者多个网站爬取数据的类，其应该包含初始页面的URL，以及跟进网页链接，分析页面内容和提取数据函数创建一个Spider类，需要继承scrapy.Spider类并定义以下三个属性 name: 区别Spider start_urls: 入口URL列表 parse(): 被调用时，每个初始URL响应后返回Response对象。将会作为唯一的参数传递给该方法。方法负责解析返回的数据(response data),提取数据(生成Item)以及生成需要进一步处理的URL的Request对象 选择器通过特定的XPath或者CSS表达式来选择HTML文件中的某个部分。Selector对象4个基本方法: xpath(query): 传入XPath表达式query,返回表达式所对应的所有节点的selector list列表 css(query): 传入CSS表达式query, 返回该表达式所对应的所有节点的selector list列表 extract(): 序列化节点为Unicode字符串并返回list列表 re(regex): 根据传入的正则表达式对数据进行提取，返回Unicode字符串列表。regex可以是一个已编译的正则表达式，也可以是一个将被re.compile(regex)编译为正则表达式的字符串命令行工具全局命令 startproject settings runspider 在未创建项目的情况下运行一个编写好的spider模块 shell[url] 用来启动Scrapy shell fetch 下载给定的URL,并将获取到的内容送到标准输出 view # 在浏览器打开给定的URL并以Scrapy spider获取到的形式展现 version bench # 运行benchmark测试 项目命令 crawl 用来使用spider进行爬取 check [-l] 运行contract检查 list 列出项目上所有可用的spider edit parse 获取给定的URL并使用相应的spider分析处理 genspider deploy 将项目部署到Scrapyd服务 定义Item爬取的主要目标就是从非结构性的数据源提取结构性数据。scrapy提供Item类来满足这样的需求。Item对象是一种简单的容器，用来保存爬取到的数据，提供了类似于词典API以及用于声明可用字段的简单语法。Item使用简单的class定义语法以及Field对象来声明 创建获取字段的值设置字段的值获取所有的键和值复制dict与item的转化item扩展 Item Pipeline当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理典型应用： 清理HTML数据 验证爬取的数据的合法性，检查Item是否包含某些字段 查重并丢弃 将爬取结果保存到文件或数据库中定制Item Pipeline每个Item Pipeline组件是一个独立的Python类，必须实现process_item方法1process_item(self, item, spider) 每个Item Pipeline组件都需要调用该方法，这个方法必须返回一个Item(或任何继承类)对象，或者抛出DropItem异常，被丢弃的Item将不会被之后的Pipeline组件所处理item对象为被爬取的ItemSpider对象代表着爬取该Item的Spider 激活Item Pipelinesettings.py必须将它的类添加到settings.py中的ITEM_PIPELINES变量中 内置数据存储简单的存储方式，通常叫做输出(feed)1scrapy crawl cnblogs -o papers.csv 内置图片和文件下载方式FilesPipeline或者ImagesPipeline特性： 避免重新下载最近已经下载过的数据 指定存储的位置和方式ImagesPipeline额外特性： 将所有下载的图片转换通用的格式(JPG)和模式(RGB) 缩略图生成 检测图像的宽/高，确保它们满足最小限制这个管道也会为那些当前安排好林下载的图片保留一个内部队列，并将那些到达的包含相同图片的项目连接到该队列中这可以避免多次下载几个Item共享的同一个图片FilesPipeline工作流程： 在一个爬虫里，爬取一个Item，把其中文件的URL放入file_rls组内 item从爬虫内返回时，进入 Item pipeline 当items进入 Pipelines, files_url组内的URL将被Scrapy的调度器和下载器安排下载，如果优先级更高，会在其他页面爬取前处理。item会在这个特定的管道阶段保持”locker”的状态，直到文件完成下载 当文件下载完成后，另一个字段(files)将被更新到结构中ImagesPipeline工作流程类似Pillow用来生成缩略图，并将图片化成JPG/RGB格式python imaging library(PIl),在一些设置里会出现问题使用FilePipeLine 在setting.py文件中的ITEM_PIPELINES中添加类 在item中添加两个字段 12file_urls = scrapy.Field()files = scrapy.Field() 在settings.py文件中添加下载路径FILES_STORE,文件url所有的item字段FILES_URLS_FIELD和文件结果信息所在的item字段FILES_RESULT_FILED使用FILES_EXPIRES设置文件过期时间 1234FILES_STORE = '.\/cnblogs'FILES_URLS_FIELD = 'file_urls'FILES_RESULT_FIELD = 'files'FILES_EXPIRES = 30 # 30天过期 ImagesPipeline 使用IMAGES_THUMBS制作缩略图，并设置尺寸大小1234IMAGES_THUMBS = &#123; 'small': (50,50), 'big': (270,270),&#125; 定制化图片文件保存重写get_media_requests(item, info)方法item_completed(result, items, info) 启动爬虫由于Scrapy是在Twisted异步网络库上构建的，因此必须在Twisted reactor里运行第一种方法使用CrawlerProcess类，这个类内部将会开启Twisted reactor,配置log和设置twisted reactor自动关闭另一种使用CrawlerRunner，在spider运行结束后必须自行关闭Twisted reactor，需要在CrawlerRunner.crawl所返回的对象中添加回调函数 强化爬虫调试方法 parse命令 Scrapy shell logging异常控制运行状态 访问telnet 深入Scrapy爬虫框架Spider类定义了如何爬取某个或某些网站，包括了爬取的动作（例如是否跟进链接），以及如何从网页的内容中提取结构化数据item。换句话说，Spider是定义爬取的动作及分析网页结构的地方。对Spider来说，爬取的循环流程如下：1）以入口URL初始化Request，并设置回调函数。此Request下载完毕返回Response，并作为参数传给回调函数。spider中初始的Request是通过调用start_requests（）方法来获取的，start_requests（）读取start_urls中的URL，并以parse为回调函数生成Request。2）在回调函数内分析Response，返回Item对象、dict、Request或者一个包括三者的可迭代容器。其中返回的Request对象之后会经过Scrapy处理，下载相应的内容，并调用设置的回调函数，可以是parse（）或者其他函数。3）在回调函数内，可以使用选择器（Selectors）或者其他第三方解析器来分析response，并根据分析的数据生成item。4）最后，由spider返回的item可以经由Item Pipeline被存到数据库或使用Feed exports存入到文件中。 scrapy.SpiderSpider并没有提供什么特殊的功能，仅仅提供了start_requests()的默认实现，读取并请求spider属性听start_urls,并根据返回的response调用spider的parse方法常用属性 name allowed_domains start_urls custom_settings 该设置是一个dict，当启动spider时，该设置将会覆盖项目级的设置，由于设置必须在初始化前被更新，所以该属性必须定义为class属性 crawler 该属性在初始化class后，由类方法from_crawler()设置，并且链接了本spider实例对应的Crawler对象。Crawler包含了很多项目中的组件，作为单一的入口点常用方法 start_requests()方法，该方法必须返回一个可迭代对象，该对象包含了spider用于爬取的第一个Request。当spider启动爬取并且未制定URL时，该方法被调用。当指定了URL时，make_requests_from_url将被调用来创建Request对象。该方法仅仅会被Scrapy调用一次，因此可以将其实现为生成器。该方法的默认实现是使用start_urls的url生成Request。如果想要修改最初爬取某个网站的Request对象，可以重写该方法。例如在进行深层次爬取时，在启动阶段需要POST登录某个网站，获取用户权限，示例代码： 123456789class Myspider(scrapy.Spider): name = 'myspider' def start_request(self): return [scrapy.FormRequest('http://www.example.com/login',formdata=&#123;'user':'john','pass':'secret'&#125;, callback = self.login)] def login(self, response): pass make_requests_from_url(url)方法。该方法接受一个URL并返回用于爬取的Request对象。该方法在初始化request时被start_requests（）调用，也用于转化URL为Request。默认未被复写（overridden）的情况下，该方法返回的Request对象中，parse作为回调函数·parse（response）方法。response参数即用于分析的response。当response没有指定回调函数时，该方法是Scrapy处理下载的response的默认方法。 parse负责处理response并返回处理的数据以及跟进的URL，该方法及其他的Request回调函数必须返回一个包含Request、dict或Item的可迭代的对象。 closed（reason）方法。当spider关闭时，该函数被调用。可以用来在spider关闭时释放占用的资源。Scrapy除了提供了Spider类作为基类进行拓展，还提供了CrawlSpider、XMLFeedSpider、CSVFeedSpider和SitemapSpider等类来实现不同的爬虫任务 CrawlSpider爬取一般网站，其定义了一些规则(rule)来提供跟进链接功能，使用方便。多个Rule对爬取动作定义了特定的规则 XMLFeedSpiderItem LoaderItems可以使用自带的类字典形式API填充，Items Loader提供了更便捷的API可以分析原始数据并对Item进行赋值。Items提供保存爬取数据的容器，item Loader提供的是填充的机制。item loaders提供的是一种灵活，高效的机制，可以更方便地被spider或HTML，XML等文件扩展，重写不同字段的解析规则这对大型的爬虫项目的后期维护非常有利，拓展新的功能更加方便。 内置处理器 identity不进行任何处理，直接返回原来的数据无参数 TaskFirst返回第一个非空值，用于单值字段的输出处理器，无参数。 Join返回分隔符separator连接后的值 Compose用给定的多个方法的组合来构造处理器，每个输入值被传递到第一个方法，然后其输出再传递到第二个方法直到最后一个方法返回整个处理器的输出。 MapCompose和Compose类似，也是用给定的多个方法的组合来构造处理器，不同的是内部结果在方法传递的方式：处理器的输入值是被迭代处理的，每一个元素被单独传入第一个函数进行处理，处理的结果被串连起来形成一个新的迭代器，并被传入第二个函数，以此类推，直到最后一个函数。最后一个函数的输出被连接起来形成处理器的输出。·每个函数能返回一个值或者一个值列表，也能返回None。如果返回值是None，此值会被下一个函数所忽略。这个处理器提供了方便的方式来组合多个处理单值的函数 SelectJmes使用指定的jsonpath查询并返回值。需要jmespath的支持，而且每次只接受一个输入 输入和输出处理器item loader负责了数据的收集，处理和填充。item仅仅承载了数据本身而已。 Item loader ContextItem loader context 是一个任意的键值对字典，能被Item Loader中的输入输出处理器所共享。它在Item Loader声明，实例化，使用的时候传入，可以调整输入输出处理器的行为。 重用和扩展Item Loader当爬虫项目越来越大，使用的Spider越来越多时，项目的维护将成为一个要紧的问题。特别是维护每一个Spider中许多而且不同的解析规则时，会出现很多异常，这个时候需要考虑重用和拓展的问题了。 Item Loader本身的设计就是为了减轻维护解析规则的负担，而且提供了方便的接口，用来重写和拓展他们。Item Loader支持通过传统Python类继承的方式来处理不同Spider解析的差异。 ItemPipeLine三个重要方法 open_spider(self,spider)spider是一个Spider对象，代表被开启的Spider.当Spider被开启时，这个方法被调用 close_spider(self,spider)参数spider是一个Spider对象，代表被关闭的Spider。当Spider被关闭时，这个方法被调用 from_crawler(cls,crawler)参数crawler是一个Crawler对象这个类方法从Crawler属性中创建一个pipeline实例，Crawler对象能够接触所有Scrapy的核心组件，比如settings和signals 当项目中有很多Spider在运行时，Item Pipeline的处理就会很麻烦，可以通过process_item(self,item,spider)中的spider参数判断来自那个爬虫，更好的做法是配置Spider类中的custom_settings对象，为每一个Spider配置不同的Pipeline 请求和响应Request对象一个Request对象代表一个HTTP请求，通常在Spider类中产生，然后传递给下载器，最后返回一个响应类原型：1class scrapy.http.Request(url[], callback, method='GET',headers,body, cookies,meta,encoding='utf-8',priority=0,dont_filter=False,errback) 参数说明：callback(callbale):指定用于解析请求响应的方法默认为spider的parse()方法meta(dict): 初始化Request.meta属性body(str or unicode): 请求的bodyheaders(dict): 请求头cookies(dict or list): 请求的cookie信息dont_filter(boolean):表明该请求不应由调度器过滤。适用场景为想多次执行相同的请求的时候，小心使用它，否则会进入爬行循环。默认为Falseerrback(callable)，如果在处理请求的过程中出现异常，指定的方法将会被调用常见属性 Request.meta常用键值 FormRequest专门用来处理HTML表单class scrapy.http.FromRequest(url,[formdata],callback=,…) 隐藏表单处理from_response(resoponse,[],callback=,…) Response对象原型1scrapy.http.Response(url,[],status=200,headers,body,flags) 常用属性和方法 下载器中间件下载器中间件是介于Scrapy的request/response处理的钩子框架，是用于全局修改Scrapy的request和response激活设置Settings.py123DOWNLOADER_MIDDLEWARES = &#123; 'myproject.middlewares.CustomDownloaderMiddleware':543,&#125; 在Settings.py中对DOWNLOADER_MIDDLEWARES的设置，会和Scrapy内置的下载器中间件设置合并，但不会覆盖，根据顺序值进行排序。最后一个中间件是最靠近下载器的。 分配中间件的位置，中间件的的设置顺序非常重要。 编写每个组件是定义了以下一个或多个方法的Python类：process_request(request, spider)process_response(request, response, spider)process_exception(request, exception, spider) process_request(request, spider)当每个Request通过下载中间件时，该方法被调用，返回值必须为None,Response对象，Request对象中的一个或RaiseIgnoreRequest异常返回值： 如果返回None， Scrapy将继续处理该Request,执行其他的中间件的相应方法，直到合适的下载器处理函数被调用，该Request被执行（其Response被下载）。如果返回Response对象，Scrapy不会调用其他的process_request（），process_exception（）方法，或相应的下载方法，将返回该response。已安装的中间件的process_response（）方法则会在每个response返回时被调用。如果返回Request对象，Scrapy则停止调用process_request方法并重新调度返回的Request。当新返回的Request被执行后，相应地中间件链将会根据下载的Response被调用。如果是Raise IgnoreRequest异常，则安装的下载中间件的process_exception（）方法会被调用。如果没有任何一个方法处理该异常，则Request的errback方法会被调用。如果没有代码处理抛出的异常，则该异常被忽略且不记录。 process_response(request, response, spider)方法说明：该方法主要用来处理产生的Response，返回值必须是Response对象、Request对象中的一个或Raise IgnoreRequest异常。参数：request（Request对象）：Response对应的Request。response（Response对象）：处理的Response。spider（Spider对象）：Response对应的Spider。返回值：如果返回Response对象，可以与传入的Response相同，也可以是新的对象，该Response会被链中的其他中间件的process_response（）方法处理。如果返回Request对象，则中间件链停止，返回的Request会被重新调度下载。处理类似于process_request（）返回Request时所做的那样。如果抛出IgnoreRequest异常，则调用Request的errback方法。如果没有代码处理抛出的异常，则该异常被忽略且不记录。 process_exption(request, exception, spider)方法说明：当下载处理器或process_request（）抛出异常，比如IgnoreRequest异常时，Scrapy调用process_exception（）。process_exception（）应该返回None、Response对象或者Request对象其中之一。参数：request（Request对象）：产生异常的Request。exception（Exception对象）：抛出的异常。spider（Spider对象）：Request对应的Spider。返回值：如果返回None，Scrapy将会继续处理该异常，接着调用已安装的其他中间件的process_exception（）方法，直到所有中间件都被调用完毕，则调用默认的异常处理。如果返回Response对象，则已安装的中间件链的process_response（）方法被调用。Scrapy将不会调用任何其他中间件的process_exception（）方法。如果返回Request对象，则返回的request将会被重新调用下载，这将停止中间件的process_exception（）方法执行，类似于返回Response对象的处理。 12345678910111213141516171819202122232425262728class RandomUserAgent(object): def __init__(self, agents): self.agents = agents; @classmethod def from_crawler(cls,crawler): # 从Setting 中加载User-Agent的值 return cls(crawler.setting.getlist('USER-AGENTS')) def process_request(self,request,spider): request.headers.setdefault('User-Agent',random.choice(self,agents))class RandomProxy(object): def __init__(self,iplist): self.iplist=iplist @classmethod def from_crawler(cls, crawler): return cls(crawler.settings.getlist('IPLIST')) def process_request(self, request, spider): proxy = random.choice(self,iplist) request.meat['proxy'] = proxy Spider中间件Spider中间件是介入到Scrapy的Spider处理机制的钩子框架，可以用来处理发送给Spiders的Response及Spider产生的Item和Request 激活键是中间件的路径，值为中间件的顺序123SPIDER_MIDDLEWARES = &#123; 'myproject.middleware.CustomSpiderMiddleware':543&#125; SPIDER_MIDDLEWARES_BASEK中内置中间件并不是都开启的，有些中间件需要特定的设置来启用 编写process_spider_input(response, spider)process_spider_output(response, result, spider)process_spider_exception(response, exception, spider)process_start_requests(start_requests, spider) process_spider_input(response, spider)如果返回None，Scrapy将会继续处理该response，调用所有其他的中间件直到spider处理该response。如果产生一个异常，Scrapy将不会调用任何其他中间件的process_spider_input（）方法，并调用request的errback。errback的输出将会以另一个方向被重新输入到中间件链中，使用process_spider_output（）方法来处理，当其抛出异常时，则调用process_spider_exception（） process_spider_output(response,result,spider)参数：response（Response对象）：生成该输出的Response。result：Spider返回的Result，是包含Request、Dict或Item的可迭代对象。spider（Spider对象）：其结果被处理的Spider。返回：process_spider_output（）必须返回包含Request、dict或Item对象的可迭代对象（iterable）。 process_spider_exception(response, exception, spider)参数：response（Response对象）：生成该输出的Response。result：Spider返回的Result，是包含Request、Dict或Item的可迭代对象。spider（Spider对象）：其结果被处理的Spider。返回：process_spider_output（）必须返回包含Request、dict或Item对象的可迭代对象（iterable）。 process_start_requests(start_requests, spider)方法说明：该方法以spider启动的request为参数，执行的过程类似于process_spider_output（），其接受一个可迭代的对象（start_requests参数）且必须返回另一个包含Request对象的可迭代对象。参数：·start_requests（包含Request的可迭代对象）：起始Requests。·spider（Spider对象）：起始Requests所属的Spider。 URL 规范化中间件 12345678910111213from scrap.http import Requestfrom scrapy.utils.url import canonicalize_urlclass UrlCanonicalizerMiddleware(object): def process_spider_output(self, response, result, spider): for r in result: if isinstance(r, Request): curl = canonicalize_url(r.url) if curl != canonicalize_url(r.url): r = r.replace(url = curl) yield r 扩展扩展框架提供了一种机制，可以将自定义功能绑定到Scrapy中，扩展只是正常的Python类，会在Scrapy启动时被实例化，初始化 配置扩展扩展需要在settings中进行设置。和中间件的设置类似扩展的状态： 可用的 开启的 禁用的 定制扩展扩展类是一个不同的Python类，但是如果想操作Scrapy的功能，需要一个入口：from_crawler类方法，它接收一个Crawler类的实例，通过这个对象可以访问settings（设置）、signals（信号）、stats（状态），以便控制爬虫的行为。通常来说，扩展需要关联到signals并执行它们触发的任务，如果from_crawler方法抛出NotConfigured异常，扩展会被禁用。否则，扩展会被开启。下面通过一个例子来实现简单扩展，功能是当出现以下事件时，记录一条日志： Spider被打开 Spider被关闭 爬取了特定数量的Item 1234567891011121314151617181920212223242526272829303132333435363738394041# coding:utf-8import loggingfrom scrapy import signalsfrom scrapy.exceptions import NotConfiguredlogger = logging.getLogger(__name__)class SpiderOpenCloseLogging(object): def __init__(self, item_count): self.item_count = item_count self.items_scraped = 0 @classmethod def from_crawler(cls, crawler): if not crawler.settings.getbool('MYEXT_ENABLED'): raise NotConfigured item_count = crawler.settings.getint('MYEXT_ITEMCOUNT',1000) ext = cls(item_count) crawler.signal.connect(ext.spider_opened, signals=signals.spider_opened) crawler.signal.connect(ext.spider_closed,signals=signals.spider_closed) crawler.signal.connect(ext.items_scraped,signals=signals.item_scraped) return ext def spider_opened(self, spider): logger.info('Open spider %s', spider.name) def spider_closed(self, spider): logger.info('closed spider %s', spider.name) def item_scraped(self,item, spider): self.item_scraped += 1 if self.items_scraped % self.item_count == 0: logger.info('scraped %d items' , self.items_scraped) 编写扩展依赖Crawler实例，需要设置信号 engine_start engine_stopped 内置扩展 反爬虫突破验证码Headers用户行为动态页面 突破方式UserAgent池禁用Cookies设置下载延时与自动限速代理IP池Tor代理分布式下载器：CrawleraGoogle cache]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫]]></title>
    <url>%2F2018%2F11%2F19%2Fpython%2F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬虫结构代码示例全为python3 首先选取一部分精心挑选的种子URL。 将这些URL放入待抓取URL队列。 从待抓取URL队列中读取待抓取队列的URL，解析DNS，并且得到主机的IP，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。 分析已抓取URL队列中的URL，从已下载的网页数据中分析出其他URL，并和已抓取的URL进行比较去重，最后将去重过的URL放入待抓取URL队列，从而进入下一个循环。 Python实现urllib请求和响应模型get1234567891011121314import urllib.requestresponse=urllib.request.urlopen('http://www.zhihu.com')html=response.read()print(html)import urllib.requestrequest=urllib.request.Request('http://www.zhihu.com')response=urllib.request.urlopen(request)html=response.read()print(html) post数据12345678910import urllib.requesturl = 'http://www.baidu.com/login'postdata = &#123;'username': 'qiye', 'password': 'qiye_pass'&#125;data = urllib.parse.urlencode(postdata).encode('utf-8')req = urllib.request.Request(url, data)res = urllib.request.urlopen(req)html = res.read().decode('utf-8')print(html) header处理12345678910111213import urllib.requesturl = 'http://www.baidu.com/login'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'referer = 'http://www.baidu.com'postdata = &#123;'username': 'qiye', 'passwd': 'qiye_pass'&#125;headers = &#123;'User-Agent': user_agent, 'Referer': referer&#125;data = urllib.parse.urlencode(postdata).encode('utf-8')req = urllib.request.Request(url, data, headers)print(req)response = urllib.request.urlopen(req)html = response.read()print(type(html))print(html.decode('utf-8')) 也可以使用req.addheader方法req.add_header(‘User-Agent’, user_agent) cookie处理自动处理1234567import urllibimport http.cookiejarcookie = http.cookiejar.CookieJar()opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cookie))response = opener.open('http://www.zhihu.com')for item in cookie: print(item.name + ':' + item.value) 手动处理1234567import urllib.requestopener = urllib.request.build_opener()response = opener.addheaders.append(('Cookie', 'email' + 'wewerwr@163.com'))req = urllib.request.Request('http://www.zhihu.com')response = opener.open(req)print(response.headers)retdate = response.read() Timeout超时设置Http响应码重写向Proxy的设置httplib实现功能较少 RequestsGithub:Requests Get123import requestsr = requests.get('http://www.baidu.com')print(r.content) Post1234import requestspostdata = &#123;'key':'value'&#125;r = requests.post('http://www.baidu.com/login', data=postdata)print(r.content) 其他方法123456r = request.put('http://ww',data=&#123;'key':'value'&#125;)r = request.delete('http://fsfs.sf.com/delete')payload=&#123;'Keywords': 'blog:qiyeboy', 'pageindex':1&#125;r = requests.get('http://zzk.cnblogs.com/s/blogpost', params = payload)print(r.url) 响应和编码r.content #字节形式r.text #文本形式r.encoding #猜测格式 探测编码格式的包chardet1234567import requestsimport chardetpayload=&#123;'Keywords': 'blog:qiyeboy', 'pageindex':1&#125;r = requests.get('http://zzk.cnblogs.com/s/blogpost', params = payload)print(chardet.detect(r.content))r.encoding = chardet.detect(r.content)['encoding']print(r.text) 流模式r.raw.read(10)请求头处理在get函数中添加headers参数即可响应码和响应头处理123456789import requestsr = requests.get('http://www.baidu.com')if r.status_code == requests.codes.ok: print(r.status_code) print(r.headers) print(r.headers.get('content-type')) #推荐 print(r.headers['content-type']) #错误时返回Nonelse: r.raise_for_status() # 主动产生异常 cookie处理1234import requestsr = requests.get('http://www.baidu.com')for cookie in r.cookies.keys(): print(cookie +':'+ r.cookies.get(cookie)) 自定义cookie123456import requestsimport chardetcookies = dict(name='qiye',age='10')r=requests.get('http://www.badu.com',cookies=cookies)r.encoding = chardet.detect(r.content)['encoding']print(r.text) 更高级作法，每次访问时，程序自动把cookie的值带上，Request提供一个session的概念1234567891011import requestsloginUrl = 'http://www.baidu.com/login's = requests.Session()# 首先访问登录页面，作为游客，服务器会先分配一个cookier = s.get(loginUrl,allow_redirects=True)datas = &#123; 'name':'qiye','password':'qiye'&#125;r=s.post(loginUrl, data = datas,allow_redirects=True)r.encoding='utf-8'print(r.text) 如果没有第一步访问登录的页面，而是直接向登录链接发送Post请求，系统会将这个Cookie在发送Post请求时带上，这种使用Session函数处理Cookie的方式会很常用重定向1234import requestsr = requests.get('http://github.com')print(r.url)print(r.history) 超时1r = requestes.get('http://github.com', timeout=2) 代理设置123456import requestsproxies = &#123; 'http':'http://0.10.1.10:3128', 'https':'http://10.01.0.1:1080',&#125;requests.get('http://github.com', proxies=proxies) HTTP Basic Auth123proxies = &#123; 'http':'http://user:pass@10.0.0.1:3128'&#125; HTML解析Firebug工具正则表达式元字符\b代表单词的开关或结尾.匹配除了换行符的任意字符*任意表达式\bwe\b.*\bwork\b先匹配出we单词，接着再匹配任意的字符（非换行），直到匹配到work单词结束。无字符的四种作用： 匹配字符 匹配数量 匹配模式 匹配位置\d 匹配数字\w 匹配字母，数字，下划线或汉字\s 匹配任意空白符^ 匹配串的开始$ 匹配串的结束所有以s开关的单词\bs\w*\b匹配s100\bs\d*$字符转义\\重复* 0次或多次+ 1次或多次? 重复0次或一次{n} n次{n,} n到多次{n,m} n-m次hello\d+ 匹配hello后1个或更多数字^\d{5,12}$5-12个数字的字符串，qq号we\d we后面0个或者一个数字 we,we0字符集合分支条件分组反义后向引用零宽断言注释贪婪与懒惰处理选项 Python与正则原生字符串re模块 Beautiful soup一个可以从HTML或XML文件中提取数据的Python库支持标准库中的HTML解析器，支持一些第三方库lxml解析速度非常快,要ｃ语言支持纯Python的html5lib，解析方式和浏览器相同,速度慢 使用 创建对象 对象种类 遍历文档树(节点关系) 搜索文档树 css选择器lxml的XPath解析Beautiful和lxml的原理不一样，Beautiful基于DOM，会载入整个文档，解析整个DOM树，速度慢lxml使用XPath技术，局部处理，速度快FirePath自动生成XPath表达式 数据存储HTML正文抽取无JavaScript动态加载 json存储盗墓笔记示例标题和链接12345678910111213141516import requestsfrom bs4 import BeautifulSoupuser_agent = 'Mozilla/4.0 (compatible; MSIE 5.5;Windows NT)'headers = &#123; 'User-Agent':user_agent&#125;r = requests.get('http://seputu.com/',headers=headers)soup = BeautifulSoup(r.text, 'html.parser') #html.paserfor mulu in soup.find_all(class_="mulu"): h2 = mulu.find('h2') if h2 != None: h2_title = h2.string #标题 for a in mulu.find(class_='box').find_all('a'): #获取ａ标识中url和章节内容 href = a.get('href') box_title = a.get('title') print(href, box_title) 存储为json编码和解码json模块实现dumps和dump函数dump把Python对象转换成json对象，并将json对象通过fp文件流写入文件中而dumps则是生成了一个字符串。123456dumps(obj, skipkeys=False, ensure_ascii=True, checkcircular=True, allow_nan=True, cls=None, indent= None, separators=None, encoding='utf-8', default=None, sort_keys=False,**kw)dump(obj,fp, skipkeys=False, ensure_ascii=True, checkcircular=True, allow_nan=True, cls=None, indent= None, separators=None, encoding='utf-8', default=None, sort_keys=False,**kw) 解码1234loads(s,encoding=None,cls=None,object_hook=None, parse_float=None,parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)load(fp,encoding=None,cls=None,object_hook=None, parse_float=None,parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) 数据格式的变化 12345678910111213141516171819202122232425262728293031import requestsimport jsonfrom bs4 import BeautifulSoupuser_agent = 'Mozilla/4.0 (compatible; MSIE 5.5;Windows NT)'headers = &#123; 'User-Agent':user_agent&#125;r = requests.get('http://seputu.com/',headers=headers)soup = BeautifulSoup(r.text, 'html.parser') #html.pasercontent = []for mulu in soup.find_all(class_="mulu"): h2 = mulu.find('h2') if h2 != None: h2_title = h2.string #标题 list = [] for a in mulu.find(class_='box').find_all('a'): #获取ａ标识中url和章节内容 href = a.get('href') box_title = a.get('title') #print(href, box_title) list.append(&#123; 'href':href,'box_title':box_title &#125;) content.append(&#123; 'title':h2_title,'content':list &#125;)#print(content)with open('/tmp/qiye.json','w') as fp: json.dump(content,fp=fp,indent=4)with open('/tmp/qiye.json','r') as f1: print(json.load(f1)) CSV存储CSV（逗号分隔值），纯文本形式存储的表格数据。纯文本意味着该文件是一个字符序列，不含必须像二进制数字那样被解读的数据Python使用csv库读写csv文件python对象-&gt;csv文件csv文件-&gt;python对象使用数据索引使用命名元组列名是合法Python标识符时才生效字典序列 123456789101112131415161718192021222324252627282930313233343536373839404142434445from collections import namedtuplefrom lxml import etreeimport requestsimport reimport csvuser_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'headers=&#123; 'User-Agent':user_agent&#125;r = requests.get('http://seputu.com/',headers=headers)pattern = re.compile(r'\s*\[(.*)]\s+(.*)')html = etree.HTML(r.text)rows=[]div_mulus = html.xpath('.// *[@class="mulu"]') #所有div class=mulu标记for div_mulu in div_mulus: #div_h2标记 div_h2 = div_mulu.xpath('./div[@class="mulu-title"]/center/h2/text()') if len(div_h2) &gt; 0: h2_title = div_h2[0].encode('utf-8') a_s = div_mulu.xpath('./div[@class="box"]/ul/li/a') for a in a_s: #href href = a.xpath('./@href')[0].encode('utf-8') #titile box_title=a.xpath('./@title')[0] match = pattern.search(box_title) if match!=None: date = match.group(1).encode('utf-8') real_title=match.group(2).encode('utf-8') #print content=(h2_title,real_title,href,date) #print(content) rows.append(content)headers=['title','real_title','href','date']with open('qiye.csv','w') as f: f_csv = csv.writer(f,) f_csv.writerow(headers) f_csv.writerow(rows)with open('qiye.csv','r') as f1: f_csv = csv.reader(f1) headings = next(f_csv) for s in f_csv: print(s) 多媒体文件抽取使用urllib模块提供的urlretrieve()函数，urlretrieve()方法直接将远程数据下载到本地1urlretrieve(url, filename=None, reporthook=None, data=None) 123456789101112131415161718192021222324252627import urllibfrom lxml import etreeimport requestsdef Schedule(blocknum, blocksize, totalsize): '''''' blocknum:已经下载的数据块 blocksize:数据块大小 totalsize:远程文件的大小 '''''' per = 100.0 * blocknum*blocksize/totalsize if per &gt; 100: per=100 print('当前下载进度: %d' %per)user_agent='Mozilla/4.0 (compatible;MSIE 5.5; Windows NT)'headers=&#123; 'User-Agent':user_agent&#125;r = requests.get('http://www.ivsky.com/tupian/ziranfengguang/',headers=headers)#lxml解析html=etree.HTML(r.text)img_urls=html.xpath('.// img/@src')i=0for img_url in img_urls: urllib.request.urlretrieve(img_url,'img'+str(i)+'.jpg',Schedule) i+=1 Email提醒123456789101112131415161718192021222324252627282930from email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrimport smtplibdef _format_addr(s): name, addr = parseaddr(s) return formataddr((Header(name,'utf-8').encode(), addr))from_addr = 'xxxx@163.com'password = 'xxxx'to_addr = 'mctashuo@outlook.com'smtp_server='smtp.163.com'msg = MIMEText('Python爬虫运行异常，异常信息为遇到HTTP 403', 'plain', 'utf-8')msg['From'] = _format_addr('一号爬虫 &lt;%s&gt;' % from_addr)msg['To'] = _format_addr('管理员 &lt;%s&gt;' % to_addr)msg['Subject'] = Header('一号爬虫运行状态','utf-8').encode()#发送server = smtplib.SMTP(smtp_server, 25)server.login(from_addr, password)server.sendmail(from_addr, [to_addr], msg.as_string())server.quit() 基础爬虫100个百度百科网络爬虫词条以及相关词条的标题，摘要和链接等信息 架构和运行流程五大模块 爬虫调度器负责统筹其他四个模块的协调工作 url管理器管理url链接，维护已经爬取的URL集合和未爬取的URL集合，提供获取新URL链接的接口 HTML下载器用于从URL管理器中获取未爬取的URL链接并下载HTML网页 HTML解析器用于从HTML下载器中获取已经下载的HTML网页，并从中解析出新的URL链接交给URL管理器，解析出有效数据交给数据存储器 数据存储器用于将HTML解析器解析出来的数据通过文件或者数据库的形式存储起来运行流程URL管理器两个变量，已经爬取的URL的集合，未爬取的URL集合，使用set的去重功能去重解决方案 内存去重 关系数据库去重 缓存数据库去重 接口 判断是否有待取的URL，方法定义为has_new_url(). 添加新的URL到未爬取集合中，方法定义为add_new_url(url),add_new_urls(urls) 获取一个未爬取的URL，方法定义为get_new_url(). 获取未爬取URL集合的大小，方法定义为new_url_size(). 获取已经爬取的URL集合的大小，方法定义为old_url_size(). 12345678910111213141516171819202122232425262728293031323334353637383940#URLManager.py#!/usr/bin/env python# coding=utf-8class UrlManager(object): def __init__(self): self.new_urls = set() self.old_urls = set() def has_new_url(self): # 判断是否有未爬取的URL return self.new_url_size() != 0 def get_new_url(self): # 获取一个未爬取的URL new_url = self.new_urls.pop() self.old_urls.add(new_url) return new_url def add_new_url(self,url): if url is None: return if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) def add_new_urls(self,urls): '' 将新的URL添加到未爬取的URL集合中 '' if urls is None or len(urls) == 0: return for url in urls: self.add_new_url(url) def new_url_size(self): return len(self.new_urls) def old_url_size(self): return len(self.old_urls) HTML下载器乱码问题接口download(url)1234567891011121314151617181920# HtmlDownloader.py#!/usr/bin/env python# coding=utf-8import requestsclass HtmlDownloader(object): def download(self,url): if url is None: return None user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' headers=&#123; 'User-Agent':user_agent &#125; r = requests.get(url,headers=headers) if r.status_code == 200: r.encoding='utf-8' return r.text return None HTML解析器解析部分主要分为提取相关词条页面的URL和提取当前词条的标题和摘要接口123parse(page_url,html_cont)解析网页内容抽取URL和数据，返回URL和数据_get_new_urls(page_url,soup):抽取新的URL集合_get_new_data(page_url,soup):抽取有效数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445# HtmlParser.py#!/usr/bin/env python# coding=utf-8import refrom urllib import parsefrom bs4 import BeautifulSoupclass HtmlParser(object): def parser(self, page_url, html_cont): if page_url is None or html_cont is None: return soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8') new_urls = self._get_new_urls(page_url,soup) new_data = self._get_new_data(page_url,soup) return new_urls,new_data def _get_new_urls(slef, page_url,soup): # 抽取新的URL集合 new_urls = set() # 抽取符合要求的a标记 links = soup.find_all('a',href=re.compile(r'/item/*')) for link in links: # 提取href属性 new_url = link['href'] # 拼接成完整网址 new_full_url = parse.urljoin(page_url, new_url) new_urls.add(new_full_url) return new_urls def _get_new_data(self,page_url,soup): #抽取有效数据 data = &#123;&#125; data['url']=page_url title = soup.find('dd',class_='lemmaWgt-lemmaTitle-title').find('h1') data['title']=title.get_text() summary = soup.find('div',class_='lemma-summary') data['summary']=summary.get_text() return data 数据存储器接口store_data(data)解析出来的数据存储到内存中output_html()将存储的数据输出为指定格式的文件格式12345678910111213141516171819202122232425262728293031#!/usr/bin/env python# coding=utf-8import codecsclass DataOutput(object): def __init__(self): self.datas=[] def store_data(self, data): if data is None: return self.datas.append(data) def output_html(self): fout=codecs.open('baike.html','w',encoding='utf-8') fout.write("&lt;html&gt;") fout.write("&lt;body&gt;") fout.write("&lt;table&gt;") for data in self.datas: fout.write("&lt;tr&gt;") fout.write("&lt;td&gt;%s&lt;/td&gt;"%data['url']) fout.write("&lt;td&gt;%s&lt;/td&gt;"%data['title']) fout.write("&lt;td&gt;%s&lt;/td&gt;"%data['summary']) fout.write("&lt;/tr&gt;") self.data.remove(data) fout.write("&lt;/table&gt;") fout.write("&lt;/body&gt;") fout.write("&lt;/html&gt;") fout.close() 爬虫调度器1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python# coding=utf-8from firstSpider.DataOutput import DataOutputfrom firstSpider.HtmlDownloader import HtmlDownloaderfrom firstSpider.HtmlParser import HtmlParserfrom firstSpider.URLManager import URLManagerclass SpiderMan(object): def __init__(self): self.manager = URLManager() self.downloader = HtmlDownloader() self.parser = HtmlParser() self.output = DataOutput() def crawl(self,root_url): # 入口URL self.manager.add_new_url(root_url) # 新URL，和数量 while(self.manager.has_new_url() and self.manager.old_url_size() &lt; 100): try: new_url = self.manager.get_new_url() html = self.downloader.download(new_url) new_urls,data = self.parser.parser(new_url,html) self.manager.add_new_urls(new_urls) self.output.store_data(data) print("已经爬取%s个链接"%self.manager.old_url_size()) except Exception as e: print(e) self.output.output_html()if __name__=='__main__': spider_man = SpiderMan() spider_man.crawl('http://baike.baidu.com/view/284853.htm') 简单分布式爬虫难点在于调度主从模式指由一台主机作为控制节点，负责管理所有运行网络爬虫的主机，爬虫只需要从控制节点那里接收任务，并把新生成的任务提交给控制节点，不必与其他爬虫通信，简单，利于管理，控制节点需要与所有爬虫进行通信，因此控制节点会成为整个系统的瓶颈，容易导致性能下降例子使用三台主机，1控制，2爬虫结构主从结构 URL管理器内存溢出问题：对爬取过后URL进行MD5处理。添加save_progress和load_progress方法进行序列化将未爬取URL和已爬取的URL集合序列化到本地，保存当前进度，以便下次恢复状态1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# URL Manager.py# coding:utf-8import _pickleimport hashlibclass URLManager(object): def __init__(self): self.new_urls = self.load_progress('new_urls.txt') self.old_urls = self.load_progress('old_urls.txt') def has_new_url(self): ''' 判断是否有未爬取的URL :return: ''' return self.new_url_size() != 0 def get_new_url(self): ''' 获取一个未爬取的URL :return: ''' new_url = self.new_urls.pop() m = hashlib.md5() m.update(new_url.encode('utf-8')) self.old_urls.add(m.hexdigest()[8:-8]) return new_url def add_new_url(self,url): ''' 将新的URL添加到未爬取的URL集合中 :param url: 单个URL :return: ''' if url is None: return m = hashlib.md5() m.update(url.encode('utf-8')) url_md5 = m.hexdigest()[8:-8] if url not in self.new_urls and url_md5 not in self.old_urls: self.new_urls.add(url) def add_new_urls(self,urls): ''' 将新的URL集合添加到未爬取的URL集合中 :param urls: url集合 :return: ''' if urls is None: return for url in urls: self.add_new_url(url) def new_url_size(self): ''' 获取未爬取URL集合的大小 :return: ''' return len(self.new_urls) def old_url_size(self): ''' 获取已经爬取URL集合的大小 :return: ''' return len(self.old_urls) def save_progress(self, path, data): ''' 保存进度 :param path: 文件路径 :param data: 数据 :return: ''' with open(path, 'wb') as f: _pickle.dump(data,f) def load_progress(self,path): ''' 从本地加载进度 :param path: 文件路径 :return: 数据 ''' print("[+] 从文件加载进度 %s" % path) try: with open(path, 'rb') as f: tmp = _pickle.load(f) return tmp except: print('[!]无进度文件，创建 %s' %path) return set() 数据存储器生成的文件需要按照当前时间进行命名，以避免重复，同时对文件进行缓存写入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python# coding=utf-8import codecsimport timeclass DataOutput(object): def __init__(self): self.filepath='baike_%s.html' %(time.strftime("%Y_%m_%d_%H_%M_%S", time.localtime())) self.output_head(self.filepath) self.datas=[] def store_data(self, data): if data is None: return self.datas.append(data) if len(self.datas) &gt; 10: self.output_html(self.filepath) def output_head(self,path): ''' 将HTML头写入 :param path: :return: ''' fout=codecs.open(path,'w',encoding='utf-8') fout.write("&lt;html&gt;") fout.write("&lt;body&gt;") fout.write('&lt;table&gt;') fout.close() def output_html(self,path): fout=codecs.open(path,'a',encoding='utf-8') for data in self.datas: fout.write("&lt;tr&gt;") fout.write("&lt;td&gt;%s&lt;/td&gt;"%data['url']) fout.write("&lt;td&gt;%s&lt;/td&gt;"%data['title']) fout.write("&lt;td&gt;%s&lt;/td&gt;"%data['summary']) fout.write("&lt;/tr&gt;") self.datas.remove(data) fout.close() def output_end(self,path): fout=codecs.open(path,'a',encoding='utf-8') fout.write("&lt;/table&gt;") fout.write("&lt;/body&gt;") fout.write("&lt;/html&gt;") fout.close() 控制调度器产生并启动URL管理进行，数据提取进行和数据存储进行，同时维护4个队列保持进行间的通信url_q队列是URL管理进程将URL传递给爬虫节点的通道result_q队列是爬虫节点将数据返回给数据提取进程的通道conn_q队列是数据提取进程将新的URL数据提交RURL管理进程的通道store_q队列是数据提取进程将获取到的数据交给数据存储进程的通道123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# coding:utf-8from multiprocessing.managers import BaseManagerfrom SpiderDis.ControlNode.URLManager import URLManagerfrom SpiderDis.ControlNode.DataOutput import DataOutputfrom multiprocessing import Process, Queueimport timeclass NodeManager: def start_manager(self,url_q,result_q): ''' 创建一个分布式管理器 :param self: :param url_q: url队列 :param result_q: 结果队列 :return: ''' BaseManager.register('get_task_queue',callable=lambda:url_q) BaseManager.register('get_result_queue', callable=lambda:result_q) manager=BaseManager(address=('',8001),authkey='baike'.encode('utf-8')) return manager def url_manager_proc(self,url_q,conn_q,root_url): url_manager = URLManager() url_manager.add_new_url(root_url) while True: while(url_manager.has_new_url()): new_url = url_manager.get_new_url() url_q.put(new_url) print("old_url=",url_manager.old_url_size()) if(url_manager.old_url_size() &gt; 2000): # 通知爬取节点工作结束 url_q.put('end') print("控制节点发起结果通知") url_manager.save_progress('new_urls.txt',url_manager.new_urls) url_manager.save_progress('old_urls.txt',url_manager.old_urls) return # 将从result_solve_proc获取到的URL添加到URL管理器 try: if not conn_q.empty(): urls = conn_q.get() url_manager.add_new_urls(urls) except BaseException as e: time.sleep(0.1) # 延时休息 def result_solve_proc(self,result_q,conn_q,store_q): while(True): try: if not result_q.empty(): content = result_q.get(True) if content['new_urls'] == 'end': print('结果分析进行接收通知然后结果') store_q.put('end') return conn_q.put(content['new_urls']) #url 为set store_q.put(content['data']) #解析出来的数据为dict else: time.sleep(0.1) except BaseException as e: time.sleep(0.1) def store_proc(self,store_q): output = DataOutput() while True: if not store_q.empty(): data = store_q.get() if data == 'end': print('存储进行接受通知然后结束') output.output_end(output.filepath) return output.store_data(data) else: time.sleep(0.1)if __name__ == '__main__': # 初始化４个队列 url_q = Queue() result_q = Queue() store_q = Queue() conn_q = Queue() node = NodeManager() manager = node.start_manager(url_q, result_q) # 创建URL管理进程 url_manager_proc = Process(target=node.url_manager_proc, args=(url_q, conn_q,'http://baike.baidu.com/view/284853.htm', )) result_slove_proc = Process(target=node.result_solve_proc, args=(result_q, conn_q ,store_q,)) store_proc = Process(target=node.store_proc, args=(store_q,)) # 启动三个进程和分布式管理器 url_manager_proc.start() result_slove_proc.start() store_proc.start() manager.get_server().serve_forever() 爬虫节点流程 爬虫调度器从控制节点中的url_q队列读取URL 爬虫调度器调用HTML下载器，HTML解析器获取网页中新的URL和标题摘要 爬虫调度器将新的URL和标题摘要传入result_q队列交给控制节点 HTML下载器HTML解析器爬虫调度器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding:utf-8from multiprocessing.managers import BaseManagerfrom SpiderDis.SpiderNode.HtmlDownloader import HtmlDownloaderfrom SpiderDis.SpiderNode.HtmlParser import HtmlParserclass SpiderWork(object): def __init__(self): #初始化分布式进行中工作节点的连接工作 #1 BaseManager.register('get_task_queue') BaseManager.register('get_result_queue') server_addr = '127.0.0.1' print("Connect to server %s" %server_addr) self.m = BaseManager(address=(server_addr, 8001), authkey='baike'.encode('utf-8')) self.m.connect() self.task = self.m.get_task_queue() self.result = self.m.get_result_queue() self.downloader = HtmlDownloader() self.parser = HtmlParser() print("init finish") def crawl(self): while(True): try: if not self.task.empty(): url = self.task.get() if url == 'end': print("控制节点通知停止工作") self.result.put(&#123;'new_urls':'end','data':'end'&#125;) return print("爬虫节点正在解析：%s" % url.encode('utf-8')) content = self.downloader.download(url) new_urls,data = self.parser.parser(url,content) self.result.put(&#123;'new_urls':new_urls,'data':data&#125;) except EOFError as e: print("连接工作节点失败") except Exception as e: print(e) print("Crawl fail")if __name__ == '__main__': spider = SpiderWork() spider.crawl()]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python快速入门]]></title>
    <url>%2F2018%2F11%2F16%2Fpython%2Fpython%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[文件读写123open(name[.mode][.buffering])#默认为读模式，无缓冲#模式和c相同，缓冲为负数使用默认缓冲 文件读取read(),readlines(),close()read()一次读入所有内容，read(size)一次最多读取,返回str IO异常12345678910try: f = open(r'.text.txt','r') print f.read()finally: if f: f.close()# 另一种写法with open(r'./test.txt','r') as fileReader: print: fileReader.read() 文件写入123f = open(r'test.txt','w')f.write('qiye')f.close() 操作文件和目录使用模块os模块和shutil模块1234567891011121314151617181920212223242526os.getcwd()os.listdir()os.remove()os.removedirs() #多个空目录os.path.isfile(filepath)os.path.isdir(filepath)os.path.isabs() #绝对路径os.path.exists()os.path.split() #分离目录和文件os.path.splistext() #分享扩展名os.path.dirname(path)os.path.basenane(filepath)os.getenv()和os.putenv()os.linesep #行终止符os.rename(old,new)os.name #打印平台os.makedirs(r"dir\dir\dir")os.mkdir("test")os.stat(file)os.chmod(file) # 修改文件权限和时间os.path.getsize(filename)shutil.copytree("olddir","newdir")shutil.copyfile("oldfile","newfile")shutil.move("oldpos","newpos")os.rmdir("dir")shutil.rmtree("dir") #删除不空 序列化操作声明一个dict对象1d = dict(url='index.html',title='首页',content='首页') 把内存中的变量变成可存储或可传输的过程，就是序列化模块cPickle和pickle，前者为c语言编写，快，功能一样1234try: import cPickle as pickleexcept: import pickle 实现序列化主要使用dumps方法或dump方法，dumps方法将任意对象序列化成一个str，然后可以将这个str写入文件进行保存1234pickle.dumps(d)f=open(r'test.txt','wb')pickle.dump(d,f)f.close() 反序列化使用loads方法和load方法1234f = open(r'test.txt','rb')d.pickle.load(f)f.close()d 进程和线程进程os模块中的fork方法，和multiprocessing模块前者只支持unix，后者跨平台例子12345678910import osif __name__ == '__main__': print('current process (%s) start.' % os.getpid()) pid = os.fork() if pid &lt; 0: print("error") elif pid == 0: print('child id%s parent id' % os.getpid()) else: print('parent') multiprocessing12345678910111213141516import osfrom multiprocessing import Processdef run_proc(name): print('Child process %s (%s) Running...' % (name, os.getpid()))if __name__ == '__main__': print ('parent process %s' % os.getpid()) for i in range(5): p = Process(target=run_proc, args=(str(i), )) print ("process will start") p.start() p.join() print('process end.') 进程池pool数量默认大小为cpu核数有新的请求提交，如果池还没有満，就创建一个新的进程来处理，如果已经达到最大值，则等待，直到池中有任务结束。才创建新的进程来处理它。Pool对象调用join()方法会等待所有子进程执行完成，调用join()之前必须先调用close(),调用close()之后就不能继续添加新的Process123456789101112131415161718192021from multiprocessing import Poolimport osimport timeimport randomdef run_task(name): print("task %s (pid = %s) is running ..." % (name, os.getpid())) time.sleep(random.random() * 3) print('Task %s end.' % name)if __name__ == '__main__': print("Current process %s" % os.getpid()) p = Pool(processes=3) for i in range(5): p.apply_async(run_task, args=(i, )) print("waiting for subprocesses done...") p.close() p.join() print("all subprocess done") 进程间通信Queue多进程安全队列.Put方法插入数据到队列中，两个可选参数blocked和timeout,如果blocked为True（默认值),并且timeout为正值该方法会阻塞timeout指定的时间，直到队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为false但，该Queue已満，会立即抛出Queue.Full异常.Get方法从队列中读取并删除一个元素有两个可选参数blocked和timeout和.Put类似 123456789101112131415161718192021222324252627282930313233343536from multiprocessing import Process, Queueimport osimport timeimport randomdef proc_write(q, urls): print('Process(%s) is writing ...' % os.getpid()) for url in urls: q.put(url) print('Put %s to queue...' % url) time.sleep(random.random())def proc_read(q): print('Process(%s) is reading...' % os.getpid()) while True: url = q.get(True) print('Get %s from queue.' % url)if __name__ == '__main__': q = Queue() proc_write1 = Process(target=proc_write, args=(q, ['url1', 'url2', 'url3'])) proc_write2 = Process(target=proc_write, args=(q, ['url4', 'url5', 'url6'])) proc_reader = Process(target=proc_read, args=(q,)) proc_write1.start() proc_write2.start() proc_reader.start() proc_write1.join() proc_write2.join() proc_reader.terminate() Pipe经常用于两个进程间的通信，两个进程分别位于管道的两端Pipe方法返回(conn1, conn2)代表一个管道的两端，Pipe方法duplex参数为True（默认值）全双工模式为False,conn1只负责接收，conn2只负责发送 123456789101112131415161718192021222324252627import multiprocessingimport randomimport timeimport osdef proc_send(pipe, urls): for url in urls: print("Process(%s) send: %s" % (os.getpid(), url)) pipe.send(url) time.sleep(random.random())def proc_recv(pipe): while True: print("Process(%s) recv %s" % (os.getpid(), pipe.recv())) time.sleep(random.random())if __name__ == "__main__": pipe = multiprocessing.Pipe() p1 = multiprocessing.Process(target=proc_send, args=(pipe[0], ['url_' + str(i)for i in range(10)])) p2 = multiprocessing.Process(target=proc_recv, args=(pipe[1],)) p1.start() p2.start() p1.join() p2.join() 线程优点： 可以把运行时间长的任务放到后台去处理 用户界面可以更加吸引人 程序的运行速度可能加快 在一些需要等待的任务实现上 两个模块：thread和threadingthread低级模块，threading高级模块threading两种实现方法： 把一个函数传入并创建Thread实例，然后调用start方法开始执行： 直接从threading.Thread继承并创建线程类，然后重写init方法 12345678910111213141516171819202122import randomimport timeimport threadingdef thread_run(urls): print("Current %s is running..." % threading.currentThread().name) for url in urls: print("%s----&gt;&gt;&gt;%s" % (threading.currentThread().name, url)) time.sleep(random.random()) print("%s ended." % threading.currentThread().name)print ("%s is running..." % threading.current_thread().name)t1 = threading.Thread(target=thread_run, name="Thread1", args=(['url_1', 'url_2', 'url_3'], ))t2 = threading.Thread(target=thread_run, name="Thread2", args=(['url_4', 'url_5', 'url_6'], ))t1.start()t2.start()t1.join()t2.join()print("%s ended." % threading.currentThread().name) 123456789101112131415161718192021222324252627import randomimport threadingimport timeclass myThread(threading.Thread): def __init__(self, name, urls): threading.Thread.__init__(self, name=name) self.urls = urls def run(self): print("current %s is running ..." % threading.currentThread().name) for url in self.urls: print("%s ----&gt; %s" % (threading.currentThread().name, url)) time.sleep(random.random()) print("%s ended." % threading.currentThread().name)print("%s is running ..." % threading.current_thread().name)t1 = myThread(name='Thread_1', urls=['urls1', 'urls2'])t2 = myThread(name='Thread_2', urls=['urls3', 'urls4'])t1.start()t2.start()t1.join()t2.join()print("%s ended." % threading.currentThread().name) 线程同步使用Thread对象的Lock和RLock可以实现简单的线程同步，使用acquire方法和release方法Lock对一个线程连续再次进行acquire操作由于第一次没有release，第二次acquire将挂起线程，会导致Lock对象永远不会release，造成线程死锁RLock允许一个线程多次对其进行acquire操作，因为在其内部通过一个counter变量维护线程acquire的次数而且每一次的acquire操作必须有一个release操作与之对应，在所有的release操作完成之后，别的线程才能申请该RLock对象 1234567891011121314151617181920212223242526import threadingmylock = threading.RLock()num = 0class myThread(threading.Thread): def __init__(self, name): threading.Thread.__init__(self,name=name) def run(self): global num while True: mylock.acquire() print('%s locked, Number: %d' %(threading.current_thread().name, num)) if num &gt;= 4: mylock.release() print("%s released, Number: %d" %(threading.current_thread().name, num)) break num += 1 print('%s released , Number: %d' %(threading.current_thread().name,num)) mylock.release()if __name__ == '__main__': thread1 = myThread('Thread1') thread2 = myThread('Thread2') thread1.start() thread2.start() 全局解释器锁(GIL)在解释执行Python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GIL，由于全局解释器锁的存在，在进行多线程操作的时候，不能调用多个cpu内核，只能利用一个内核，所以在cpu密集型操作的时候，不推荐使用多线程，就使用多进程。对于IO密集型操作，多线程可以明显提高效率. 协程一种用户级的轻量级线程，协程拥有自己的寄存器上下文和栈。协和调度切换时将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，因此协程以保留上一次调用的状态，每次过程重入时，就相当于进入上一次调用的状态。在并发编程中，协和与线程类似，每个协和表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。协和需要用户自己来编写调度逻辑，对于cpu来说，协程其实是单线程，所以cpu不用去考虑怎么调度，切换上下文，这就省去了cpu的切换开销，所以协和在一定程度上又好于多线程。模块yield,第三方库geventgevent是一个基于协程的Python网络函数库，使用greenlet在libev事件循环顶部提供了一个有高级别并发性的API,有以下特性： 基于libev的快速事件循环，Linux上是epoll机制 基于greenlet的轻量级执行单元 API复用了Python标准库里的内容。 支持SSL的协作式sockets 可通过线程池或c-ares实现DNS查询 通过monkey patching功能使得第三方模块变成协作式 grevent对协程的支持本质上是greenlet在实现切换工作。工作流程：假如进行访问网络的IO操作时，出现阻塞，greenlet就显式切换到另一段没有被阻塞的代码段执行，直到原先的阻塞状况消失以后，再自动切换回原来的代码继续处理。因此greenlet是一种合理安排的串行方式。 和多线程比较：由于IO操作非常耗时，经常使程序处于等待状态，gevent自动切换协程，就保证总有greenlet在运行，而不是等待IO，这就是协程比多线程效率高的原因。 特点由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，将一些常见的阻塞，如socket，select等地方实现协程跳转，这一过程在启动通过monkey patch完成. 12345678910111213141516171819from gevent import monkey; monkey.patch_all()import geventimport urllib.requestdef run_task(url): print("visit --&gt;%s" % url) try: response = urllib.request.urlopen(url) data = response.read() print("%d bytes received from %s." %(len(data), url)) except Exception as e: print(e)if __name__ == '__main__': urls = ['https://github.com/', 'https://www.python.org', 'http://www.cnblogs.com'] greenlets = [gevent.spawn(run_task, url) for url in urls] gevent.joinall(greenlets) spawn方法可以看做是用来形成协程，joinall方法就是添加这些协程，并且启动运行。从运行结果来看，3个网络操作是并发执行的而且结束顺序不同，但其实只有一个线程。 gevent池当拥有动态数量的greenlet需要进行并发管理（限制并发数）时，就可以使用池，在处理大量网络和IO操作时是非常需要的。 12345678910111213141516171819202122import urllib.requestfrom gevent.pool import Poolfrom gevent import monkeymonkey.patch_all()def run_task(url): print("visit --&gt;%s" % url) try: response = urllib.request.urlopen(url) data = response.read() print("%d bytes received from %s." % (len(data), url)) except Exception as e: print(e) return 'url: %s---&gt;finish' % urlif __name__ == '__main__': pool = Pool(2) urls = ['https://github.com/', 'https://www.python.org', 'http://www.cnblogs.com'] results = pool.map(run_task, urls) print(results) 分布式进程分布式进程指的是将Process进程分布到多台机器上，充分利用多台机器的性能完成复杂的任务。 使用multiprocessing模块，其不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。可以写一个服务进程作为调度者，将任务分布到其他多个进程中，依靠网络进行通信管理。例子：在做爬虫程序时，常常会遇到这样的场景，我们想抓取某个网站的所有图片，如果使用多进程的话，一般是一个进程负责抓取图片的链接地址，将链接地址存放到Queue中，另外的进程负责从Queue中读取链接地址进行下载和存储到本地。现在把这个过程做成分布式，一台机器上的进程负责抓取链接，其他机器上的进程负责下载存储。那么遇到的主要问题是将Queue暴露到网络中，让其他机器进程都可以访问，分布式进程就是将这一个过程进行了封装，我们可以将这个过程称为本地队列的网络化 创建服务步骤 建立队列Queue，用来进行进行间的通信。服务进程创建任务队列task_queue，用来作为传递任务给任务进程的通道；服务进程创建结果队列result_queue，作为任务进程完成任务后回复服务进程的通道。在分布式多进程环境下，必须通过由Queuemanager获得的Queue接口来添加任务。 把第一步中建立的队列在网络上注册，暴露给其他进程（主机），注册后获得网络队列，相当于本地队列的映像。 建立一个对象（Queuemanager（BaseManager））实例manager，绑定端口和验证口令。 启动第三步中建立的实例，即启动管理manager，监管信息通道。 通过管理实例的方法获得通过网络访问的Queue对象，即再把网络队列实体化成可以使用的本地队列。 创建任务到“本地”队列中，自动上传任务到网络队列中，分配给任务进程进行处理。linux版服务进程123456789101112131415161718192021222324252627282930313233343536373839#3.ximport queue as Queuefrom multiprocessing.managers import BaseManager# 1task_queue = Queue.Queue()result_queue = Queue.Queue()class Queuemanager(BaseManager): pass# 2Queuemanager.register('get_task_queue', callable=lambda: task_queue)Queuemanager.register('get_result_queue', callable=lambda: result_queue)# 3manager = Queuemanager(address=('', 8081), authkey=b'qiye')# 4manager.start()# 5task = manager.get_task_queue()result = manager.get_result_queue()# 6for url in ["ImageUrl_" + str(i) for i in range(10)]: print("put task %s ..." % url) task.put(url)print('try get result')for i in range(10): print('result is %s' % result.get(timeout=10))manager.shutdown() 创建任务进程 使用QueueManager注册用于获取Queue的方法名称，任务进程只能通过名称来在网络上获取Queue。 连接服务器，端口和验证口令注意保持与服务进程中完全一致。 从网络上获取Queue，进行本地化。 从task队列获取任务，并把结果写入result队列。 1234567891011121314151617181920212223242526272829303132333435import timefrom multiprocessing.managers import BaseManager# 创建类似的QueueManager:class QueueManager(BaseManager): pass# 1QueueManager.register('get_task_queue')QueueManager.register('get_result_queue')# 2server_addr = '127.0.0.1'print("connect to server %s" % server_addr)m = QueueManager(address=(server_addr, 8081), authkey=b'qiye')m.connect()# 3task = m.get_task_queue()result = m.get_result_queue()# 4while(not task.empty()): image_url = task.get(True, timeout=5) print('run task download %s...' % image_url) time.sleep(1) result.put('%s----&gt;success' % image_url)# doneprint('worker exit.') 在windows下创建服务进行的代码有所不同绑定接口不能使用lambda，只能先定义函数再绑定]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17最短路径算法]]></title>
    <url>%2F2018%2F11%2F11%2FACM%2FCLR%2F17_%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最短路径问题图Consider a digraph G=(V,E) with edge-weight function w:E-&gt;R. The weigth of path $p=v{1}\rightarrow v{2}\rightarrow \ldots \rightarrow v_{k}$is defined to be W\left( p\right) =\sum ^{k-1}_{i=1}w\left( v_{i},v_{i+1}\right)Shortest pathsA shortest path from u to v is a path ofminimum weight from u to v. The shortestpath weight from u to v is defined asδ(u, v) = min{w(p) : p is a path from u to v}.Note: δ(u, v) = ∞ if no path from u to v exists. Optimal substructure证明最优子结构是最优选择的组成部分，使用剪切法证明Theorem. A subpath of a shortest path is ashortest pathProof. Cut and paste: Triangle inequality三角不等式，证明简单路径大于等于最短路径Theorem. For all u, v, x ∈ V, we haveδ(u, v) ≤ δ(u, x) + δ(x, v). Single-source shortest paths使用贪心算法，维持一个S集合任意选择一个已知最短路径s不断的向其中添加和s相连的不在S集合中的最短路径的顶点，维护剩余点的权值Problem. From a given source vertex s ∈ V, findthe shortest-path weights δ(s, v) for all v ∈ V.If all edge weights w(u, v) are nonnegative, allshortest-path weights must exist.IDEA: Greedy. Maintain a set S of vertices whose shortestpath distances from s are known. At each step add to S the vertex v ∈ V – Swhose distance estimate from s is minimal. Update the distance estimates of verticesadjacent to v.Dijkstra算法1234567891011d[s] ← 0for each v ∈ V – &#123;s&#125; do d[v] ← ∞S ← ∅Q ← V ⊳ Q is a priority queue maintaining V – Swhile Q ≠ ∅ do u ← EXTRACT-MIN(Q) S ← S ∪ &#123;u&#125; for each v ∈ Adj[u] do if d[v] &gt; d[u] + w(u, v) then d[v] ← d[u] + w(u, v) 正确性Correctness-part-1初始化变量后在之后的所有松驰操作中简单路径和最短路径的关系一直保持Lemma. Initializing d[s] ← 0 and d[v] ← ∞ for allv ∈ V – {s} establishes d[v] ≥ δ(s, v) for all v ∈ V,and this invariant is maintained over any sequenceof relaxation steps.12345678Proof. Suppose not. Let v be the first vertex forwhich d[v] &lt; δ(s, v), and let u be the vertex thatcaused d[v] to change: d[v] = d[u] + w(u, v). Then,d[v] &lt; δ(s, v) supposition ≤ δ(s, u) + δ(u, v) triangle inequality ≤ δ(s,u) + w(u, v) sh. path ≤ specific path ≤ d[u] + w(u, v) v is first violationContradiction. Correctness-part-2从一步扩展到下一步的正确性Lemma. Let u be v’s predecessor on a shortestpath from s to v. Then, if d[u] = δ(s, u) and edge(u, v) is relaxed, we have d[v] = δ(s, v) after therelaxation.Proof. Observe that δ(s, v) = δ(s, u) + w(u, v).Suppose that d[v] &gt; δ(s, v) before the relaxation.(Otherwise, we’re done.) Then, the test d[v] &gt;d[u] + w(u, v) succeeds, because d[v] &gt; δ(s, v) =δ(s, u) + w(u, v) = d[u] + w(u, v), and thealgorithm sets d[v] = d[u] + w(u, v) = δ(s, v). Correctness-part-3算法结束时构造出正确路径Theorem. Dijkstra’s algorithm terminates with d[v] = δ(s, v) for all v ∈ V. 12345678910Proof. It suffices to show that d[v] = δ(s, v) for everyv ∈ V when v is added to S. Suppose u is the firstvertex added to S for which d[u] &gt; δ(s, u). Let y be thefirst vertex in V – S along a shortest path from s to u,and let x be its predecessor:Since u is the first vertex violating the claimedinvariant, we have d[x] = δ(s, x). When y wasadded to S, the edge (x, y) was relaxed, whichimplies that d[y] = δ(s, y) ≤ δ(s, u) &lt; d[u]. But,d[u] ≤ d[y] by our choice of u. Contradiction. 分析Time:array O(V) O(1) O(V2) binary heap O(lg V) O(lg V) O(E lg V) Fibonacci heap O(lg V) amortized O(1) amortized O(E + V lg V) worst case 和BFS的关系Unweighted graphs Bellman-FordDifference constraintsAll-pairs shorest pathsFloyd-WarshallJohnsonImplementation参考(需要科学上网) 给定一个图G,向图中添加顶点s，添加从G出发的所有边，修改后的图记为$G^’$ 在$G^’$图上以新加顶点s为起点运行Bellman-Ford算法，计算出的距离记作h[0],h[1],…h[V-1].如果找到负环则退出返回（注意到添加的新顶点s不会产生负环，因为只存在从s出发的边，没有回到s的边 重新确定每个边的权值，original weight + h[u] - h[v] 移除添加的s顶点，对第一个顶点运行一遍dijkstra算法 Example:原始图: 添加顶点s和所有边使用Bellman-Ford算法计算从顶点4到所有顶点的最短路径，h[]={0,-5,-1,0}之后移除顶点4,重新给边赋权值对每一条边运行dijkstra算法]]></content>
      <categories>
        <category>ACM</category>
        <category>CLR</category>
      </categories>
      <tags>
        <tag>路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07编辑多个文件]]></title>
    <url>%2F2018%2F11%2F10%2FVim%2F07%E7%BC%96%E8%BE%91%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[7.1 编辑另一个文件 ​ :edit filename.txt :编辑另一个文件 ​ :edit! filename.txt :强制编辑另一个文件,不进行保存当前缓冲区的内容. ​ :hide edit filename.txt :隐藏缓冲区内容,直接编辑另一个文件,但此时不保存当前的文件. 7.2 文件列表 ​ (1) 打开多个文件 ​ vim note05.txt note06.txt note07.txt ​ (2) 文件列表——当前在编辑哪个文件??? ​ :args命令(arguments):显示当前的文件列表,当前文件以[]括起来. ​ (3) 文件列表中的切换 ​ :next命令 :打开编辑下一个文件. ​ :next!命令 :强制打开编辑下一个文件. ​ :wnext命令 :完成两个单独的命令 :write :next ​ :previous命令 :打开编辑上一个文件. ​ :wprevious命令 :保存当前文件,打开编辑上一个文件. ​ :last命令 :打开最后一个文件,wlast命令. ​ :first命令 :打开第一个文件,wfirst命令. ​ :2next命令 :使用计数命令,向前跳过两个文件. ​ (4) 自动保存 ​ :set autowrite :在不同的文件转移时,不需要每次都执行write命令. ​ :set noautowrite :关闭自动保存. ​ 备注:与word自动保存不同的,过一段时间会自动保存,指某个事件发生时自动保存这个文件. ​ (5) 编辑另一个文件列表 ​ :args note01.txt note02.txt note03.txt ​ :args *.txt :支持通配符. ​ (6) 最后文件了吗??? ​ 当你有一个列表文件要编辑时,Vim会假设你要全部编辑它们.如果你要退出,需要再执行一次退出 命令. 7.3 切换到另一个文件 ​ 1. CTRL-^:两个文件之间快速的切换. ​ :args note01.txt note02.txt note03.txt ​ :next或previous之后,可以使用这个命令非常方便的在两个文件中进行切换. ​ 2. 多个文件之间的标记 ​ (1) 全局标记: 使用大写字母命名标记. ​ 如:note06.txt 50%mM note07.txt GmB ​ ‘或`命令进行跳转到自定义标记的位置. ​ 备注:如果你删除了局部标记所在的行,也就相当于删除了这个局部标记. ​ 与全局标记不同,全局标记会一直存在下去. ​ (2) 预定义的标记 ​ `”:关闭文件时的光标的位置. ​ `.:文件最后一次修改的地方. ​ 备注:在多文件中也可以使用CTRL-o CTRL-i两个同样试用. 7.4 备份 ​ :set backup :生成备份文件,文件名为原文件名加一个~. ​ 备注:ZZ进行退出,是不能生成备份文件的,需要使用:write ​ :set backupext=.bak :修改生成一个名为原文件名加.bak的备份文件. ​ :set patchmode=.orig :保存一份修改前的原始文件作为副本,同时后缀为.orig. 7.5 在文件间复制粘贴 ​ 1. 简单的复制粘贴 ​ :edit thisfile.txt ​ /This ​ vjjj$y ​ :edit otherfile.txt ​ /There ​ p ​ 2. 使用寄存器 ​ 复制多个独立的文本到另一个文件中时,这时可以使用寄存器,使用a到z的字母作为寄存器的名字. ​ CTRL-vjjj$”by :把一个文本块复制到名为b(block)的寄存器中. ​ “fyas :把一个句子复制到名为f(first)的寄存器中. ​ “l3Y :把3个整行的内容复制到名为l(line)的寄存器中. ​ “bp :取出寄存器b中的内容文本. ​ “wdaw :删除一个word并将其存入名为w(word)的寄存器中. ​ 3. 向文件中追加内容 ​ :read note06.txt :向当前文件进行追加note06.txt文件内容. ​ :write &gt;&gt; note06.txt :将当前文件追加到文件名为note06.txt文件中去,只能追加到文件的最后. ​ :write logfile :将当前文件写入到logfile中去 ​ 备注:Visual模式下也可以进行选择要写入的文本. 7.6 查看文件 ​ vim note07.txt :直接打开编辑文件,可以读写. ​ vim -R note07.txt :以只读的方式打开该文本. ​ view note07.txt :以只读的方式打开该文本. ​ vim -M note07.txt :强制性地避免对文件进行修改,其中的-M选项告诉Vim工作于viewer模式中. ​ :set modifiable ​ :set write 7.7 更改文件名 ​ :write filename :将当前文件写入到新的文件中去. ​ :saveas filename :将当前文件进行另存为操作. ​ :file filename :与saveas功能相似,也可以实现文件名的更改.]]></content>
      <categories>
        <category>Vim</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[dynamic programming]]></title>
    <url>%2F2018%2F11%2F09%2FACM%2FCLR%2F15_dynamic_programming%2F</url>
    <content type="text"><![CDATA[分治算法和动态规划的异同分治法： 分治方法将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解动态规划： 与分治法相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治算法会做许多不必要的工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。动态规划算法通常用来求解最优化问题 设计步骤 刻画一个最优解的结构特征。 递归地定义最优解的值。 计算最优解的值，通常采用自底向上的方法。 利用计算出的信息构造一个最优解 动态规划的实现方法 备忘的自顶向下法(top-down with memoization) 自底向上(bottom-up method)自底向上动态规划算法是按逆拓扑序(reverse topological sort)或反序的拓扑序(topological sort of the transpose)来处理子问题图中的顶点，换句话说，对于任何子问题，直到它依赖的所有子问题均已求解完成，才会求解它。可以用尝试优先搜索来描述（带备忘机制的）自顶向下动态规划算法处理子问题图的顺序 动态规划原理两个要素：最优子结构和问题重叠如果一个问题的最优解包含其子问题的最优解，则此问题具有最优子结构性质。 最优子结构发掘最优子问题的通用模式 证明问题最优解的第一个组成部分是做出一个选择,例如,选择钢条第一次切割位置, 选择矩阵链的划分位置等。做出这次选择会产生一个或多个待解的子问题。 对于一个给定问题,在其可能的第一步选择中,你假定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的,只是假定已经知道了这种选择。 给定可获得最优解的选择后,你确定这次选择会产生哪些子问题,以及如何最好地刻画子问题空间。 利用“剪切一粘贴”( cut-and-paste)技术证明:作为构成原问题最优解的组成部分,每个子问题的解就是它本身的最优解。证明这一点是利用反证法:假定子问题的解不是其自身的最优解,那么我们就可以从原问题的解中“剪切”掉这些非最优解,将最优解“粘贴”进去,从而得到原问题一个更优的解,这与最初的解是原问题最优解的前提假设矛盾。如果原问题的最优解包含多个子问题,通常它们都很相似,我们可以将针对一个子问题的“剪切一粘贴”论证方法稍加修改,用于其他子问题。 最优子结构的不同体现在两个方面 原问题的最优解中涉及多少个子问题，以及 在确定最优解使用哪些子问题时，我们需要考察多少种选择重叠子问题适合用动态规划方法求解的最优化问题具备的第二个性质是子问题空间必须足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。如果每个子问题都必须至少求解一次，自底向上动态规划算法会比自顶向下备忘算法快，因为自底向上算法没有递归调用的开销，表的维护开销也更小。相反如果子问题空间中的某些子问题完全不必求解，备忘方法就会体现出优势了，因为它只会求解那些绝对必要的子问题。]]></content>
      <categories>
        <category>ACM</category>
        <category>CLR</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用stl算法]]></title>
    <url>%2F2018%2F11%2F01%2FACM%2Fstl%2F%E5%B8%B8%E7%94%A8stl%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序：sort(begin,end);lower_bound(begin,end,target)在区间内查找大于或等于target的第一个元素 不定长数组vectorvector不定长数组，用clear()清空，resize()改变大小，用push_back()和pop_back()在尾部添加和删除元素，用empty()测试是否为空，可以直接赋值或者作为函数的返回值。 集合set数学上的集合，每个元素最多只出现一次。和sort一样，自定义类型也可以构造set，但必须定义“小于运算符” 映射map关联数组，类似高级数组。用一个map month_name来表示“月份名字到月份编号”映射，然后可以用month_name[“July”] = 7，来赋值 栈，队列和优先队列优先队列，越小的整数优先级越大1priority_queue&lt;int, vecotr&lt;int&gt;, greater&lt;int&gt; &gt; pq;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[78. subset]]></title>
    <url>%2F2018%2F11%2F01%2FACM%2Fleetcode%2F78.subset%2F</url>
    <content type="text"><![CDATA[给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 方法1 DFS+回溯1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); vector&lt;vector&lt;int&gt; &gt; ans; vector&lt;int&gt; cur; for(int i = 0;i &lt;= len;i++) &#123; dfs(nums,i,0,cur,ans); &#125; return ans; &#125; void dfs(vector&lt;int&gt; &amp; nums,int n,int s,vector&lt;int&gt; &amp; cur,vector&lt;vector&lt;int&gt; &gt; &amp;ans) &#123; if(n == cur.size()) &#123; ans.push_back(cur); return; &#125; for(int i = s;i &lt; nums.size();i++) &#123; cur.push_back(nums[i]); dfs(nums,n,i+1,cur,ans); cur.pop_back(); &#125; &#125;&#125;; 123456789101112131415161718class Solution: def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ ans = [] def dfs(n,s,cur): if len(cur) == n: ans.append(cur.copy()) return for i in range(s,len(nums)): cur.append(nums[i]) dfs(n,i+1,cur) cur.pop() for i in range(len(nums) + 1): dfs(i,0,[]) return ans 方法2 Bit manipulation包含n个元素的数组的所有可以的子集为$2^n$个(算法复杂度也为$2^n$)位运算，选择那个数放入子集中就像填充比特位，有三个数对应三个比特位，0 0 0。第0个子集什么都没有，第一个子集只有第一个数0 0 1,第二个子集有第二个数0 1 0…。以此类推，第7个子集包含所有的数1 1 1.j从0到maxn变化，每一次计算j移动i位后判断最后一位是否为1，如果为1就将nums[i]的值放入result[j]12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int maxn = 1 &lt;&lt; len; vector&lt;vector&lt;int&gt;&gt; result(maxn); for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; maxn; j++) &#123; if ((j &gt;&gt; i) &amp; 1) result[j].push_back(nums[i]); &#125; &#125; return result; &#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; ans; int len = nums.size(); int mn = 1 &lt;&lt; len; for(int s = 0;s &lt; mn;s++) &#123; vector&lt;int&gt; cur; for(int i = 0;i &lt; len;i++) &#123; if(s &amp; (1 &lt;&lt; i)) cur.push_back(nums[i]); &#125; ans.push_back(cur); &#125; return ans; &#125;&#125;; 1234567class Solution: def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ return [[nums[i] for i in range(len(nums)) if s &amp; 1 &lt;&lt; i] for s in range(1 &lt;&lt; len(nums))] 参考链接]]></content>
      <categories>
        <category>ACM</category>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM小技巧]]></title>
    <url>%2F2018%2F10%2F27%2FACM%2F%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[偶数奇数判断使用n &amp; 0x1 == 0比 n % 2 == 0快 按列输出1234567891011for(int i = 0;i &lt; cols;i++) &#123; for(int j = 0;j &lt; rows;j++) &#123; a[j][i]; &#125;&#125;for(int i=0;i &lt; rows;i++) &#123; for(int j = 0;j &lt; cols;j++) &#123; a[j * rows + cols]; &#125;&#125; 定义时初始化C/C++数组初始化的一些误区1234567891011121314int a[5] = &#123;0&#125;;//全部初始化为0int a[5] = &#123;1&#125;;//只有第一个初始化为1其他的全为0数组初始化列表中的元素个数小于指定的数组长度时,不足值用补以默认值vector&lt;int&gt; a(10);//默认全初始化为0vector&lt;int&gt; dist(N,MAX_TIME);//默认全初始化为MAX_TIMEint dis[N]&#123;0&#125;;//可以初始化为0,但决不能初始化其他值//memset只对char型数组管用(存在疑问)double array[100];memset(array,0,100*sizeof(double)); 最大值1*max_element(dist.begin(),dist.end());]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入分析epoll函数]]></title>
    <url>%2F2018%2F10%2F18%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90epoll%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[深入分析epoll函数]]></content>
      <categories>
        <category>C++面试</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[realloc,malloc,以及calloc函数的区别]]></title>
    <url>%2F2018%2F10%2F16%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2Frealloc%2Cmalloc%2C%E4%BB%A5%E5%8F%8Acalloc%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[123void * malloc(unsigned int num_bytes);void * calloc(size_t n,size_t size);void * realloc(void *ptr,size_t new_Size); mallocmalloc一次申请一个连续的地址空间,并将空间基地址强制转换为int类型.赋值给指针p,申请的内存值是不确定的.1int *p = (int *) malloc(20 * sizeof(int)); calloccalloc不需要人为的计算空间的大小,1int *p = (int *) calloc(20,sizeof(int)); calloc在申请空间后,对空间进行初始化为0; reallocrealloc用于对空间进行扩容,ptr指向原来空间的基址的指针,new_size为接下来要扩充容量的大小,如果size较小,原来申请的空间后面有空余内存,将直接在其后扩容,如果size较大,将新申请一块空间,将内存拷贝过去,然后free原来的内存空间.如果size_t非常大,则申请失败,返回NULL,原来的内存不会释放.]]></content>
      <categories>
        <category>C++面试</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>malloc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[where和having的区别]]></title>
    <url>%2F2018%2F10%2F11%2Fsql%2Fwhere%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[聚合函数是比较where,having的关键 where &gt; 聚合函数 &gt; having 若须引入聚合函数来对group by 结果进行过滤,则只能用having where后不能跟聚合函数 where在分组前进行数据过滤,条件不能包含聚合函数, having 作用是筛选满足条件的组,在分组之后过滤数据.]]></content>
      <categories>
        <category>sql</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2018%2F10%2F08%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[定义及属性红黑树是许多”平衡”搜索树中的一种,可以保证在最坏情况下基本动态集合操作的时间复杂度为O(lgn)红黑树是一棵二叉搜索树,它在每个结点上增加了一个存储位来表示结点的颜色,可以是RED或BLACK.通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束,红黑树确保没有一条路径会比其他路径长出2倍,因而是近似于平衡的.树中每个结点包含5个属性,color,key,left,right和p.如果一个结点没有子结点或父结点.则该相应的指针属性的值为NIL,我们可以把这些NIL视为指向二叉搜索树的叶结点(外部结点)的指针,而把带关键字的结点视为树的内部结点. 性质 每个结点或是红色的,或是黑色的. 根结点是黑色的 每个叶结点(NIL)是黑色的. 如果一个结点是红色的,则它的两个子结点都是黑色的. 对每个结点,从该结点到其所有后代叶结点的简单路径上,均包含相同数目的黑色结点. 引理一棵有n个内部结点的红黑树的高度至多为2lg(n+1) 从根结点x出发(不含该结点)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高从根到叶结点的任何一条简单路径上都至少有一半的结点为黑.因此,根的黑高至少为h/2 操作左旋123456789101112131415161718192021LEFT_ROTATE(T,x) &#123; y = x.right; //y为x的右孩子 x.right = y.left; // if(y.left != T.nil) //如果y的左孩子不空 &#123; y.left.p = x; &#125; y.p = x.p; if(x.p == T.nil) //x的父结点为根结点 &#123; T.root = y; &#125; else if(x = x.p.left) //x为其父结点左孩子 x.p.left = y; else //x为其父结点右孩子 x.p.right = y; y.left = x; x.p = y;&#125; 插入123456789101112131415161718192021222324RB_INSERT(T,z)&#123; y = T.nil; x = T.root;//从根结点向下搜索 while(x != T.nil) &#123; y = x; if(z.key &lt; x.key) x = x.left; else x = x.right; &#125; z.p = y; if(y == T.nil) //在根结点插入 T.root = z; else if(z.key &lt; y.y.key) //左 y.left = z; else y.right = z; //右 z.left = T.nil; z.right = T.nil; z.color = RED; RB_INSERT_FIXUP(T,z);&#125; 调整插入节点z后被破坏的性质有性质2和性质4，如果插入为根节点，则性质2被破坏，如果插入节点的父节点为红色，则性质4被破坏如果违反性质2，则说明插入的为根节点三种情况处理：将其染成黑色如果违反性质4，则有三种情况：case1：z和z.parent都为红色，z的叔叔节点为红色处理：将z.parent染为黑色，z.parent.parent染为红色，z.uncle染为黑色。 case2：z和z.parent都为红色，z的叔叔为黑色，z == z.parent.right处理：z = z.parent，以z为支点，左旋 case3：z和z.parent都为红色，z的叔叔为黑色，z == z.parent.left处理：z.parent染为黑色，z.parent.parent染为红色，以z.parent.parent为支点右旋 1234567891011121314151617181920212223242526272829303132RB_INSERT_FIXUP(T,z)&#123; while(z.p.color == RED) //z的父节点为红色 &#123; if(z.p == z.p.p.left) //左子树 &#123; y = z.p.p.right; if(y.color == RED) //z的父结点的右兄弟为红色 &#123; z.p.color = BLACK; y.color = BLACK; //z.uncle z.p.p.color = RED; z = z.p.p; //z指针沿树上升 &#125; else if(z == z.p.right) &#123; z = z.p; LEFT_ROTATE(T,z); &#125; z.p.color = BLACK; z.p.p.color = RED; RIGHT_ROTATE(T,z.p.p); &#125; else if(z.p == z.p.p.right) &#123; y = z.p.p.left; //right和left交换.故省略 &#125; &#125;&#125; 删除]]></content>
      <categories>
        <category>C++面试</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息的表示和处理]]></title>
    <url>%2F2018%2F10%2F07%2FCSAPP%2Fch02%2F</url>
    <content type="text"><![CDATA[机器级程序将内存视为一个非常大的字节数组,称为虚拟内存.内存中的每个字节都由一个唯一的数字来标识,称为它的地址.所有可能地址的集合就称为虚拟地址空间.]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POSIX线程]]></title>
    <url>%2F2018%2F10%2F02%2FBLP%2Fch12_POSIX%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[定义:线程是一个进程内部的一个控制序列 fork系统调用和创建新线程之间的区别当进程执行fork调用时,将创建出该进程的一份新副本,这个新进程拥有自己的变量和自己的PID,它的时间高度也是独立的,它的执行(通常)几乎完全独立于父进程.当在进程中创建一个新线程时,新的执行线程将拥有自己的栈(因此也有自己的局部变量),但与它的创建者共享全局变量,文件描述符,信号处理函数,和当前目录状态. 优缺点优点 线程的数据共享和数据一致性方面的要求实现比进程容易的多 线程之间的切换需要操作系统优势的工作要比进程之间的切换少得多，因此多个线程结资源的需求要远小于多个进程，如果一个程序在逻辑上需要有多个执行线程，那么在单处理器系统上把它运行为一个多线程程序才更符合实际情况．缺点 编写多线程程序需要非常仔细的设计.在多纯种程序中,因时序上的细微偏差或无意造成的变量共享而引发错误的可能性是很大的. 对多线程程序的调试要比单线程程序的调试困难的多,因为线程之间的交互非常难于控制. 将大量的计算分成两个部分,并把这两个部分任务两个不同的纯种来运行的程序在一台单处理器机器上不一定运行得更快,除非计算确实允许它的不同部分可以被同时计算.而且运行它的机器拥有多个处理器来支持真正的多处理. 可重入代码编写多线程程序,可以通过定义宏_REENTRANT来告诉编译器我们需要可重入功能,必须位于#include之前.将做三件事 对函数重新定义它们的可安全重入版本.会在函数名后面添加_r字符串 stdio.h中原来以宏的形式实现的一些函数将变成可安全重入的函数 error.h中定义的变量error现在将成为一个函数调用.它能够以一种多线程安全的方式来获取真正的errno的值12gcc -D_REENTRANT//加入宏定义 线程程序12345678910111213#include&lt;pthread.h&gt;int pthread_create(pthread_t * thread, pthread_attr_t * attr,void *(*start_routine)(void *),void *arg);//第一个参数是指向pthread_t类型数据的指针.线程被创建时这个指针指向的变量中将被写入一个标识符.我们用该标识符来引用新线程//指针属性//执行的函数//函数的参数//函数成功返回0,失败返回错误码void pthread_exit(void *retval);//终止调用它的线程并返回一个指向某个对象的指针.绝不能返回一个局部变量int pthread_join(pthread_h th,void **thread_return);//要等待的指针//一个指针指向另一个指针,后者返回线程的返回值 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;void *thread_function(void *arg);char message[] = "Hello World";int main() &#123; int res; pthread_t a_thread; void *thread_result; res = pthread_create(&amp;a_thread, NULL, thread_function, (void *)message); if (res != 0) &#123; perror("Thread creation failed"); exit(EXIT_FAILURE); &#125; printf("Waiting for thread to finish...\n"); res = pthread_join(a_thread, &amp;thread_result); if (res != 0) &#123; perror("Thread join failed"); exit(EXIT_FAILURE); &#125; printf("Thread joined, it returned %s\n", (char *)thread_result); printf("Message is now %s\n", message); exit(EXIT_SUCCESS);&#125;void *thread_function(void *arg) &#123; printf("thread_function is running. Argument was %s\n", (char *)arg); sleep(3); strcpy(message, "Bye!"); pthread_exit("Thank you for the CPU time");&#125; 信号量信号量是一个特殊类型的变量,它可以被增加或减少,但对其的关键访问被保证是原子操作,即使在一个多线程程序中也是如此.这意味着如果一个程序中有两个(或更多)的线程试图改变一个信号量的值,系统将保证所有的操作都将依次进行,但如果是普通变量,来自同一程序中的不同线程的冲突操作导致的结果将是不确定的. 12345#include&lt;semaphore.h&gt;int sem_init(sem_t *sem, int pshared, unsigned int value);int sem_wait(sem_t *sem);int sem_post(sem_t *sem);int sem_destroy(sem_t *sem); 缺点在另一个线程没有及时处理的情况下,信号量会一直增加,造成资源问题和程序错误比如一个线程处理用户输入的字符,一个线程统计输入的字符数量.如果输入的太快,字符统计线程就会反复统计字符数目并减少信号量的值.直到它再次变为0为止. 互斥量它允许程序员锁住某个对象,使得每次只有一个线程访问它,为了对关键代码的访问必须在进入这段代码之前锁住一个互斥量.然后在完成操作之后解锁它. 12345678#include&lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * mutexattr);int pthread_mutex_lock(pthread_mutex_t * mutex);int pthread_mutex_unlock(pthread_mutex_t * mutex);int pthread_mutex_destroy(pthread_mutex_t * mutex); 可以设置线程属性默认为fast.如果程序试图对一个加了锁的互斥量调用pthread_mutex_lock,程序就会被阻塞,而又因为拥有互斥量的这个线程正是现在被阻塞的线程,所以互斥量就永远也不会被解锁了,程序也就进入死锁状态,这个问题可以通过改变互斥量的属性来解决.我们可以让它检查这种情况并返回一个错误,或者让它递归的操作,给同上个线程加上多个锁,但必须注意在后面执行同行数量的解锁操作 线程属性脱离线程在主线程启动之后不需要执行完后直接结束不需要主线程等待其结束 称为脱离线程.通过修改线程属性或调用pthread_detach的方法来创建 12345#include&lt;pthread.h&gt;int pthread_attr_init(pthread_attr_t *attr);//回收函数pthread_attr_destroy//它的目的是对属性对象进行清理和回收.一旦对象被回收了,除非它被重新初始化,否则就不能被再次使用 线程调度取消线程12#include&lt;pthread.h&gt;int pthread_cancel(pthread_t thread); 可以设置取消状态,接收到取消消息后立即行动,另一个是等待直到线程执行了特定函数如pthread_cond_wait 多线程对共享变量和多个执行路径没有做到足够重视时,程序很有可能出现错误行为]]></content>
      <categories>
        <category>BLP</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++杂项]]></title>
    <url>%2F2018%2F09%2F30%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2F%E6%9D%82%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[new数组初始化问题12345int *pia = new int[10];//申请空间的值是随机值,int *pia2 = new int[10]();//申请的空间的值初始化为0;//调用默认构造函数 实测都打印为0 等概率输出m个随机数假设n远大于m123456789knuth(int n,int m) &#123; srand((unsigned int)time(0)); for(int i = 0;i &lt; n;i++) &#123; if(rand() % (n - i) &lt; m) &#123; cout&lt;&lt;i&lt;&lt;endl; m--; &#125; &#125;&#125; 由这个for循环循环n次，且在满足条件时才输出i,可知，输出m个不同值的要求已满足，因为每次输出的都是i值，而i值每次都是不一样的，m—保证了程序在输出了m个值后就停止循环。在i=0时，rand()%(n-i)的取值范围为0到n-1，共n个数，此时要输出0只需要rand()%(n-i)小于m，故i=0被输出的概率为m/n;在i=1时，rand()%(n-i)的取值范围为0到n-2，共n-1个数，若i=0没有被输出，则m—未被执行，此时i=1被输出的概率为m/(n-1)，若i=0已经被输出了，则m变为m-1，此时i=1被输出的概率为(m-1)/(n-1)；由概率论的知识，可知此时i=1被输出的概率为P=(1-m/n)(m/(n-1))+m/n((m-1)/(n-1))=m/n；以此类推，可知每个数被输出的概率都为m/n]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2018%2F09%2F29%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FB%E6%A0%91%E5%92%8CB%2B%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树的不足在B树的结构中,在每个结点之间往返意味着,必须得在硬盘的页面之间进行多次访问,假如希望遍历B树,每个结点都属于硬盘的不同页面,我们为了中序遍历,会频繁的在页面间切换B+树,在B树的结构基础上,加上了新的元素组织方式.!B树和B+树详解!从B树B+树到R树]]></content>
      <categories>
        <category>C++面试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>B树</tag>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树(AVL)]]></title>
    <url>%2F2018%2F09%2F29%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2FAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[它是一种高度平衡的二叉排序树,高度平衡指的是要么它是一棵空树,要么它的左子树和右子树都是平衡二叉树,且左子树和右子树的深度之差的绝对值不超过1,我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor),那么平衡二叉树上所有的结点的平衡因子只可能是-1,0,和1只要二叉树上有一个结点的平衡因子的绝对值大于1则该二叉树就是不平衡的.实现原理:在构建二叉排序树的过程中,每当插入一个结点时,先检查是否因插入而破坏了树的平衡性,若是,则找出最小不平衡子树在保持二叉排序树特性的前提下,调整最小不平衡子树各结点之间的链接关系,进行相应的旋转,使之成为新的平衡子树 !AVL树]]></content>
      <categories>
        <category>C++面试</category>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>AVL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找优化]]></title>
    <url>%2F2018%2F09%2F29%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[插值查找传统二分查找算法mid = (low + high) / 2;变换后得到mid = low + 1 / 2 (high - low);进一步转换为mid = low + (value - a[low])/(a[high] - a[low]) (high - low);插值查找是根据要查找关键字key与查找表中最大最小记录的关键字比较后的查找方法,其核心就在于插值的计算公式.对于均匀的查找表来说比较适用,]]></content>
      <categories>
        <category>C++面试</category>
        <category>算法</category>
        <category>查找</category>
      </categories>
      <tags>
        <tag>二分查找优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx源码安装和boost安装]]></title>
    <url>%2F2018%2F09%2F28%2Flinux%2Fnginx%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E5%92%8Cboost%E5%BA%93%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[nginx安装zlibpcreopenssl1234567891011sudo apt-get install libz-dev libpcre3-dev//centosyum install zlib zlib-develyum install pcre pcre-develwget http://nginx.org/download/nginx-1.8.0.tar.gznx.org/download/nginx-1.8.0.tar.gztar -zxvf ./configuremake sudo make install 安装boost库www.boost.org下载源码包 ```bash./bootstrap.shsudo ./b2 link=static install //安装到/usr/local目录下]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx特点]]></title>
    <url>%2F2018%2F09%2F28%2Fnginx%2F01%2F</url>
    <content type="text"><![CDATA[特点: 高性能完全使用c编写,采用事件驱动模型. 高稳定性内存池one master/multi workers进程池 低资源消耗不使用传统的进程或线程服务器模型,没有进程或线程切换时的系统成本.使用字符串而不是拷贝,使用linux的sendfile调用用来零拷贝发送数据. 高扩展性进程模型启动一个master进程和多个worker进程来对外提供服务,master监控进程,不处理具体的htttp请求只接收unix信号,管理和监控worker进程,worker进程平等地竞争客户端的连接,执行nginx主要的业务逻辑,使用epoll,kqueue等机制高效率地处理HTTP请求master进程和worker进程使用操作系统提供的进程间通信机制,如信号,unix域套接字,共享内存等互相通信]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中断处理函数不能使用printf的本质]]></title>
    <url>%2F2018%2F09%2F28%2FBLP%2F%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8printf%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[阻塞在全局变量STDOUT上vxworks 中断处理程序之所以不用printf，本质在于printf是将信息输出到标准输出设备(STDOUT)中, 整个标准输出设备是一个全局变量，由于有semTake操作，那么就会发生阻塞，vxworks属于硬实时操作系统，不能在规定的时间内完成操作即会死机或复位。所以vxworks不用printf的原因在于阻塞。 网上说printf 因为引用全局变量stdout，所以是不可重入的。这个稍微解释一下。如果用到了全局变量，但是用信号量保护，是线程安全的，但是不可重入的（会导致死锁，譬如一个任务或中断处理程序调用了printf，被另一个高优先级中断打断，那么就会形成死锁而导致系统复位）。 所以这里的阻塞和不可重入都是因为对共享变量的保护而采用互斥锁引起的，而这里的阻塞是不可重入的一个真子集。（例如：可能有些函数对静态或全局变量没有锁保护，因此是非线程安全，也是非可重入的，此时并没有阻塞在静态或全局变量上，所以不可重入的概念要大。）。因此printf不能用在中断处理程序中的根本原因在于使用了全局变量后采用了锁机制，而锁机制会导致阻塞，阻塞是不可重入的真子集。 所以网上说printf因为不可重入，也会说得过去的（但不可重入还有其他非阻塞的场景）。更准确的说法是因为阻塞在全局变量STDOUT上）。关于可重入和线程安全的区别，下文会有详细解释： 线程安全函数 • 概念： 线程安全的概念比较直观。一般说来，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。 • 确保线程安全： 要确保函数线程安全，主要需要考虑的是线程之间的共享变量。属于同一进程的不同线程会共享进程内存空间中的全局区和堆，而私有的线程空间则主要包括栈和寄 存器。因此，对于同一进程的不同线程来说，每个线程的局部变量都是私有的，而全局变量、局部静态变量、分配于堆的变量都是共享的。在对这些共享变量进行访 问时，如果要保证线程安全，则必须通过加锁的方式。 • 线程不安全的后果： 线程不安全可能导致的后果是显而易见的——共享变量的值由于不同线程的访问，可能发生不可预料的变化，进而导致程序的错误，甚至崩溃。 可重入函数 • 概念： 可重入的概念基本没有比较正式的完整解释，多数的文档都只是说明什么样的情况才能保证函数可重入，但没有完整定义。按照Wiki上的说法，“A computer program or routine is described as reentrant if it can be safely executed concurrently; that is, the routine can be re-entered while it is already running.”根据笔者的经验，所谓“重入”，常见的情况是，程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理 函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，这样便发生了所谓的重入。此时如果foo()能够正确的运行，而且处理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。 • 确保可重入： 要确保函数可重入，需满足以下几个条件： 1、不在函数内部使用静态或全局数据 2、不返回静态或全局数据，所有数据都由函数的调用者提供。 3、使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。 4、不调用不可重入函数。 • 不可重入的后果： 不可重入的后果主要体现在象信号处理函数这样需要重入的情况中。如果信号处理函数中使用了不可重入的函数，则可能导致程序的错误甚至崩溃。 可重入与线程安全 可重入与线程安全并不等同。一般说来，可重入的函数一定是线程安全的，但反过来不一定成立。 如果一个函数中用到了全局或静态变量，那么它不是线程安全的，也不是可重入的； 如果我们对它加以改进，在访问全局或静态变量时使用互斥量或信号量等方式加锁，则可以使它变成线程安全的，但此时它仍然是不可重入的，因为通常加锁方式是针对不同线程的访问，而对同一线程可能出现问题；这里举例说明：假设函数func() 在执行过程中需要访问某个共享资源，因此为了实现线程安全，在使用该资源前加锁，在不需要资源解锁。 假设该函数在某次执行过程中，在已经获得资源锁之后，有异步信号发生，程序的执行流转交给对应的信号处理函数；再假设在该信号处理函数中也需要调用函数 func() ，那么func() 在这次执行中仍会在访问共享资源前试图获得资源锁，然而我们知道前一个func() 实例已然获得该锁，因此信号处理函数阻塞。另一方面，信号处理函数结束前被信号中断的线程是无法恢复执行的，当然也没有释放资源的机会，这样就出现了线程和信号处理函数之间的死锁局面。 因此，func() 尽管通过加锁的方式能保证线程安全，但是由于函数体对共享资源的访问，因此是非可重入。如果将函数中的全局或静态变量去掉，改成函数参数等其他形式，则有可能使函数变成既线程安全，又可重入。比如：strtok函数是既不可重入的，也不是线程安全的；加锁的strtok不是可重入的，但线程安全；而strtok_r既是可重入的，也是线程安全的.]]></content>
      <categories>
        <category>BLP</category>
      </categories>
      <tags>
        <tag>中断处理</tag>
        <tag>线程安全</tag>
        <tag>可重入函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和信号]]></title>
    <url>%2F2018%2F09%2F26%2FBLP%2Fch11_%E8%BF%9B%E8%A1%8C%E5%92%8C%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[进程进程定义:一个其中运行着一个或多个线程的地址空间和这些线程所需要的系统资源正常情况下程序代码是以只读的方式加载到内存中的.所有的进程都init进程启动或init启动的其他进程启动 进程调度Linux内核用进程调度器来决定下一个时间片应该分配给那个进程(优先级).多任务中持续占用cpu并轮询系统来查看是否有新输入的到达的程序没有执行短期突发性并等待输入的进程表现好表现良好的进程称为nice进程.默认为0系统根据变化改变nice值可以使用命令启动1nice oclock &amp; 会分配一个+10的nice值,如果用下面的命令调整这个值1renice 10 1362 使用ps -l查看如果状态栏STAT中包含字符N表明这个进程的nice值已经被修改过了,不是默认值了 启动新进程system可以通过库函数system来完成12#include&lt;stdlib.h&gt;int system(const char *string); 以字符串参数的形式传递给它的命令并等待该命令的完成.命令的执行情况就如同在shell中执行如下的命令sh -c string如果无法启动shell来运行这个命令,system函数将返回错误代码127,如果是其他错误则返回-1.否则system函数将返回该命令的退出码一般来说,使用system函数远非启动其他进程的理想手段,因为它必须用一个shell来启动需要的程序.由于在启动程序之前需要先启动一个shell,而且对shell的安装情况及使用的环境的依赖也很大,所以使用system函数的效率不高. exec系列函数替换进程映像exec函数可以把当前进程替换为一个新进程,新进程由path或file参数指定.可以使用exec将程序的执行从一个程序切换到另一个程序.exec函数比system函数更有效,因为在新的程序启动后,原来的程序就不再运行了.复制进程映像使用fork1234#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t fork(void); fork调用返回子进程的PID,新进程将继续执行.就像原进程一样,不同之处在于,子进程中的fork调用返回的是0.父子进程可以通过这个判断父子进程如果fork失败,返回-1,通常因为父进程拥有的子进程数目超过了规定的限制(CHILD_MAX),此时errno将被设置为EAGAIN.如果因为进程表里没有足够的空间用于创建新的表单或虚拟内存不足,errno变量将被设为ENOMEM 12345678910111213141516171819202122232425262728293031323334#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; pid_t pid; char *message; int n; printf("fork program starting\n"); pid = fork(); switch(pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "This is the child"; n = 5; break; default: message = "This is the parent"; n = 3; break; &#125; for(; n &gt; 0; n--) &#123; puts(message); sleep(1); &#125; exit(0);&#125; wait函数等待子进程退出1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t wait(int *stat_loc);#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; pid_t pid; char *message; int n; printf("fork program starting\n"); pid = fork(); switch(pid) &#123; case -1: perror("fork failed"); exit(1); case 0: message = "This is the child"; n = 3; break; default: message = "This is the parent"; n = 5; break; &#125; for(; n &gt; 0; n--) &#123; puts(message); sleep(1); &#125; exit(0);&#125;#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid,int * stat_loc,int options); pid 参数指定需要等待的子进程的PID,如果它的值为-1,waitpid将返回任一子进程的信息,与wait一样,如果stat_loc不是空指针,waitpid将把状态信息写到它所指向的位置.option参数可以改变waitpid的行为.其中最有用的一个选项是WNOHANG,它的作用是防止waitpid调用将调用者的执行挂起父进程周期性检查某个特定子进程是否已终止,使用如下调用方式 1waitpid(child_pid,(int *) 0,WNOHANG); 僵尸进程子进程终止时,它与父进程之间的关联还会保持,直到父进程也正常终止或父进程调用wait才告结束.因此,进程表中代表子进程的表项不会立刻释放,虽然子进程已经不在运行,但它仍然存在于系统中,因为它的退出码还需要保存起来,以备父进程今后的wait调用,这时它将成为一个僵尸进程. 如果父进程异常终止,子进程将自动把PID为1的进程(即init)作为自己的父进程,子进程现在是一个不再运行的僵尸进程,但因为其父进程异常终止,所以它由init进程接管,僵尸进程将一直保留在进程表中直到被init进程发现并释放,进程表越大这一过程就越慢.应该尽量避免产生僵尸进程,因为在init清理它们之前,它们将一直消耗系统的资源. 输入和输出重定向12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849upper.c#include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int ch; while((ch = getchar()) != EOF) &#123; putchar(toupper(ch)); &#125; exit(0); &#125; useupper.c/* This code, useupper.c, accepts a file name as an argument and will respond with an error if called incorrectly. */ #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) &#123; char *filename; if(argc != 2) &#123; fprintf(stderr, "usage: useupper file\n"); exit(1); &#125; filename = argv[1]; /* That done, we reopen the standard input, again checking for any errors as we do so, and then use execl to call upper. */ if(!freopen(filename, "r", stdin)) &#123; fprintf(stderr, "could not redirect stdin to file %s\n", filename); exit(2); &#125; execl("./upper", "upper", 0); /* Don't forget that execl replaces the current process; provided there is no error, the remaining lines are not executed. */ perror("could not exec ./upper"); exit(3); &#125; 信号信号是由于某些错误条件而生成的,如内存段冲突,浮点处理器错误或非法指令等.如果进程收到signal.h中的一些信号,但没有事先安排捕获它,进程会立刻终止,系统将生成核心转储文件core,并将其放在当前目录下该文件是进程在内存中的映像.它对程序的调度很有用处. 信号函数 1void (*signal(int sig, void (*func)(int)))(int); 准备捕获或忽略的信号由参数sig给出,接收到指定的信号后将要调用的函数由参数func给出.信号处理函数必须有一个int类型的参数(即接收到的信号代码)并且返回类型为void.signa函数本身也返回一个同类型的函数.即先前用来处理这个信号的函数.或者用SIG_IGN(忽略信号)和SIG_DEF(恢复默认行为) 123456789101112131415161718192021222324252627282930/* We'll start by writing the function which reacts to the signal which is passed in the parameter sig. This is the function we will arrange to be called when a signal occurs. We print a message, then reset the signal handling for SIGINT (by default generated by pressing CTRL-C) back to the default behavior. Let's call this function ouch. */ #include &lt;signal.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; void ouch(int sig) &#123; printf("OUCH! - I got signal %d\n", sig); (void) signal(SIGINT, SIG_DFL); &#125; /* The main function has to intercept the SIGINT signal generated when we type Ctrl-C . For the rest of the time, it just sits in an infinite loop, printing a message once a second. */ int main() &#123; (void) signal(SIGINT, ouch); while(1) &#123; printf("Hello World!\n"); sleep(1); &#125; &#125; 在信号处理函数中,调用如printf这样的函数是不安全的,一个ISR应该避免调用不可重入函数。一些标准库函数是不可重入的，如经常实现的malloc和printf。因为中断可能发生在执行任务中，因为任务可能是在“malloc”的函数调用中，如果ISR调用此相同的不可重入函数，由此产生的行为可能是灾难性的。不可重入函数是指这样的一类函数，不可以在它还没有返回就再次被调用。例如printf，malloc，free等都是不可重入函数。因为信号可能在任何时候发生，例如在printf执行过程中，因此不能在信号处理函数里调用printf，否则printf将会被重入。 函数不可重入大多数是因为在函数中引用了全局变量。例如，printf会引用全局变量stdout，malloc，free会引用全局的内存分配表。 发送信号123#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;int kill(pid_t pid,int sig); kill函数把参数指定的信号发送给由参数pid给出的进程号所指定的进程,冬暖夏凉时它返回0. 12#inlucde&lt;unistd.h&gt;unsigned int alarm(unsigned int seconds); alarm函数用来在seconds秒之后安排发送一个SIGALRM信号 函数pause把程序挂起直到有一个信号出现12#include&lt;unistd.h&gt;int pause(void); 需要等待信号的话,一个常用的函数为sigsuspend函数如果信号出现在系统调用的执行过程中,结果是视情况而定如果想调用pause等待一个信号,可信号却出现在调用pause之前,就会使程序无限期的等待一个不会发生的事件 健壮的信号接口sigaction 12345678#include&lt;signal.h&gt;int sigaction(int sig,const struct sigaction * act,struct sigaction *oact);//sigaction结构void(*) int sa_handlersigset_t sa_maskint sa_flags sa_handler是一个函数指针在接收到信号sig后被调用的处理函数sa_mask指定一组信号集,将被阻塞不会被传递给进程的信号.设置信号屏蔽字可以防止信号在它的处理函数还示运行结束时就被接收到的情况,使用sa_mask字段可以消除这一竞态条件. 信号集sigaction和其他函数将用这些信号来修改进程在接收到信号的行为.]]></content>
      <categories>
        <category>BLP</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注释和删除]]></title>
    <url>%2F2018%2F09%2F23%2FVim%2F%E6%B3%A8%E9%87%8A%E5%92%8C%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[多行注释： 首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式; 在行首使用上下键选择需要注释的多行; 按下键盘（大写）“I”键，进入插入模式； 然后输入注释符（“//”、“#”等）; 最后按下“Esc”键。 注：在按下esc键后，会稍等一会才会出现注释，不要着急时间很短的 删除多行注释： 首先按esc进入命令行模式下，按下Ctrl + v, 进入列模式; 选定要取消注释的多行; 按下“x”或者“d”. 注意：如果是“//”注释，那需要执行两次该操作，如果是“#”注释，一次即可 多行删除1.首先在命令模式下，输入“：set nu”显示行号； 2.通过行号确定你要删除的行； 3.命令输入“：32,65d”,回车键，32-65行就被删除了，很快捷吧如果无意中删除错了，可以使用‘u’键恢复（命令模式下）]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java和C的一些基础不同]]></title>
    <url>%2F2018%2F09%2F23%2FJava%2F01%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型的长度byte 1字节 -128 - 127short 2字节 -32768-32767char 2字节int 4字节 -2147483648-2147483647long 8字节float 4字节double 8字节 布尔值布尔类型通过关键字boolean来定义布尔类型变量只有true和false两个值,分别代表布尔逻辑的真和假,布尔值不能与整数类型进行转换, 常量final 数据类型 常量名称 短路&amp;&amp;短路 &amp; 不短路 switch可以是字符串类型 foreachfor(元素变量x:遍历对象obj) { 引用了x的java语句} String字符串基本 创建 12345char a[] = &#123;'g','o','o','d'&#125;;String s = new String(a); //goodString s = new String(a,2,3);//od 长度 1str.length(); 字符串查找 12indexOf(String s) //返回首次出现的索引位置lastIndexOf //最后一次出现索引位置 指定索引位置的字符1str.charAt(int index); //char 字符串操作 获取子字符串 12str.substring(int beginIndex);str.substring(int beginIndex,endIndex); 去除空格 1str.trim(); 字符串替换 1str.replace(char oldChar,char newChar): //返回String 判断字符串开始与结尾 12startWith(String prefix);endsWith(String sufix); //返回布尔 字符串相等不能简单使用==因为比较运算符比较的是两个字符串的地址是否相同equals()方法 12str.equals(String otherstr);str.equalsIgnoreCase(String otherstr); 字典序比较两个字符串 1str.compareTo(String otherstr); 字符串大小写转换 12str.toLowerCase();str.toUpperCase(); 字符串分割使用指定分割字符对字符串进行分割,并将分割后的结果存放在字符串数组中, 1234str.split(String sign);str.split(String sign,int limit);String newstr = str.split(" ");//limit为次数 格式化字符串1234str.format(String format,Object ...args);/*format:格式字符串args: 格式字符串中由格式说明符引用的参数. 日期和时间字符串格式化 12Date date = new Date();String year = String.format("%tF");//年-月-日格式 正则表达式 12String regex = "\\w";str1.matches(regex); 字符串生成器使用 “+”会产生一个新的String实例,会在内存中创建新的字符串对象使用StringBuild 12StringBuild builder = new StringBuild("");builder.append(j); append()1234append(content);//用于向生成器的追加内容,通过多个重载,可以接受任何基本类型insert(int offset arg);delete(int start,int end);//使用toString转换 数组12345678910111213int a[] = new int[5];int arr[] = new int[]&#123;1,2,3,4,5&#125;;int arr2[] = &#123;34,2,3,4&#125;;//二维a = new int[2][];a[0] = new int[2];a[1] = new int[3]; 长度a.length; 填充数组元素静态方法使用多个重载支持不同数据类型将指定的int值分配给int型数组的每个元素fill(int[] a, int value);fill(int[] a,int fromIndex,int toIndex,int value);//从索引fromIndex(包括),到索引toIndex(不包括)进行填充 排序arrays.sort(object); 复制arrays.copyOf(arr,int newLength);arrays.copyOfRange(arr,int fromindex,int toIndex); 查询//返回索引binarySearch(Obect[].Object.key);需要先排序binarysearch(Object[].a,int fromIndex,int toIndex,Object key);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[错误]]></title>
    <url>%2F2018%2F09%2F20%2F%E9%94%99%E8%AF%AF%2Ferror%2F</url>
    <content type="text"><![CDATA[1printf("%o",a);//以8进制输出]]></content>
      <categories>
        <category>错误</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数之间调用和递归]]></title>
    <url>%2F2018%2F09%2F20%2FC%2B%2B%2F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[调用函数和被调用函数之间的链接及信息交换需通过栈来进行 当在一个函数的运行期间调用另一个函数时,在运行被调用函数之前,系统需要完成3件事, 将所有的实在参数,返回地址等信息传递给被调用函数保存; 为被调用函数的局部变量分配存储区 将控制转移到被调函数的入口 而被调用函数返回调用函数之前,系统也应完成3件工作: 保存被调函数的计算结果 释放被调用函数的数据区 依照被调函数保存的返回地址将控制转移到调用函数当有多个函数构成嵌套调用时,按照后调用先返回的原则.上述函数之间的信息传递和控制转移必须通过栈来实现为保证递归函数的正确执行.系统需设立一个”递归工作栈”作为整个递归函数运行期间使用的数据存储区.每一层递归所需信息构成一个”工作记录”,其中包括所有的实在参数,所有的局部变量以及上一层的返回地址]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[epoll]]></title>
    <url>%2F2018%2F09%2F18%2FlinuxC%2Fepoll%2F</url>
    <content type="text"><![CDATA[epoll 是 Linux 内核为处理大批句柄而作改进的 poll ，是 Linux 特有的 I/O 函数。其特点如下： epoll 是 Linux 下多路复用 IO 接口 select/poll 的增强版本。其实现和使用方式与 select/poll 有很多不同，epoll 通过一组函数来完成有关任务，而不是一个函数。 epoll 之所以高效，是因为 epoll 将用户关心的文件描述符放到内核里的一个事件表中，而不是像 select/poll 每次调用都需要重复传入文件描述符集或事件集。比如当一个事件发生（比如说读事件），epoll 无须遍历整个被侦听的描述符集，只要遍历那些被内核 IO 事件异步唤醒而加入就绪队列的描述符集合就行了。 epoll 有两种工作方式，LT(level triggered)：水平触发和 ET(edge-triggered)：边沿触发。LT 是 select/poll 使用的触发方式，比较低效；而 ET 是 epoll 的高速工作方式（本项目使用 epoll 的 ET 方式）。 通俗理解就是，比如说有一堆女孩，有的很漂亮，有的很凤姐。现在你想找漂亮的女孩聊天，LT 就是你需要把这一堆女孩全都看一遍，才可以找到其中的漂亮的（就绪事件）；而ET是你的小弟（内核）将N个漂亮的女孩编号告诉你，你直接去看就好，所以 epoll 很高效。另外，还记得小明找女神聊天的例子吗？采用非阻塞方式，小明还需要每隔十分钟回来看一下（select）；如果小明有小弟（内核）帮他守在大门口，女神回来了，小弟会主动打电话，告诉小明女神回来了，快来处理吧！这就是 epoll。 epoll 共3个函数, 如下: 12int epoll_create(int size)//创建一个epoll句柄，参数size用来告诉内核监听的数目，size为epoll所支持的最大句柄数 123456789101112131415int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)函数功能： epoll事件注册函数 参数epfd为epoll的句柄，即epoll_create返回值 参数op表示动作，用3个宏来表示： EPOLL_CTL_ADD(注册新的fd到epfd)， EPOLL_CTL_MOD(修改已经注册的fd的监听事件)， EPOLL_CTL_DEL(从epfd删除一个fd)； 其中参数fd为需要监听的标示符； 参数event告诉内核需要监听的事件，event的结构如下：struct epoll_event &#123; __uint32_t events; //Epoll events epoll_data_t data; //User data variable&#125;;其中介绍events是宏的集合，EPOLLIN(表示对应的文件描述符可以读，即读事件发生)，其他宏类型，可以google之！ 123、 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)等待事件的产生，函数返回需要处理的事件数目（该数目是就绪事件的数目，就是前面所说漂亮女孩的个数N） 因此服务端使用epoll的时候，步骤如下：调用epoll_create函数在Linux内核中创建一个事件表；然后将文件描述符（监听套接字listener）添加到所创建的事件表中；在主循环中，调用epoll_wait等待返回就绪的文件描述符集合；分别处理就绪的事件集合，本项目中一共有两类事件：新用户连接事件和用户发来消息事件（epoll还有很多其他事件，本项目为简洁明了，不介绍）。]]></content>
      <categories>
        <category>linuxC</category>
      </categories>
      <tags>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket通信]]></title>
    <url>%2F2018%2F09%2F18%2FlinuxC%2Fsocket%2F</url>
    <content type="text"><![CDATA[TCP服务端通信的常规步骤: 使用 socket()创建 TCP 套接字（socket） 将创建的套接字绑定到一个本地地址和端口上（Bind） 将套接字设为监听模式，准备接收客户端请求（listen） 等待客户请求到来: 当请求到来后，接受连接请求，返回一个对应于此次连接的新的套接字（accept） 用 accept 返回的套接字和客户端进行通信（使用write()/send()或send()/recv() ) 返回，等待另一个客户请求 关闭套接字 12345678910111213141516171819202122232425//服务端地址 ip地址 + 端口号struct sockaddr_in serverAddr;serverAddr.sin_family = PF_INET;serverAddr.sin_port = htons(SERVER_PORT);serverAddr.sin_addr.s_addr = inet_addr(SERVER_HOST);//服务端创建监听socketint listener = socket(PF_INET, SOCK_STREAM, 0);if(listener &lt; 0) &#123; perror("listener"); exit(-1);&#125; printf("listen socket created \n"); //将服务端地址与监听socket绑定 if( bind(listener, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) &lt; 0) &#123; perror("bind error"); exit(-1);&#125;//开始监听int ret = listen(listener, 5);if(ret &lt; 0) &#123; perror("listen error"); exit(-1);&#125;printf("Start to listen: %s\n", SERVER_HOST); TCP 客户端通信的常规步骤: 创建套接字（socket）使用 connect() 建立到达服务器的连接（connect)客户端进行通信（使用 write()/send() 或 send()/recv() )使用 close() 关闭客户连接 12345678910111213141516//客户要连接的服务端地址（ ip地址 + 端口号）struct sockaddr_in serverAddr;serverAddr.sin_family = PF_INET;serverAddr.sin_port = htons(SERVER_PORT);serverAddr.sin_addr.s_addr = inet_addr(SERVER_IP);// 创建套接字（socket）int sock = socket(PF_INET, SOCK_STREAM, 0);if(sock &lt; 0) &#123; perror("sock error"); exit(-1); &#125;//向服务器发出连接请求（connect）if(connect(sock, (struct sockaddr *)&amp;serverAddr, sizeof(serverAddr)) &lt; 0) &#123; perror("connect error"); exit(-1);&#125;]]></content>
      <categories>
        <category>linuxC</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阻塞与非阻塞socket]]></title>
    <url>%2F2018%2F09%2F18%2FlinuxC%2F%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9Esocket%2F</url>
    <content type="text"><![CDATA[通常的，对一个文件描述符指定的文件或设备, 有两种工作方式: 阻塞与非阻塞方式。 阻塞方式是指： 当试图对该文件描述符进行读写时，如果当时没有数据可读，或者暂时不可写，程序就进入等待状态，直到有东西可读或者可写为止。 非阻塞方式是指： 如果没有数据可读，或者不可写，读写函数马上返回，而不会等待。 举个例子来说： 比如说小明去找一个女神聊天，女神却不在。 如果小明舍不得走，只能在女神大门口死等着，当然小明可以休息。当女神来了，她会把你唤醒（囧，因为挡着她门了），这就是阻塞方式。 如果小明发现女神不在，立即离开，以后每隔十分钟回来看一下（采用轮询方式），不在的话仍然立即离开，这就是非阻塞方式。 阻塞方式和非阻塞方式唯一的区别： 是否立即返回。 1234567//将文件描述符设置为非阻塞方式（利用fcntl函数）int setnonblocking(int sockfd)&#123; fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFD, 0)| O_NONBLOCK); return 0;&#125;]]></content>
      <categories>
        <category>linuxC</category>
      </categories>
      <tags>
        <tag>阻塞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定制vim]]></title>
    <url>%2F2018%2F09%2F16%2FVim%2F06%E5%AE%9A%E5%88%B6vim%2F</url>
    <content type="text"><![CDATA[6.1 vimrc文件 如果你厌倦了手工键入常用的命令,或者要使你喜好的选项和映射一次性准备好,这时可以统统写入到vimrc(vim run command)的文件里,Vim在启动时会读取这个文件. vimrc位置: Unix and OS/2: ~/.vimrc Windows : $VIM_vimrc 6.2 vimrc示例文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183" An example for a vimrc file." Maintainer: DaiDai" Last change: 2017年6月29日" When started as "evim", evim.vim will already have done these settings.if v:progname =~? "evim"finishendif" Use Vim settings, rather than Vi settings (much better!)." This must be first, because it changes other options as a side effect.set nocompatible" allow backspacing over everything in insert modeset backspace=indent,eol,startif has("vms")set nobackup " do not keep a backup file, use versions insteadelseset backup " keep a backup file (restore to previous version)set undofile " keep an undo file (undo changes after closing)endifset history=50 " keep 50 lines of command line historyset ruler " show the cursor position all the timeset showcmd " display incomplete commandsset incsearch " do incremental searching" For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries" let &amp;guioptions = substitute(&amp;guioptions, "t", "", "g")" Don't use Ex mode, use Q for formattingmap Q gq" CTRL-U in insert mode deletes a lot. Use CTRL-G u to first break undo," so that you can undo CTRL-U after inserting a line break.inoremap &lt;C-U&gt; &lt;C-G&gt;u&lt;C-U&gt;" In many terminal emulators the mouse works just fine, thus enable it.if has('mouse')set mouse=aendif" Switch syntax highlighting on, when the terminal has colors" Also switch on highlighting the last used search pattern.if &amp;t_Co &gt; 2 || has("gui_running")syntax on" 打开语法高亮set hlsearchendif" Only do this part when compiled with support for autocommands.if has("autocmd")" Enable file type detection." 'cindent' is on in C files, etc." Also load indent files, to automatically do language-dependent indenting." Put these in an autocmd group, so that we can delete them easily.augroup vimrcExau!" For all text files set 'textwidth' to 78 characters.autocmd FileType text setlocal textwidth=78" When editing a file, always jump to the last known cursor position." Don't do it when the position is invalid or when inside an event handler" (happens when dropping a file on gvim).autocmd BufReadPost *\ if line("'\"") &gt;= 1 &amp;&amp; line("'\"") &lt;= line("$") |\ exe "normal! g`\"" |\ endifaugroup ENDelseset autoindent " always set autoindenting onendif " has("autocmd")" Convenient command to see the difference between the current buffer and the" file it was loaded from, thus the changes you made." Only define it when not defined already.if !exists(":DiffOrig")command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis\ | wincmd p | diffthisendifif has('langmap') &amp;&amp; exists('+langnoremap')" Prevent that the langmap option applies to characters that result from a" mapping. If unset (default), this may break plugins (but it's backward" compatible).set langnoremapendif" Add optional packages."" The matchit plugin makes the % command work better, but it is not backwards" compatible.packadd matchit 6.3 简单的映射 一个映射可以把一连串Vim命令用一个按键来表示. 如:用一个功能键或字符串,将某个word单词,变成{word},可以使用:map命令. 12345:map &lt;F5&gt; i&#123;&lt;Esc&gt;ea&#125;&lt;Esc&gt;:map \abc i&#123;&lt;Esc&gt;ea&#125;&lt;Esc&gt;&#123;amount&#125; 6.4 选项窗口 ​ :options命令:在帮助主题中寻找或设置相应的选项. ​ “ Each “set” line shows the current value of an option (on the left). ​ “ Hit on a “set” line to execute it. ​ “ A boolean option will be toggled. ​ “ For other options you can edit the value before hitting . ​ “ Hit on a help line to open a help window on this option. ​ “ Hit on an index line to jump there. ​ “ Hit on a “set” line to refresh it. ​ :set all命令:查看所有的设置选项. 6.5 常用选项 ​ :help ‘wrap’:查看某个选项的帮助. ​ :set shiftwidth&amp;:shiftwidth修改为默认值8. ​ set nowrap:不要折行. ​ set sidescroll=10:自动左右滚动10个字符. ​ set whichwrap=b,s :跨行移动命令 ​ set whichwrap=b,s,&lt;,&gt; :跨行移动命令 智能上上下下 ​ set whichwrap=b,s,&lt;,&gt;,[,] :跨行移动命令 智能上上下下 Insert模式下,也能如此. ​ set list :show as ^I and end-of-line as $ 显示特殊字符如Tab或换行符 ​ set listchars=tab:&gt;-,trail:-,eol:$$ :修改样式 ​ set iskeyword=@,48-57,_,192-255 :关键字默认字符要求 @:代表所有的字母;48-57 ASCII从48&gt;到57 即0到9;192-225 可以打印的字符; ​ set iskeyword+=- :增加连词符 ​ set iskeyword-=- :去掉连词符 ​ fdafd-fdasfdasfs ​ set cmdheight=3 :number of lines used for the command-line 命令行高度. 6.6 使用高亮 1234567891011:syntax enable:打开语法支持:set filetype=c :改变当前文件所属类型.:set filetype=java :int boolean:set filetype=vim:syntax clear 关闭当前高亮.:colorscheme evening:打开不同的颜色主题.]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rm命令误删文件的恢复方法]]></title>
    <url>%2F2018%2F09%2F14%2Flinux%2Fshell%2Frm%E5%91%BD%E4%BB%A4%E8%AF%AF%E5%88%A0%E6%81%A2%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[extundelete1sudo apt-get install extundelete 使用这个工具，我成功的恢复了使用rm命令误删的文件,下面简单记录一下恢复过程。1sudo extundelete /dev/sda1 --restore-all 说明：/dev/sda1是误删文件所在的分区。我的误删的文件原来在/home/liyihai里面的子目录中，而这个目录挂载于/dev/sda1分区（使用df -h命令查看）。 执行上面命令后，会在当前目录中生成一个名为RECOVERED_FILES目录，并且将恢复的文件放到这个目录中。]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>rm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统的加载流程]]></title>
    <url>%2F2018%2F09%2F14%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E7%B3%BB%E7%BB%9F%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[操作系统的加载流程]]></content>
      <categories>
        <category>C++面试</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[win10开热点]]></title>
    <url>%2F2018%2F09%2F13%2Fwindows%2Fwin10%E7%83%AD%E7%82%B9%2F</url>
    <content type="text"><![CDATA[123netsh wlan set hostednetwork mode=allow ssid=daniu1 key=czx123456 netsh wlan start hostednetwork netsh wlan stop hostednetwork]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图标缓存修复]]></title>
    <url>%2F2018%2F09%2F13%2Fwindows%2F%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[这一般是系统图标缓存出现问题所致，可这样设置：按Ctrl+Shift+Esc打开任务管理器（也可右击任务栏，在打开的快捷菜单中单击任务管理器来打开），在进程列表中找到explorer.exe并将其结束，接下来在单击任务管理器菜单“文件→运行”，输入“cmd”并回车打开命令提示符窗口，输入以下命令： 123CD /d %userprofile%\AppData\LocalDEL IconCache.db /aEXIT 最后在任务管理器中单击“文件→运行”，输入“explorer.exe”重新启动该进程即可。]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bat命令去文件前缀]]></title>
    <url>%2F2018%2F09%2F13%2Fwindows%2F%E6%89%B9%E9%87%8F%E5%8E%BB%E6%96%87%E4%BB%B6%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[批量去除文件前缀 1234567891011121314151617@echo offsetlocal EnableDelayedExpansionfor %%n in (*.wmv) do (set name=%%necho !name!echo !name:PHP公益培训第3部-=!ren &quot;%%n&quot; &quot;!name:PHP公益培训第3部-=!.wmv&quot;)pause]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[oracle驱动找不到]]></title>
    <url>%2F2018%2F09%2F13%2Foracle%2Fproblems%2F%E9%A9%B1%E5%8A%A8%E6%89%BE%E4%B8%8D%E5%88%B0%2F</url>
    <content type="text"><![CDATA[Missing artifact com.oracle:ojdbc14:jar:10.2.0.4.0 解决方案]]></content>
      <categories>
        <category>oracle</category>
        <category>problems</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试50题]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2F%E9%9D%A2%E8%AF%9550%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试50题]]></content>
      <categories>
        <category>C++面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[各数据类型字节数以及和32位64位系统的关系]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%97%E8%8A%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、64位系统和32位有什么区别？64bit CPU拥有更大的寻址能力，最大支持到16GB内存，而32bit只支持4G内存64位CPU一次可提取64位数据，比32位提高了一倍，理论上性能会提升1倍。但这是建立在64bit操作系统，64bit软件的基础上的。什么是64位处理器？之所以叫做“64位处理器”，是因为电脑内部都是实行2进制运算，处理器（CPU）一次处理数据的能力也是2的倍数。8位处理器、16位处理器、32位处理器和64位处理器，其计数都是2的倍数。一次处理的数据越大，该电脑处理信息的能力越大；因此64位处理在先天就比32位处理器具有快速的能力。那为什么不用更高级的128位处理器呢？因为位数越高，处理器芯片的设计也就越复杂，目前的技术水平暂时无法制造这么复杂的芯片。 二、数据类型对应字节数程序运行平台不同的平台上对不同数据类型分配的字节数是不同的。个人对平台的理解是CPU+OS+Compiler，是因为： 1、64位机器也可以装32位系统（x64装XP）；2、32位机器上可以有16/32位的编译器（XP上有tc是16位的，其他常见的是32位的）；3、即使是32位的编译器也可以弄出64位的integer来（int64）。 以上这些是基于常见的windows平台，加上我们可能很少机会接触的其它平台（其它的CPU和OS），所以个人认为所谓平台的概念是三者的组合。 虽然三者的长度可以不一样，但显然相互配合（即长度相等，32位的CPU+32位的OS+32位的Compiler）发挥的能量最大。 理论上来讲 我觉得数据类型的字节数应该是由CPU决定的，但是实际上主要由编译器决定(占多少位由编译器在编译期间说了算)。常用数据类型对应字节数基本整型有char,short,int,long这四种。加上无符号的这四种，那就是8种。 可用如sizeof（char),sizeof(char*)等得出。 在C和C++编程中，数据类型的大小是在头文件limits.h和climits中包含。 32位编译器：1234567891011char ：1个字节（8位，一个ASCII码字符长度就是8位，unicode编码等16-32位）char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）short : 2个字节 （short其实是short int 的缩写）//（int最高可存4字节32位数据，最低16位，也可存24位）。int： 4个字节 。可表示 -2^16 ~ 2^16-1的有+ - 正负符号的整数unsigned int : 4个字节。可表示 0 ~ 2^32-1的无符号整数float: 4个字节double: 8个字节long: 4个字节 （long其实是long int 的缩写）long long: 8个字节unsigned long: 4个字节 64位编译器： 12345678910char ：1个字节char*(即指针变量): 8个字节short int : 2个字节int： 4个字节unsigned int : 4个字节float: 4个字节double: 8个字节long: 8个字节long long: 8个字节unsigned long: 8个字节 如何选择变量的整数类型通常，int 是计算机处理起来效率最高的长度，如果没有其他必要的理由，那么就用int。如果变量的值不可能为负值，那么就用 unsigned 无符号整型，同样的存储单元，可以表示更大的数。如果知道变量的值可能会超过16位，那么最好用long ，即使系统上int可表示32位，也应该这样做。因为，当程序移植到16位系统时，int只能表示16位，这时候程序中这个变量就会内存溢出，无法工作。short比int小，但是通常还是用int较多。只有当有大型整型数组时，才有必要使用short来节省内存空间。虽然有的系统int和short大小一样，但是当移植到int位数更大的系统时，用int定义的整型数组内存就翻倍了。内存能省则省。]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>数据类型大小</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08.函数探幽]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%20Prime%20Plus%2Fchapter8%2F</url>
    <content type="text"><![CDATA[内联函数对于内联代码,程序无需跳到另一个位置处执行代码.再跳回来.因此,内联函数的运行速度比常规函数稍快.代价是需要占用更多的内存. 在函数声明前加上关键字inline在函数定义前加上关键字inline 内联函数不能递归 引用变量引用是已定义的变量的别名(另一个名称).引用变量的主要用途是用途函数的形参.通过将引用变量用作参数.函数将使用原始数据,而不是其副本.12int rats;int &amp; rodents = rats; 引用和指针的区别 引用必须在创建时初始化. 引用更接近于const指针 按引用传递允许被调用函数能够访问调用函数中的变量. 12double refcude(const double &amp;ra);double c5 = refcube(7.0); 编译器将生成一个临时匿名变量,并让ra指向它,只在调用期间存在,之后编译器可以随意删除对于形参为const引用的c++函数,如果实参不匹配.则行为类似于按值传递, 右值引用double &amp;&amp; rref = 15.0; 引入右值引用的主要目的是让库设计人员能够提供有些操作的更有效实现. 引用用于结构返回引用.效率更高应避免返回指向临时变量的引用,函数运行完毕后它将不存在.同时也应避免返回指向临时变量的指针.1234567const string &amp; version(string &amp; s1,const string &amp;s2)&#123;string temp;temp = s2 + s1 + s2;return temp;&#125; ostream的一些方法setf()设置各种格式化状态 函数模板template(typename T&gt; //or class Tvoid Swap(T &amp;a,T &amp;b); 函数模板可以重载12345template&lt;typename T&gt;void Swap(T &amp;a,T &amp;b);template&lt;typename T&gt; //newvoid Swap(T *a,T *b,int n); 显示具体化C++98标准选择了下面的方法。对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。显式具体化的原型和定义应以template&lt;>打头，并通过名称来指出类型。具体化优先于常规模板，而非模板函数优先于具体化和常规模板。 template&lt;&gt; void Swap&lt;job&gt;(job &amp;,job &amp;); 如果有多个原型，则编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本。 实例化和具体化C++还允许显式实例化（explicit instantiation）。这意味着可以直接命令编译器创建特定的实例，如Swap( )。其语法是，声明所需的种类——用&lt;>符号指示类型，并在声明前加上关键字templatetemplate void Swap&lt;int&gt;(int ,int); 具体化12template &lt;&gt; void Swap&lt;int&gt;(int &amp;,int &amp;);template &lt;&gt; void Swap(int &amp;,int &amp;); 不要使用Swap( )模板来生成函数定义，而应使用专门为int类型显式地定义的函数定义 试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错 重载解析（overloading resolution）第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。第2步：使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错。 1．完全匹配，但常规函数优先于模板。2．提升转换（例如，char和shorts自动转换为int，float自动转换为double）。 3．标准转换（例如，int转换为char，long转换为double）。 4．用户定义的转换，如类声明中定义的转换。 编写模板函数时，一个问题是并非总能知道应在声明中使用哪种类型 关键字decltype（C++11）12int x;decltype(x) y; //make y the same type as x C++11后置返回类型1234567template&lt;class T1,class T2&gt;auto gt(T1 x,T2 y) -&gt; decltype(x+y) &#123;...return x+y;&#125; 总结C++扩展了C语言的函数功能。通过将inline关键字用于函数定义，并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。只有在函数很短时才能采用内联方式。 引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。通常，被声明为特定类型引用的标识符只能指向这种类型的数据；然而，如果一个类（如ofstream）是从另一个类（如ostream）派生出来的，则基类引用可以指向派生类对象。 C++原型让您能够定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；如果函数调用提供了参数值，则程序将使用这个值（而不是默认值）。只能在参数列表中从右到左提供默认参数。因此，如果为某个参数提供了默认值，则必须为该参数右边所有的参数提供默认值。 函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。通常，通过重载函数来为不同的数据类型提供相同的服务。 函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确的函数定义。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[07.函数]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%20Prime%20Plus%2Fchapter7%2F</url>
    <content type="text"><![CDATA[用于接收传递值的变量被称为形参.传递给函数的值被称为形参 将const变量的地址赋给指向const的指针是可行的,将const的地址赋给常规指针是不可行的.123456const float g_earth = 9.8;const float * pe = &amp;g_earth;//可行const float g_moon = 1.63;float * pm = &amp; g_moon; C++禁止将const指针赋给非const指针12345678int age = 39;const int * pt = &amp;age;//禁止修改*pt,可以改ptint * const finger = * age;//禁止修改finger的指向,可以改*finger; 递归123456789void recurs(argumentlist)&#123; statements1 if(test) recurs(arguments) statments2&#125; 如果recurs()进行了5次递归调用,则第一个statements1部分将按函数调用的顺序执行5次.然后statements2部分将以与函数调用相反的顺序执行5次.进入5层递归后,程序将沿进入的路径返回. 函数指针编写将另一个函数的地址作为参数的函数,允许在不同的时间传递不同函数的地址.可以在不同的时间使用不同的函数. 步骤:获取函数的地址声明一个函数指针使用函数指针来调用函数 函数地址:函数名 声明 1234double pam(int);//原型double(*pf) (int) //pf points to a function taht takes one //int argument and that//return type double 将pam替换成了(pf).由于pam是函数,因此(pf)也是函数.而如果(*pf)是函数则pf就是函数指针正确声明了pf后就可以将相应函数的地址赋给它123double pam(int);double (*pf)(int);pf = pam; 使用指针来调用 1234567double pam(int);double (*pf)(int);pf = pam;double x = pam(4);double y = (*pf)((5);double y = pf(5); 后两种调用方法同时允许 函数指针数组 12const double * (*pa[3])(const double *,int) = &#123;f1,f2,f3&#125;; auto只能用于单值初始化,不能初始化列表 指向pa数组的指针123auto pc = &amp;pa;const double *(*(pd)[3])(const double *,int) = &amp;pa; 使用typedef来简化12345typedef const double *(*p_fun)(const double * ,int);p_fun p1=f1;p_fun pa[3] = &#123;f1,f2,f3&#125;;p_fun(*pd)[3] = &amp;pa;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[06.分支和逻辑运算符]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%20Prime%20Plus%2Fchapter6%2F</url>
    <content type="text"><![CDATA[cctype头文件中提供判断字母,数字的方法 12345isalpha();int n;cin&gt;&gt;n; 如果输入一个单词,n值保护不变不匹配的输入将被留在输入队列中;cin对象中的一个错误标记将被设置对cin方法的调用将返回false(如果被转换成bool类型); 程序必须重置cin才能删除错误输入cin.clear(); 文本写出 包含头文件fstream 创建一个ofstream对象 同一个文件关联起来 像cout一样使用 12345#include&lt;fstream&gt;ofstream outFile;outFile.open("fsfs.txt");outFile&lt;&lt;"mskefe";outFile.close(); 文本读取1234567891011ifstream inFile,fin;double wt;inFile&gt;&gt;wt;char line[81];fin.getline(line,81);inFile.open("ste.txt");if(!inFile.is_open()) &#123;exit(EXIT_FAILURE);&#125; exit()头文件cstdlib; 确定文件循环的原因12345678910while(inFile.good())_ &#123;&#125;if(inFile.eof())cout&lt;&lt;"end of file"&lt;&lt;endl;else if(inFile.eof())cout&lt;&lt;"data mismatch"&lt;&lt;endl;else cout&lt;&lt;"unknown reason"&lt;&lt;endl;]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[05.循环和关系表达式]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%20Prime%20Plus%2Fchapter5%2F</url>
    <content type="text"><![CDATA[strcmp()比较字符串 string 对象可以直接比较 编写延时循环123456789101112131415#include&lt;ctime&gt;#include&lt;iostream&gt;int main() &#123;float secs;cin&gt;&gt;secs;clock_t delay = secs * CLOCKS_PER_SEC;//系统时间单位数cout&lt;&lt;"starting "&lt;&lt;endl;clock_t start= clock();while(clock() - start &lt; delay);cout&lt;&lt;"done"&lt;&lt;endl;&#125; 基于范围的for循环(c++11)12345678910111213double prices[5] = &#123;4.99,10.99,6.87,7.99,8.59&#125;;for(double x: prices)cout&lt;&lt;x&lt;&lt;std::endl;修改for(double &amp;x;prices)x = x * 0.8;cin.get(ch); 不像cin&gt;&gt;ch;其不会忽略空格 cin.fail()结尾eof()测试]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[04.复合类型]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%20Prime%20Plus%2Fchapter4%2F</url>
    <content type="text"><![CDATA[字符常量（使用单引号）和字符串常量（使用双引号）不能互换字符常量是字符串编码的简写表示，字符串常量表示的是字符串所在的内存地址 sizeof可以计算出整个数组的长度 strlen()返回的是存储在数组内字符串的长度（不包含空字符）cin使用空白（空格，制表符和换行符）来确定字符串的结束位置。getline和get读取一行输入直到达到换行符，getline会丢弃换行符用空字符替换换行符，get()将换行符保留在输入序列中。cin.get(name,Arsize);cin.get();和cin.get(name,Arsize).get()相同cin&gt;&gt;year;会将换行符留在输入序列cin.get();无参数方法读取下一个字符c语言中strcpy()将字符串复制到字符数组中，strcat(）将字符串附加到字符串末尾strcpy(to,from);strcat(to,from);strncpy()第三个参数指出最大长度 strlen(char) 接受一个c-风格的字符串为参数string st1 = “1231”;st1.size();cin对string的实现是通过友元函数其他形式的字符串字面值 wchar_t title[] = L”1231231”;char16_t name[] = u”123131”;char32_t car[] = U”ewrq”;原始字符串rawcout&lt;&lt;R&quot;(&quot;21132133 \n&quot;)&quot;&lt;&lt;&#39;\n&#39;;定界符为左右括号,R”+“则使用+(和)+*来标识原始字符串结尾 c++声明结构体可以省略struct共用体是一种数据格式，它能够存储不同的数据类型，但只能同时存储期中的一种类型，其长度为最大成员的长度.共用体常用于操作系统数据结构或硬件数据结构枚举 指针和自由存储空间指针用于存储值的地址,指针名表示的是地址.*运算符被称为间接值,或解除引用运算符.12long * fellow;*fellow = 234234;///place a value in never-never land new12int * ps = new int [10];delete [] ps; 使用new为一个实体分配内存,则应使用delete来释放数组的地址123short tell[10];cout&lt;&lt;tell&lt;&lt;endl;display &amp; tell[0];cout&lt;&lt;&amp;tell&lt;&lt;endl;\\display address of whole array 在编译时给数组分配内存被称为静态联编.在程序运行时创建数组,称为动态联编.如果结构标识符是结构名,则使用句点句点运算符;如果标识符是指向结构的指针,则使用箭头运算符.1234inflatable * ps = new inflatable;ps-&gt;name;(*ps).name; 处理大型字符串12345678910char * getname() &#123;char temp[80];cout&lt;&lt;&quot;enter name&quot;&lt;&lt;endl;cin&gt;&gt;temp;char * pn = new char[strlen(temp) + 1];strcpy(pn,temp);return pn;&#125; 自动存储,静态存储和动态存储 1.自动存储在函数内部定义的常规变量,在函数调用时产生在结束时自动释放.存储在栈中,后进先出;2.静态存储使变量表态的方式: 在函数外面声明 使用关键字static; 动态存储 数组的替代品 vector 123#include&lt;vector&gt;vector&lt;int&gt; vi;vector&lt;int&gt; vi(10); array```c++include using namespace std;array ai = {1,2,3,4,5};array a2;a2 = ai; //可以直接复制指针真正的用武之地在于，在运行阶段分配命名的内存以存储值]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[03.处理数据]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%20Prime%20Plus%2Fchapter3%2F</url>
    <content type="text"><![CDATA[头文件climits提供查看数据类型长度的常量 12cout&lt;&lt;hex;//16进制显示cout&lt;&lt;oct;//8进制显示 C++11使用大括号初始化方式123int test = &#123;12&#125;;int test1 = &#123;&#125;; test1 为 0; bool类型非0true将0解释为falseconst 修饰声明时必须直接赋值严格的类型转换static_cast&lt;typename&gt; (value)auto 自动确定类型在stl中特别有用 int类型的变量是计算机处理起来效率最高的长度0x开头的为16进制数0开头的为8进制数 用大括号初始化的变量不允许范围缩小的初始化如123456int x = 55;char c = &#123;x&#125; //not allow(int) c; //c风格强制转换int(c); //c++风格]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>climits</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gcc命令]]></title>
    <url>%2F2018%2F09%2F11%2FlinuxC%2Fgcc%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[gcc(选项)(参数)选项-o：指定生成的输出文件；-E：仅执行编译预处理； 头文件包含 宏展开-S：将C代码转换为汇编代码；-wall：显示警告信息；-c：仅执行编译操作，不进行连接操作。-l 链接所需要的库宏可以用来定义常量使用频率比较高的常量,简单的表达式可以定义成宏&lt;&lt;深入理解计算机系统&gt;&gt;]]></content>
      <categories>
        <category>linuxC</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sizeof与Strlen的区别与联系]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2FSizeof%E4%B8%8EStrlen%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[一、sizeofsizeof(…)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：数组——编译时分配的数组空间大小；指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；类型——该类型所占的空间大小；对象——对象的实际占用空间大小；函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。 二、strlenstrlen(…)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。 三、举例：eg1、1234char arr[10] = "What?";int len_one = strlen(arr);int len_two = sizeof(arr); cout &lt;&lt; len_one &lt;&lt; " and " &lt;&lt; len_two &lt;&lt; endl; 输出结果为：5 and 10点评：sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据。strlen只关心存储的数据内容，不关心空间的大小和类型。 eg2、12345char * parr = new char[10];int len_one = strlen(parr);int len_two = sizeof(parr);int len_three = sizeof(*parr);cout &lt;&lt; len_one &lt;&lt; " and " &lt;&lt; len_two &lt;&lt; " and " &lt;&lt; len_three &lt;&lt; endl; 输出结果：23 and 4 and 1点评：第一个输出结果23实际上每次运行可能不一样，这取决于parr里面存了什么（从parr[0]开始知道遇到第一个NULL结束）；第二个结果实际上本意是想计算parr所指向的动态内存空间的大小，但是事与愿违，sizeof认为parr是个字符指针，因此返回的是该指针所占的空间（指针的存储用的是长整型，所以为4）;第三个结果，由于*parr所代表的是parr所指的地址空间存放的字符，所以长度为1。 四、参考资料：Sizeof与Strlen的区别与联系(转） 1.sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。 2.sizeof是算符，strlen是函数。 3.sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以’’\0’’结尾的。sizeof还可以用函数做参数，比如：12short f(); printf("%d\n", sizeof(f())); 输出的结果是sizeof(short)，即2。 4.数组做sizeof的参数不退化，传递给strlen就退化为指针了。 5.大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因123char str[20]="0123456789"; int a=strlen(str); //a=10; int b=sizeof(str); //而b=20; 6.strlen的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存的大小。 7.sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。 8.当适用了于一个结构类型时或变量， sizeof 返回实际的大小，当适用一静态地空间数组， sizeof 归还全部数组的尺寸。sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 9.数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，如：12fun(char [8]) fun(char []) 都等价于 fun(char *)在C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小如果想在函数内知道数组的大小， 需要这样做：进入函数后用memcpy拷贝出来，长度由另一个形参传进去123456fun(unsiged char *p1, int len) &#123; unsigned char* buf = new unsigned char[len+1] memcpy(buf, p1, len); &#125; 我们能常在用到 sizeof 和 strlen 的时候，通常是计算字符串数组的长度 看了上面的详细解释，发现两者的使用还是有区别的，从这个例子可以看得很清楚： char str[20]=&quot;0123456789&quot;; int a=strlen(str); //a=10; &gt;&gt;&gt;&gt; strlen 计算字符串的长度，以结束符 0x00 为字符串结束。 int b=sizeof(str); //而b=20; &gt;&gt;&gt;&gt; sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。 上面是对静态数组处理的结果，如果是对指针，结果就不一样了 char* ss = “0123456789”; sizeof(ss) 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是 长整型的，所以是4 sizeof(ss) 结果 1 ＝＝＝》ss是第一个字符 其实就是获得了字符串的第一位’0’ 所占的内存空间，是char类 型的，占了 1 位 strlen(ss)= 10 &gt;&gt;&gt;&gt; 如果要获得这个字符串的长度，则一定要使用 strlen]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>sizeof</tag>
        <tag>strlen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struct和class的区别]]></title>
    <url>%2F2018%2F09%2F11%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2Fstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[从语法上，在C++中（只讨论C++中）。class和struct做类型定义时只有两点区别： （一）默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理； （二）成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。 除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。 不能因为学过C就总觉得连C++中struct和class都区别很大，下面列举的说明可能比较无聊，因为struct和class本来就是基本一样的东西，无需多说。但这些说明可能有助于澄清一些常见的关于struct和class的错误认识： （1）都可以有成员函数；包括各类构造函数，析构函数，重载的运算符，友元类，友元结构，友元函数，虚函数，纯虚函数，静态函数； （2）都可以有一大堆public/private/protected修饰符在里边； （3）虽然这种风格不再被提倡，但语法上二者都可以使用大括号的方式初始化：A a = {1, 2, 3};不管A是个struct还是个class，前提是这个类/结构足够简单，比如所有的成员都是public的，所有的成员都是简单类型，没有显式声明的构造函数。 （4）都可以进行复杂的继承甚至多重继承，一个struct可以继承自一个class，反之亦可；一个struct可以同时继承5个class和5个struct，虽然这样做不太好。 （5）如果说class的设计需要注意OO的原则和风格，那么没任何理由说设计struct就不需要注意。 （6）再次说明，以上所有说法都是指在C++语言中，至于在C里的情况，C里是根本没有“class”，而C的struct从根本上也只是个包装数据的语法机制。 ———————————————————————————————- 最后，作为语言的两个关键字，除去定义类型时有上述区别之外，另外还有一点点：“class”这个关键字还用于定义模板参数，就像“typename”。但关键字“struct”不用于定义模板参数。 如果没有多态和虚拟继承，在C++中，struct和class的存取效率完全相同！简单的说就是，存取class的data member和非virtual function效率和struct完全相同！不管该data member是定义在基类还是派生类的。 如果不是为了和C兼容，C++中就不会有struct关键字。因此建议是：如果不需要与C兼容或传递参数给C程序，不要在C++中用struct。 注意class的data member在内存中的布局可不一定是data member的申明次序。C++只保证处于同一个access section的data member按照申明次序排列。 struct所体现的是一种数据结构，而class则是体现OOP思想中的”封装”的特性~~~ 还有一个区别：struct可以用{}赋初值，而class不行 比如声明如下： 123456 struct abc&#123; int m1; float m2; bool m3; &#125; 可以这么构造对象： abc abcInstance{1, 1.0f, false }; struct：属性 class：属性+行为 注意：在VC6里，class可以与模板关键字typename互换，但是struct好像就不可以，编译好像通不过。对这个问题，我专门查了一些资料，发现网上确实有说 struct不能用于模板关键字而class可以，这似乎应该是他们的一个不同了。然而，我又看了一下 《深度探索C++对象模型》，在书的前几章（好像就是第一章）Lippman说：本来他的编译器是不支持将struct作为模板关键字的，但后来改变了，也就是说struct 和class除了默认的访问属性外，其他场合下真正的完全一样了。对此，我认为这个按理说是这样的，但不同的编译器可能会有自己的处理，就像VC6那样。 class中有方法, struct中没有. class是一个扩展的struct array(类型一样)-&gt;struct(类型可以不一致)-&gt;class(添加方法) 虽然两者都可以捆绑行为。 但是，理解不一样。 struct，就是对程序员全局可见的数据与方法。简化数据逻辑结构的设计。可以说是一种自定义的数据结构。 而class，则是将数据与方法封装，即让行为与数据一致。则是一种编程方法。即客观世界在代码世界中的体现。体现的是一种编程思想。 在C里面：struct不能包含函数，而class可以。 在C++里面：都可以有函数，默认情况下struct中变量是public,而class中是private 有一点不明白,class支持的继承和多态,struct也支持?? class在赋值运算符右边出现需要有定义的拷贝构造函数,而struct是默认的位拷贝. 但是一般从兼容C的角度考虑，struct里面只包含数据成员而不包含成员函数，这只是一个编程习惯问题。]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>struct</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows 10 file explorer keeps on searching and stating "working on it"]]></title>
    <url>%2F2018%2F09%2F10%2Fwindows%2Fproblems%2F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Windows 10 File Explorer keeps on searching and stating “working on it”Hi, As per the description, I understand that in Windows 10 whenever you open the File Explorer it start going into search mode and keep saying “Working On it”. I can imagine the inconvenience you are experiencing and will certainly help you in the right direction to fix the issue. This issue can be caused due to any of the following issues: You may be using an outdated or corrupted video driver. System files on your PC may be corrupt or mismatched with other files. You may have a Virus or Malware infection on your PC. Please follow method mentioned below to check if its helps. Method 1: Update your current video driver Downloading and installing the latest video driver can solve many of these issues. You can do this from using Windows Update or by visiting your system manufacturer’s website or by contacting them directly. For more information on updating your drivers, see the following content on the Microsoft website: https://support.microsoft.com/en-us/instantanswers/ad5a063e-5f57-c715-2566-b983195752c1/update-drivers-in-windows-10 Method 2: Run System File Checker (SFC) to check your files Use System File Checker to scan your PC for missing or corrupt files. To do this, follow these steps: Click Start, and then type cmd in the Search box. In the results area, right-click cmd.exe, and then click Run as administrator. You may be prompted to type the password for an administrator account. Click Continue if you are the administrator or type the administrator password and then, click Continue. At the command prompt, type Sfc /scannow and then press ENTER. The scan may take some time, so be patient. Windows will repair any corrupted or missing files that are found. If information from the installation CD is needed to repair the problem, you may be prompted to insert your Windows CD. For more information about System File Checker (SFC) see the following KB article on the Microsoft website: https://support.microsoft.com/en-us/kb/929833 Method 3: Test for picture files that may contain corruption Corrupt images can sometimes issues with Windows Explorer. If Windows Explorer stops working while working with pictures or browsing folders that contain pictures, there may be corruption is one or more picture files. To test for this issue, follow the steps below: Click Start and click Computer Click Organize and select Folder and search options from the dropdown On the Folder Options window, click the View tab Place a check in the option to always show Icons, never thumbnail Remove the check for the option to Display file icon on thumbnails Click OK to close the Folder Options window Now, go to any folders that contain Pictures or Videos and see if you can reproduce the issue. If Windows Explorer does stop working, the folder that you were viewing possibly contains one or more pictures files that are corrupt or contain corrupted thumbnail data. Note: After adjusting the options to Display file icon on thumbnails, and Always show Icons, never thumbnail, files no longer display thumbnails so pictures and other files will display as the default icon for their file types. If you can reproduce the error with these options set, the issue is not with pictures or videos and you should return the Folder options to their original settings. Hope this information helpful, if the issue persist please write us back with the information in brief so that we can assist you further. 原文链接]]></content>
      <categories>
        <category>windows</category>
        <category>problems</category>
      </categories>
      <tags>
        <tag>problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05小幅改动]]></title>
    <url>%2F2018%2F09%2F09%2FVim%2F05%E5%B0%8F%E5%B9%85%E5%8F%91%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[5.1 操作符命令和位移 dw命令(delete word):删除一个word,w可以看作一个word,也可以看作右移了一个word. Keyboard not found … press F1 to continue. d4w命令:删除四个word,4w看作一次右移4个word. d2e命令:删除2个word,光标移动到第二个word的尾部. d$命令:删除光标到行尾. 5.2 改变文本 常用命令 cw命令(change word):改变命令,与d命令类似,执行完成后会进入Insert模式,意为改变一个word. cc命令:改变整行,保持原有的缩进. c$命令:删除到行尾的内部,等于d$a. 快捷命令 x = dl X = dh D = d$ C = c$ s = cl S = cc 命令记数放在哪里? 3dw d3w 3d2w 这些有什么区别呢??? 第一个数字是计数命令代表命令的重复次数,第二个数字是位移命令代表作用的范围. 替换单个字符 r命令(replace):替换单个字符,你也可以使用s或cl命令来完成相同的功能,但使用r命令不需要再键回到Normal模式. Kexxxxxd not found … press F1 to continue. 备注:r命令同样可以使用数字计数,如5rx等操作. 5.3 重复改动.命令:重复上一次做出的修改. 如删除HTML语言: To generate a table of contents. f&lt; df&gt; f&lt; df&gt; … .命令重复的是修改命令,而不是被改动的内容 xyz 1 xyz 2 cwxyz 使用.命令来替换 five five five five five5.4 Visual模式 选择文本范围 v命令:进入visual模式,移动光标覆盖你想操纵的文本范围,最后键入操作符. This is an examination sample of visual mode. This is an example of visual mode. 选择多行 vjj命令:选择3行,可以选择多行. 选择文本块 CTRL-v:进入visual块模式,以文本块为对象进行操作,常常用来编辑表格. 如欲删除Q2列,则可以把光标置于Q2的Q上后wd就可以删除Q2列了,块区域范围的调整. name Q1 Q2 Q3 ab 12 23 34 ab 12 23 34 ab 12 23 34 ab 12 23 34 文本块操作 o命令(other end):会让光标置于被选中的文本的另一端,对角的位置上去,可以通过光标移动进行块的所选范围进行移动. O命令:同一行左右两个角之间进行移动. 备注: 在visual块模式下,进行操作. 5.5 移动文本 p命令(put):以前通过用d或x进行删除的文本都可以用p命令来进行读取. 如:dd删除行后,将光标移动到想放入的地方然后p命令进行放入. a line a line a line 如:移动某个单词,dw删除后,将光标移动到想放入的地方然后使用p命令进入放入. a a ne line line a li 如:交换两个字符,x删除字符后,用p命令取回. teh the P命令:把取回的内容放在光标之前. 备注:可以与计数命令一起使用,如dd删除行之后,3p会将删除的行取回三次放在当前位置. a line a line a line a line a line a line a line a line a line a line a line a line a line a line a line 5.6 复制文本 y命令(yanking):将文本复制到一个寄存器中,用p命令取回. 备注:如d命令类似: yw:复制一个word y2w:复制两个word yy:复制一整行 y$:复制光标到行尾,D或d$(删除光标到行尾的内容)类似. Y:与yy类似,复制一整行.规律是存在例外的. 使用剪贴板 “*yy命令:将一行内容复制到剪贴板中. “*p命令:把剪贴板中的内容复制出来. 备注:只适用于gvim,实质上是将内容复制到名为*的寄存器中.””5.7 文本对象daw命令(delete a word):删除一个单词,光标位于单词的中间而你要删除这个单词时使用的. This is an example. diw命令(delete inner word):删除一个单词,不删除之后的空格符. cas命令(change a sentence):要修改一整个句子,删除之后的空格符,由Normal模式转到Insert模式. cis命令(change inner sentence):要修改一整个句子,不会删除之后的空格符. This is an example. This is an example. This is an example. This is an example. 5.8 替换模式 Normal -&gt; i a -&gt; Insert -&gt; Esc -&gt; Normal -&gt; V -&gt; Visual -&gt; R -&gt; Replace Normal R命令:键入的字符都会替换当前光标下的字符,键入结束该模式. This is a text. 备注: 键可以在Insert模式与Replace模式之间进行切换.键可以将原来的字符进行修复. 5.9 总结 操作命令,位移命令和文本对象可以让你在使用这些命令时任意组合,如使用操作符命令N配上位移命令M来构成一个NM命令. 操作命令: d c y p 位移命令: w 0 ^ $ 文本对象: aw as iw is 删除文本常用的方法: x 删除当前光标下的字符,dl功能是一样的. X 删除当前光标之前的字符,dh功能是一样的. D 删除当前光标到行尾的内容,d$功能是一样的. dw 删除自当前光标到下一个word的开头. db 删除自当前光标到前一个word的开始. diw 删除当前光标所在的word(不包括空白字符) daw 删除当前光标所在的word(包括空白字符) dG 删除当前行到文件尾的内容. dgg 删除当前行到文件头的内容. 更改文本常用的方法: 如果用c命令代替d这些命令就都变成更改命令,如此类推. ~ 改变当前光标下字符的大小写,并将光标移动下一个字符. THis is a examPLe. I 将光标置于当前行第一个非空白字符处并进入Insert模式. A 当光标置于当前行尾并进入Insert模式.]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const和#define的区别]]></title>
    <url>%2F2018%2F09%2F06%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2Fconst%E5%92%8Cdefine%2F</url>
    <content type="text"><![CDATA[1、两者的区别（C语言）(1) 编译器处理方式不同 #define宏是在预处理阶段展开。 const常量是编译运行阶段使用。(2) 类型和安全检查不同 #define宏没有类型，不做任何类型检查，仅仅是展开。 const常量有具体的类型，在编译阶段会执行类型检查。(3) 存储方式不同 #define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。） const常量会在内存中分配(可以是堆中也可以是栈中)。(4) const 可以节省空间，避免不必要的内存分配。 例如： define NUM 3.14159 //常量宏const doulbe Num = 3.14159; //此时并未将Pi放入ROM中 ……double i = Num; //此时为Pi分配内存，以后不再分配！double I= NUM; //编译期间进行宏替换，分配内存double j = Num; //没有内存分配double J = NUM; //再进行宏替换，又一次分配内存！const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。(6) 宏替换只作替换，不做计算，不做表达式求解;宏预编译时就替换了，程序运行时，并不分配内存。 2、const 和 #define的比较（C++）在C++ 中，可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：（1） const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。（2） 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。 l 【规则5-2-1】在C++ 程序中只使用const常量而不使用宏常量，即const常量完全取代宏常量。5.3 常量定义规则l 【规则5-3-1】需要对外公开的常量放在头文件中，不需要对外公开的常量放在定义文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中。l 【规则5-3-2】如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>const</tag>
        <tag>define</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Static和const的用途区别]]></title>
    <url>%2F2018%2F09%2F06%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2FStatic%E5%92%8Cconst%2F</url>
    <content type="text"><![CDATA[static隐藏未加static前缀的全局变量和函数都有全局可见性.加了static会对其他的源文件隐藏 保持内容的持久存储在静态数据区的变量会在程序刚开始运行时就完成初始化,也是唯一的一次初始化.static可以控制变量的可见范围,说到底还是用来隐藏的. 默认初始化为0 区别对于C/C++语言来讲,const就是只读的意思,只在声明中使用;static一般有2个作用,规定作用域和存储方式.对于局部变量,static规定其为静态存储方式,每次调用的初始值为上一次调用的值,调用结束后存储空间不释放;对于全局变量,如果以文件划分作用域的话,此变量只在当前文件可见;对于static函数也是在当前模块内函数可见.static const 应该就是上面两者的合集.下面分别说明:全局:const,只读的全局变量,其值不可修改.static,规定此全局变量只在当前模块(文件)中可见.static const,既是只读的,又是只在当前模块中可见的.文件:文件指针可当作一个变量来看,与上面所说类似.函数:const,返回只读变量的函数.static,规定此函数只在当前模块可见.]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>static</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell利器Zsh]]></title>
    <url>%2F2018%2F09%2F05%2Flinux%2Fshell%2Fzsh%2F</url>
    <content type="text"><![CDATA[zsh_github 安装zsh1sudo apt-gt install -y zsh 设置终端的 shell 环境默认为 zsh，输入以下命令（需要重启）1chsh -s `which zsh` 安装antigen管理功能 12345678910curl -L git.io/antigen &gt; antigen.zsh# 修改配置 ~/.zshrc（如果切换帐号后无法使用 zsh 则把该用户的配置文件再配一遍）curl -L https://raw.githubusercontent.com/skywind3000/vim/master/etc/zshrc.zsh &gt; ~/.zshrc# 修改主题, 参考：https://github.com/robbyrussell/oh-my-zsh/wiki/themes# 如果需要主题一直生效需要添加到 ~/.zshrc 中antigen theme ys# 配置修改完重新执行 zsh 如果出现警告 zsh compinit:insecure directories,run compaudit for list1chmod -R 755 ~/.antigen 安装autojump autojump 是一个命令行工具，它允许你可以直接跳转到你喜爱的目录，而不受当前所在目录的限制。意思就是可以让你更快地切换目录，而不用频繁地使用 cd/tab 等命令。 1sudo apt-get install autojump 如果运行出错 在 ~/.zshrc 中添加 antigen bundle autojump]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04移动]]></title>
    <url>%2F2018%2F08%2F30%2FVim%2F04%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[以word为单位的移动w命令(word):光标向前移动一个word,光标会移动到下一个word的首字符上,同时可以加计数前缀,如3w,将光标向前移动3个word. b命令(backward):光标向后移动到前一个word的首字符上,同时可以加计数前缀,如3b,将光标向后移动3个word. e命令(end of word):光标向前移动到下一个word的最后一个字符上. ge命令:光标向后移动到前一个word的最后一个字符上. This is a line with example text. This is-a line,with special/separated/words(and some more). 有一些被认为是non-word的特殊字符,比如”.”、”-“、”/“、”(“. 大写命令：W B E gE. 备注：混合使用这几种不同的大小写命令，可以让你更快的在文本前后移动。 移动到行首或行尾$命令:光标移动当前行行尾,与键作用相同,可以接受计数命令,如2$表示下一行的行尾. ^命令:光标移动到当前行第一个非空白的字符上. 0命令:光标移动到当前行第一个字符上,与键作用相同. This is a line with example text. 移动到指定的字符上f命令(find):向后单字符搜索命令,如fx在当前行查找下一个字符x,同时也可以使用计数命令,如3fx. F命令:向左单字符搜索命令. t命令(to):向右单字符搜索命令,只不过不是把光标停留在被搜索字符上,而是它之前的一个字符上. T命令:向左单字符搜索命令. This is-a line,with special/separated/words(and some more). 备注: 可以同时与;键来重复使用这些命令. 以匹配一个括号为目的的移动%命令:光标跳转到与当前光标相匹配的括号上.括号:() [] {} if (a==(b*c)/d) 如果当前光标没有停留在一个可用的括号字符上,会向前找到第一个括号,与之匹配. 移动到指定行G命令(go):光标定位到计数指定的行,如果没有指定计数,光标会定位到最后一行. gg命令:定位到第一行与1G的效果相同. %命令:光标定位到计数指定的行上,如50%,90%等. 告诉你当前的位置CTRL-g命令:显示信息行,如行号,总行数,以及当前行在文件中的百分比. set number命令:显示行号. set nonumber命令:关闭显示行号. set ruler命令:显示当前光标的位置. set noruler命令:关闭显示当前光标的位置. 滚屏CTRL-u命令(up): 文本向下滚动半屏,窗口向上滚动半屏. CTRL-d命令(down): 文本向上滚动半屏,窗口向下滚动半屏. CTRL-e命令(extra): 文本向上滚动一行,窗口向下滚动一行. CTRL-y命令: 本文向上滚动一行,窗口向下滚动一行. CTRL-f命令(forward): 本文向下滚动一屏,窗口向上滚动一屏. CTRL-b命令(backward): 本文向上滚动一屏,窗口向下滚动一屏. zz命令:当前行置于正中央. zt命令(top):当前行置于屏幕顶端. zb命令(bottom):当前行置于屏幕底端. 简单搜索1.常用命令 /string命令:向下搜索一个字符串. ?string命令:向上搜索一个字符串. n命令:下一次搜索,可以加计数命令. N命令:前一次搜索,可以加计数命令. 备注: . ^ ~ $有特殊的意义,需要一个反斜杠,. 2.大小定问题 :set ignorecase: 开启搜索忽略大小写. :set noignorecase: 闭关搜索忽略大小写. 3.命令历史记录 按下/来搜索,先别按回车键,上箭头键会显示你上一次进行搜索的命令. 4.在文本中查找下一个word *命令:向下搜索下一个当前光标所在的单词. #命令:向上搜索上一个当前光标所在的单词. 备注:\:完整的单词搜索. 5.查找整个word >:单词结束符. \&lt;:单词开始符. \:完整的单词搜索. 6.高亮显示搜索结果 :set hlsearch(highlight search):开启高亮显示搜索结果. :set nohlsearch(highlight search):关闭高亮显示搜索结果. :nohlsearch :去掉当前的高亮显示. 7.调整搜索 :set incsearch :使用键入目标字符串同时就开始搜索. :set noincsearch :关闭使用键入目标字符串同时就开始搜索. :set wrapscan :到达文件的尾部会向另一个方向进行搜索. :set nowrapscan :关闭到达文件的尾部会向另一个方向进行搜索. 简单的搜索模式Vim使用正则表达式进行搜索的,功能十分的强大. 一行的开关与结尾 ^字符:匹配一行的开头. $字符:匹配一行的结尾. the solder holding one of the chips melted and the /^the / the /the$ 匹配任何一个字符 .字符:匹配任何一个字符. We use a computer that became the cumin winter. com cam cum /c.m 备注:如果是特殊字符,需要反斜杠.如ter. 使用标记 常用命令 ``命令:当使用G命令进行跳转时,回到原来的跳转位置. 跳转:包括G /与n等搜索命令,但不包括fx或tx,以及word为单位的移动命令,或者光标的移动均不包括. CTRL-o命令(old):跳转到前一个光标停留的位置. CTRL-i命令:跳转到下一个光标停留的位置,键作用功能相同. jumps命令:显示你曾经跳转过的位置. 具体的命令的标记命令 m命令(mark):定义一个标记,如ms,名为s(start)的标记. ‘命令:跳转到某个名字的标记.如’s. :marks :查看所有的标记. define …….特殊的标记: ` 进行此次跳转之前的跳点. ‘’ 到上次跳转的位置. [ 最后一次修改的起始位置. ] 最后一次修改的结束位置.]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03帮助]]></title>
    <url>%2F2018%2F08%2F30%2FVim%2F03%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[打开帮助命令: :help 或 打开用户手册的目录: :help usr_toc.txt 常用的帮助命令的使用: (1) 查看关于某个特殊主题的帮助 :help {subject} :help x 关于x命令的帮助 :help deleting 关于如何删除的内容 :help index 所有Vim命令的索引 (2) 关于某个控制字符的帮助 CTRL - :help CTRL-A (3) 查找其它模式下的帮助 :help i_CTRL-H insert模式 :help v_CTRL-A Visual模式 :help c_CTRL-B Command模式 (4) 关于命令行选项 -subject :help -R vim -R file.txt 以只读的形式打开文档 (5) 关于命令选项的说明 ‘showmode’ :help ‘showmode’ (6) 特殊键用尖括号中的简单的描述性名字表示 :help i_&lt;UP&gt; (7) 错误ID号的作为帮助的主题 :help E37 (8) 关于函数”subject”的帮助 :help add() //Vimscript 中使用 (9) 关于编译时特性”+subject”的帮助 :help +visual(10) 查找一个以”pattern”开始的帮助标记.重复按查看其它匹配的帮助标记. :help pattern (11) 同时列出匹配”pattern”的所有可能的帮助主题. :help pattern (12) 在所有帮助文件中搜索全部文本查找指定的pattern. :helpgrep pattern 下一个匹配 :cn 前一个匹配 :cprev :cN 第一个/最后一个匹配项 :cfirst :clast 打开/关闭快速修改窗口 :copen 直接回车进行进入编辑 :cclose 关闭快速修改窗口]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02小试牛刀]]></title>
    <url>%2F2018%2F08%2F30%2FVim%2F02%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80%2F</url>
    <content type="text"><![CDATA[模式 Normal模式与Insert模式 Normal模式:键入的每个字符都被视为一个命令. Insert模式:键入的字符作为实际要输入的文本内容.使用i命令(insert). A man and woman are in a computer programming lecture. The man touches the woman’s breasts. “Hey” she says. “Those are private!” The man says, “But we are in the same class!” 现在是什么模式? 打开显示模式: :set showmode 关闭显示模式: :set noshowmode 模式之灾 使用Vim经常忘记自己身在何种模式,或者不经意敲了哪个字符就切换到别的模式去了.按再次,如果Vim以一声蜂鸣来回答你,那说明你已经是&gt;在Normal模式了. 移动光标 移动光标命令: 12345 k 上h 左 l 右 j 下 也可以用箭头键来移动光标,会大大的降低效率.想象一下要是你在一小时内这样的做一百次会占用你多少时间?在编辑器中移动光标是十分常用的操作,这些字符在键盘上都分布在你右手周围,精心挑选的. 删除字符 删除一个字符命令:x 这是在追忆古老的打字机的时代,在打字机上删除字符就是用xxxx来覆盖它的. 删除一行命令:dd 删除后下面的行会移上来填补空缺. 删除换行符命令:J 把两行合并为一行,也就是说两行之间的换行符被删除了. 撤消和重做 撤消命令:u (undo) 如果误删了过多的内容,命令u更简便,它可以撤消上一次的操作. 撤消命令还有另一种形式,U命令,它一次撤消对一行的全部操作,即打开文件时的状态. 重做命令:ctrl + r(repeat) 如果你撤消了多次,可以用ctrl+r来反转撤消的动作.换名话说它是对撤消的撤消. 其它编辑命令 追加 (1) 光标之后插入文本命令:a (append) (2) 另起一行命令:o/O o命令可以在当前行的下面另起一行,并使当前模式转为Insert模式,而大写的O,是在当前行的上面另起一行. 使用命令计数 指定的数字要紧挨在它所要修饰的命令前面. 假设你要向上移动9行,这可以用”kkkkkkkkk”或”9k”来完成. 行尾追加三个感叹号,可以用a!!!另一个办法是3a!命令. 删除3个字符可以用3x. 退出 (1) 放弃编辑命令:q! (quit) 有时你会在做了一连串修改之后突然意识到最好是放弃所有的修改重新来过,这个命令由3个部分组成:冒号,用以进入冒号命令行模式;q命令,告诉 编辑器退出;最后是强制命令执行的修饰符(!) (2) 放弃所有修改后还想以该文件的初始内容作为开始继续编辑:e! (edit) (3) 保存并退出命令:ZZ 或 :wq (write quit)]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[make和makefile]]></title>
    <url>%2F2018%2F08%2F27%2FlinuxC%2Fmake%E5%92%8Cmakefile%2F</url>
    <content type="text"><![CDATA[命令选项和参数-k 在发现错误时仍继续执行,而不是在检测到第一个错误时就停下.-n 输出要执行的操作而不执行-f 告诉make命令将那个文件作为makefile的文件 三要素目标依赖关系1234myapp: main.o 3.o 2.omain.o: main.c2.o: 2.c3.o: a.c 规则12345678myapp: main.o 3.o 2.o gcc -o myapp main.o 3.o 2.omain.o: main.c gcc -c main.c2.o: 2.c gcc -c 2.c3.o: 3.c gcc -c 3.c 注释号开头宏1234567891011121314151617181920212223//定义MACRONAME=value//使用$(MACRONAME)例CC = gccINCLUDE = .CFLAGS = -g -Wall -ansiCFLAGS = -O -Wall -ansimyapp:main.o 2.o 3.o $(CC) -o myapp main.o 2.o 3.omain.o:main.c $(CC) -I$(INCLUDE) $(CFLAGS) -c main.c2.o:2.c $(CC) -I$(INCLUDE) $(CFLAGS) -c 2.c3.o:3.c $(CC) -I$(INCLUDE) $(CFLAGS) -c 3.c 内置宏$? 当前目标所依赖的文件列表中比当前目标文件还要新的文件$@ 当前目标的名字$&lt; 当前依赖文件的名字$* 不包括后缀名的当前依赖文件的名字 命令之前的特殊字符- 告诉命令忽略所有错误@ 不要将该命令显示在标准输出上 多个目标]]></content>
      <categories>
        <category>linuxC</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2F2018%2F08%2F27%2FVim%2F01.%E5%89%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言编辑器的三个层次 Edit Notepad Gedit,垄断着你的大脑,并且已经根深蒂固,挥之不去,那么VIM的使用不是提高你的工作效率,而是降低,一场噩梦. Editplus Notepad++ Ultraedit,是Windows上目前比较流行的3种文本编辑器,都支持多种编程语言,并且都可以进行语法着色,对于各个代码的编写者使用起来也是非常便利的. 如果是嵌入式方面的开发或编程,或者是在Linux服务器上写服务,基本上Windows所支持的编辑器都不能使用了.江湖传言:世界上的程序员分三种:一种使用Emacs,一种使用VIM,剩下就是使用其它的. Emacs是神的编辑器,Vim是编辑器之神,而我喜欢把Vim称为上古神器. VIM是一种技能而不是一种知识,不要试图从本课程中获取任何什么知识. 在学习VIM时,不用贪图一下全部掌握众多的精致的技巧,而是最好看一条技巧后,马上在编辑器上进行操作,这样可以建立一种自然的反射,不是由头脑来搜索应 该使用哪个操作技巧. Vim的目的只有一个,节省敲击键盘的次数,最好不用鼠标. 1.3 VIM安装 Linux a) Ubuntu Debian1sudo apt install vim b) Centos RedHat Fedora1sudo yum install vim Windows Gvim 8.0.281.0 1.4 VIM卸载 Linux a) Ubuntu Debian1sudo apt remove vim b) Centos RedHat Fedora1sudo yum remove vim Windows 控制面板-程序-更改或删除,软件管理软件. 1.5 首次运行Vim Linux vim filename Windows Gvim gvim filename 1.6 Vim文档帮助手册 用户手册面向问题,可以像读一本书一样从头到尾的进行学习. 用户手册包含了VIM方方面面的细节. 中文帮助的手册的安装 a) :version b) Vim documentation chinese version下载 123wget https://nchc.dl.sourceforge.net/project/vimcdoc/vimcdoc/vimcdoc-1.9.0.tar.gztar -xzvf vimdoc-1.9.0.tar.gz./vimcdoc.sh -i 中英文帮助切换 12:set helplang=en:set helplang=cn 帮助主题(超级链接)之间的跳转: a) :help 打开帮助手册 b) ctrl + ] 跳转到当前光标所在单词的对应的主题. c) ctrl + o 回到前一个主题.]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存泄漏]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是内存泄漏(Memory Leak)?简单地说就是申请了一块内存空间，使用完毕后没有释放掉。它的一般表现方式是程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，且没有任何一个指针指向它，那么这块内存就泄露了。 如何检测内存泄露第一：良好的编码习惯，尽量在涉及内存的程序段，检测出内存泄露。当程式稳定之后，在来检测内存泄露时，无疑增加了排除的困难和复杂度。使用了内存分配的函数，一旦使用完毕,要记得要使用其相应的函数释放掉。第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。 第三：Boost 中的smart pointer 第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky等等]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬空指针和野指针]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2F%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[A dangling pointer is a pointer that used to point to a valid address but now no longer does. This is usually due to that memory location being freed up and no longer available. There is nothing wrong with having a dangling pointer unless you try to access the memory location pointed at by that pointer. It is always best practise not to have or leave dangling pointers.空悬指针是这样一种指针：它曾经指向一个有效地址，但是现在不再指向有效地址（个人添加，其实就是原来的那块地址不能通过这个指针区访问了）。这通常是因为指针所指的内存单位被释放了并且不再有效了。空悬指针存在并没有什么问题，除非你尝试通过这个指针访问指向的地址空间。不遗留任何悬空指针总是最好的实践方式。A wild pointer is a pointer that has not been correctly initialised and therefore points to some random piece of memory. It is a serious error to have wild pointers.而野指针是这样一种指针：它没有被正确的初始化于是指向一个随机的内存地址。存在野指针是一个严重的错误]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[十大经典排序算法]]></content>
      <categories>
        <category>C++面试</category>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在一个已经 “exit” 的docker容器中修改配置文件]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2F%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%BB%8F%20%E2%80%9Cexit%E2%80%9D%20%E7%9A%84docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1、运行命令 docker inspect [CONTAINER ID] ,可以找到如下的内容 复制 MergedDir 中的路径，切换到对应的目录下，可以看到 可以惊奇地发现前者的目录文件和直接进入容器中的可以看到的目录文件是一样的，这样我们就可以在前者中，也就是在容器已经 “exit” 的情况下，修改容器中的配置文件，比如 nginx 的话，就进入到 etc/nginx/ 下边去修改那个“忘记添加分号的” nginx.conf 原文链接]]></content>
      <categories>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache2.4安装SSL证书教程]]></title>
    <url>%2F2018%2F08%2F27%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%2FApache2.4%E5%AE%89%E8%A3%85SSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[从证书提供商获取CA证书 开启Ubuntu的OpenSSL，并使Apache加载SSL模块 配置conf文件，安装CA证书 加载Apache的ReWrite模式 增加.htaccess文件，同时配置Apache2.conf使其生效 安装ssl模块 1sudo a2enmod ssl Apache加载SSL模块后，会在/etc/apache2/sites-available下生成default-ssl.conf文件，我们在终端使用sudo权限，通过vi编辑器打开 原文链接]]></content>
      <categories>
        <category>服务器配置</category>
      </categories>
      <tags>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针和引用的区别]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2F%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[空值问题 初值问题 赋值问题 重载操作符]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc和new的区别]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%E9%9D%A2%E8%AF%95%2FC%2B%2B%2Fmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[相同点：都可用于申请动态内存和释放内存 不同点：（1）操作对象有所不同。malloc与free是C++/C 语言的标准库函数，new/delete 是C++的运算符。对于非内部数据类的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。 （2）用法上也有所不同。函数malloc 的原型如下：void * malloc(size_t size); 用malloc 申请一块长度为length 的整数类型的内存，程序如下：int *p = (int *) malloc(sizeof(int) * length);我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。 malloc 返回值的类型是void *，所以在调用malloc 时要显式地进行类型转换，将void *转换成所需要的指针类型。 malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。函数free 的原型如下：void free( void * memblock );为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p 的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p 是NULL 指针，那么free对p 无论操作多少次都不会出问题。如果p 不是NULL 指针，那么free 对p连续操作两次就会导致程序运行错误。 new/delete 的使用要点：运算符new 使用起来要比函数malloc 简单得多，例如：int *p1 = (int *)malloc(sizeof(int) * length);int *p2 = new int[length];这是因为new 内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new 在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new 的语句也可以有多种形式。如果用new 创建对象数组，那么只能使用对象的无参数构造函数。例如123Obj *objects = new Obj[100]; // 创建100 个动态对象不能写成Obj *objects = new Obj[100](1); // 创建100 个动态对象的同时赋初值1 在用delete 释放对象数组时，留意不要丢了符号‘[]’。例如12delete []objects; // 正确的用法delete objects; // 错误的用法 后者相当于delete objects[0]，漏掉了另外99 个对象。 new自动计算需要分配的空间，而malloc需要手工计算字节数 new是类型安全的，而malloc不是，比如：12int* p = new float[2]; // 编译时指出错误int* p = malloc(2*sizeof(float)); // 编译时无法指出错误 new operator 由两步构成，分别是 operator new 和 construct operator new对应于malloc，但operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上。而malloc无能为力 new将调用constructor，而malloc不能；delete将调用destructor，而free不能。 malloc/free要库文件支持，new/delete则不要。 本质区别malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete 12345678910111213141516171819202122232425262728class Obj&#123;public: Obj( ) &#123; cout &lt;&lt; "Initialization" &lt;&lt; endl; &#125; ~ Obj( ) &#123; cout &lt;&lt; "Destroy" &lt;&lt; endl; &#125; void Initialize( ) &#123; cout &lt;&lt; "Initialization" &lt;&lt; endl; &#125; void Destroy( ) &#123; cout &lt;&lt; "Destroy" &lt;&lt; endl; &#125;&#125;obj;void UseMallocFree( )&#123; Obj * a = (Obj *) malloc( sizeof ( obj ) ); // allocate memory a -&gt; Initialize(); // initialization // … a -&gt; Destroy(); // deconstruction free(a); // release memory&#125;void UseNewDelete( void )&#123; Obj * a = new Obj; // … delete a; &#125; 类Obj的函数Initialize实现了构造函数的功能，函数Destroy实现了析构函数的功能。函数UseMallocFree中，由于malloc/free不能执行构造函数与析构函数，必须调用成员函数Initialize和Destroy来完成“构造”与“析构”。所以我们不要用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。 2、联系既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete、malloc/free必须配对使用。]]></content>
      <categories>
        <category>C++面试</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>malloc</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 .对象和类]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%20Prime%20Plus%2Fchapter10%2F</url>
    <content type="text"><![CDATA[类和对象初始化在C++11中，可将列表初始化语法用于类吗？可以，只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起 const函数需要一种新的语法——保证函数不会修改调用对象。C++的解决方法是将const关键字放在函数的括号后面。 this指针C++解决这种问题的方法是：使用被称为this的特殊指针。this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）。每个成员函数（包括构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。 然而，要返回的并不是this，因为this是对象的地址，而是对象本身，即this（将解除引用运算符用于指针，将得到指针指向的值）。现在，可以将*this作为调用对象的别名来完成前面的方法定义。 类作用域在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符（．）、间接成员运算符（-&gt;）或作用域解析运算符（::） 作用域为类的常量第一种方式是在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整型常量提供作用域为整个类的符号名称C++提供了另一种在类中定义常量的方式——使用关键字static： 作用域内枚举（C++11）总结面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使用数据。然后，设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称为方法）提供访问数据的唯一途径。类将数据和方法组合成一个单元，其私有性实现数据隐藏。 通常，将类声明分成两部分组成，这两部分通常保存在不同的文件中。类声明（包括由函数原型表示的方法）应放到头文件中。定义成员函数的源代码放在方法文件中。这样便将接口描述与实现细节分开了。从理论上说，只需知道公有接口就可以使用类。当然，可以查看实现方法（除非只提供了编译形式），但程序不应依赖于其实现细节，如知道某个值被存储为int。只要程序和类只通过定义接口的方法进行通信，程序员就可以随意地对任何部分做独立的改进，而不必担心这样做会导致意外的不良影响。 类是用户定义的类型，对象是类的实例。这意味着对象是这种类型的变量，例如由new按类描述分配的内存。C++试图让用户定义的类型尽可能与标准类型类似，因此可以声明对象、指向对象的指针和对象数组。可以按值传递对象、将对象作为函数返回值、将一个对象赋给同类型的另一个对象。如果提供了构造函数，则在创建对象时，可以初始化对象。如果提供了析构函数方法，则在对象消亡后，程序将执行该函数。 每个对象都存储自己的数据，而共享类方法。如果mr_object是对象名，try_me( )是成员函数，则可以使用成员运算符句点调用成员函数：mr_object.try_me( )。在OOP中，这种函数调用被称为将try_me消息发送给mr_object对象。在try_me( )方法中引用类数据成员时，将使用mr_object对象相应的数据成员。同样，函数调用i_object.try_me( )将访问i_object对象的数据成员。 如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显式地引用调用它的对象，则可以使用this指针。由于this指针被设置为调用对象的地址，因此*this是该对象的别名。 类很适合用于描述ADT。公有成员函数接口提供了ADT描述的服务，类的私有部分和类方法的代码提供了实现，这些实现对类的客户隐藏。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9. 内存模型和名称空间]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%20Prime%20Plus%2Fchapter9%2F</url>
    <content type="text"><![CDATA[存储持续性自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量。静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。它们在程序整个运行过程中都存在。C++有3种存储持续性为静态的变量。线程存储持续性（C++11）：当前，多核处理器很常见，这些CPU可同时处理多个执行任务。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。本书不探讨并行编程。动态存储持续性：用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。 作用域和链接作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。例如，函数中定义的变量可在该函数中使用，但不能在其他函数中使用；而在文件中的函数定义之前定义的变量则可在所有函数中使用。链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。C++变量的作用域有多种。作用域为局部的变量只在定义它的代码块中可用。代码块是由花括号括起的一系列语句。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用（这就是为什么这些名称是什么以及是否出现都不重要的原因）。在类中声明的成员的作用域为整个类（参见第10章）。在名称空间中声明的变量的作用域为整个名称空间（由于名称空间已经引入到C++语言中，因此全局作用域是名称空间作用域的特例）。 C++函数的作用域可以是整个类或整个名称空间（包括全局的），但不能是局部的（因为不能在代码块内定义函数，如果函数的作用域为局部，则只对它自己是可见的，因此不能被其他函数调用。这样的函数将无法运行）。 12345678 int main() &#123; int teledeli = 9; &#123; int websight = 0; //websight expires &#125; //teledeli expires&#125; 使得有两个同名的变量（一个位于外部代码块中，另一个位于内部代码块中），情况将如何呢？在这种情况下，程序执行内部代码块中的语句时，将teledeli解释为局部代码块变量。我们说，新的定义隐藏了（hide）以前的定义，新定义可见，旧定义暂时不可见。在程序离开该代码块时，原来的定义又重新可见 静态持续变量123456int global = 1000; //static duration,external linkagestatic int one_file = 50; //static duration,internal linkagevoid functl(int n) &#123; static int count = 0;//static duration ,no linkage&#125; 静态持续性,外部链接性外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块中访问）。这3种链接性都在整个程序执行期间存在，与自动变量相比，它们的寿命更长。由于静态变量的数目在程序运行期间是不变的，因此程序不需要使用特殊的装置（如栈）来管理它们。编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。 要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。 链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言都是外部的。 单定义规则.一方面，在每个使用外部变量的文件中，都必须声明它；另一方面，C++有“单定义规则”（One Definition Rule，ODR），该规则指出，变量只能有一次定义。为满足这种需求，C++提供了两种变量声明。一种是定义声明（defining declaration）或简称为定义（definition），它给变量分配存储空间；另一种是引用声明（referencing declaration）或简称为声明（declaration），它不给变量分配存储空间，因为它引用已有的变量。 引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间： 如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义（单定义规则），但在使用该变量的其他所有文件中，都必须使用关键字extern声明它： 静态持续性、内部链接性将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。在多文件程序中，内部链接性和外部链接性之间的差别很有意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变量都具有外部链接性，即可以在其他文件中使用.可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（名称空间提供了另外一种共享数据的方法）。另外，如果将作用域为整个文件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突。 静态存储持续性、无链接性将static限定符用于在代码块中定义的变量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将保持不变。（静态变量适用于再生——可以用它们将瑞士银行的秘密账号传递到下一个要去的地方）。另外，如果初始化了静态局部变量，则程序只在启动时进行一次初始化。即试图使用get(char *, int)读取空行将导致cin为false。 说明符和限定符关键字volatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化mutable。可以用它来指出，即使结构（或类）变量为const，其某个成员也可以被修改。const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。也就是说，在C++看来，全局const定义（如下述代码段所示）就像使用了static说明符一样。 函数和链接性默认情况下，函数的链接性为外部的，即可以在文件间共享。实际上，可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义的，不过这是可选的（要让程序在另一个文件中查找函数，该文件必须作为程序的组成部分被编译，或者是由链接程序搜索的库文件）。还可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字： 这意味着该函数只在这个文件中可见，还意味着可以在其他文件中定义同名的的函数。和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义，因此即使在外部定义了同名的函数，该文件仍将使用静态函数。 单定义规则也适用于非内联函数，因此对于每个非内联函数，程序只能包含一个定义。对于链接性为外部的函数来说，这意味着在多文件程序中，只能有一个文件（该文件可能是库文件，而不是您提供的）包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。 内联函数不受这项规则的约束，这允许程序员能够将内联函数的定义放在头文件中。这样，包含了头文件的每个文件都有内联函数的定义。然而，C++要求同一个函数的所有内联定义都必须相同。 C++在哪里查找函数 假设在程序的某个文件中调用一个函数，C++将到哪里去寻找该函数的定义呢？如果该文件中的函数原型指出该函数是静态的，则编译器将只在该文件中查找函数定义；否则，编译器（包括链接程序）将在所有的程序文件中查找。如果找到两个定义，编译器将发出错误消息，因为每个外部函数只能有一个定义。如果在程序文件中没有找到，编译器将在库中搜索。这意味着如果定义了一个与库函数同名的函数，编译器将使用程序员定义的版本，而不是库函数（然而，C++保留了标准库函数的名称，即程序员不应使用它们）。有些编译器-链接程序要求显式地指出要搜索哪些库。 语言链接性存储方案和动态分配由new分配的80个字节（假设float为4个字节）的内存将一直保留在内存中，直到使用delete运算符将其释放。但当包含该声明的语句块执行完毕时，p_fees指针将消失。如果希望另一个函数能够使用这80个字节中的内容，则必须将其地址传递或返回给该函数。另一方面，如果将p_fees的链接性声明为外部的，则文件中位于该声明后面的所有函数都可以使用它。另外，通过在另一个文件中使用下述声明，便可在其中使用该指针：1extern int * prss; 定位new运算符将信息放在特定的硬件地址处 名称空间名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。using声明使一个名称可用，而using编译指令使所有的名称都可用。 未命名的名称空间这就像后面跟着using编译指令一样，也就是说，在该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾。 名称空间及其前途使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。如果开发了一个函数库或类库，将其放在一个名称空间中。事实上，C++当前提倡将标准函数库放在名称空间std中，这种做法扩展到了来自C语言中的函数。例如，头文件math.h是与C语言兼容的，没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实际上，并非所有的编译器都完成了这种过渡。仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。不要在头文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理器编译指令#include之后。导入名称时，首选使用作用域解析运算符或using声明的方法。对于using声明，首选将其作用域设置为局部而不是全局。 总结C++鼓励程序员在开发程序时使用多个文件。一种有效的组织策略是，使用头文件来定义用户类型，为操纵用户类型的函数提供函数原型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后，将main( )和其他使用这些函数的函数放在第三个文件中。 C++的存储方案决定了变量保留在内存中的时间（储存持续性）以及程序的哪一部分可以访问它（作用域和链接性）。自动变量是在代码块（如函数体或函数体中的代码块）中定义的变量，仅当程序执行到包含定义的代码块时，它们才存在，并且可见。自动变量可以通过使用存储类型说明符register或根本不使用说明符来声明，没有使用说明符时，变量将默认为自动的。register说明符提示编译器，该变量的使用频率很高，但C++11摒弃了这种用法。 静态变量在整个程序执行期间都存在。对于在函数外面定义的变量，其所属文件中位于该变量的定义后面的所有函数都可以使用它（文件作用域），并可在程序的其他文件中使用（外部链接性）。另一个文件要使用这种变量，必须使用extern关键字来声明它。对于文件间共享的变量，应在一个文件中包含其定义声明（无需使用extern，但如果同时进行初始化，也可使用它），并在其他文件中包含引用声明（使用extern且不初始化）。在函数的外面使用关键字static定义的变量的作用域为整个文件，但是不能用于其他文件（内部链接性）。在代码块中使用关键字static定义的变量被限制在该代码块内（局部作用域、无链接性），但在整个程序执行期间，它都一直存在并且保持原值。 在默认情况下，C++函数的链接性为外部，因此可在文件间共享；但使用关键字static限定的函数的链接性为内部的，被限制在定义它的文件中。 动态内存分配和释放是使用new和delete进行的，它使用自由存储区或堆来存储数据。调用new占用内存，而调用delete释放内存。程序使用指针来跟踪这些内存单元。 名称空间允许定义一个可在其中声明标识符的命名区域。这样做的目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。可以通过使用作用域解析运算符、using声明或using编译指令，来使名称空间中的标识符可用。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11 .使用类]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%20Prime%20Plus%2Fchapter11%2F</url>
    <content type="text"><![CDATA[运算符重载1234567891011Time Time::operator + (const Time &amp;t) const &#123; Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t. hours + sum.minutes / 60; sum.minutes %= 60; return sum;&#125;Time t1,t2;Time t3 = t1 + t2;//调用相当于 t3 = operator + (t1,t2); 重载限制1．重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符（−）重载为计算两个double值的和，而不是它们的差。虽然这种限制将对创造性有所影响，但可以确保程序正常运行。 2．使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符（%）重载成使用一个操作数：同样，不能修改运算符的优先级。因此，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级。 3．不能创建新运算符。例如，不能定义operator **( )函数来表示求幂。4．不能重载下面的运算符。 sizeof：sizeof运算符。.：成员运算符。. *：成员指针运算符。::：作用域解析运算符。?:：条件运算符。typeid：一个RTTI运算符。const_cast：强制类型转换运算符。dynamic_cast：强制类型转换运算符。reinterpret_cast：强制类型转换运算符。static_cast：强制类型转换运算符。然而，表11.1中所有的运算符都可以被重载。 5．表11.1中的大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。 =：赋值运算符。( )：函数调用运算符。[ ]：下标运算符。-&gt;：通过指针访问类成员的运算符。 友元非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问。然而，有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数。 创建友元1friend Time operator * (double m,const Time &amp;t); 虽然operator ( )函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；虽然operator ( )函数不是成员函数，但它与成员函数的访问权限相同。第二步是编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。另外，不要在定义中使用关键字friend， 重载&lt;&lt;运算符1．&lt;&lt;的第一种重载版本 123void operator &lt;&lt;(ostream &amp;os,const Time &amp;t) &#123; os&lt;&lt;t.hours&lt;&lt;"hours ."&lt;&lt;t.minutes&lt;&lt;"minutes";&#125; 2．&lt;&lt;的第二种重载版本1234ostream &amp; operator &lt;&lt;(ostream &amp; os,const Time &amp; t) &#123; os&lt;&lt;t.hours&lt;&lt;"hours"&lt;&lt;t.minutex&lt;&lt;"minute"; return os;&#125; 重载运算符：作为成员函数还是非成员函数namespace1234567891011namespace VECTOR&#123; class Vector &#123; &#125;&#125; //end namespace Vector//main.cppint main() &#123; using VECTOR::Vector;&#125; 随机数随机数。标准ANSI C库（C++也有）中有一个rand( )函数，它返回一个从0到某个值（取决于实现）之间的随机整数。该程序使用求模操作数来获得一个0～359的角度值。rand( )函数将一种算法用于一个初始种子值来获得随机数，该随机值将用作下一次函数调用的种子）依此类推。这些数实际上是伪随机数，因为10次连续的调用通常将生成10个同样的随机数（具体值取决于实现）。然而，srand( )函数允许覆盖默认的种子值，重新启动另一个随机数序列。该程序使用time（0）的返回值来设置种子。time（0）函数返回当前时间，通常为从某一个日期开始的秒数（更广义地，time( )接受time_t变量的地址，将时间放到该变量中，并返回它。将0用作地址参数，可以省略time_t变量声明）。文件cstdlib（以前为stdlib.h）包含了srand( )和rand( )的原型，而ctime（以前是time.h）包含了time( )的原型。C++11使用头文件radom中的函数提供了更强大的随机数支持。 类的自动转换和强制类型转换123456789101112Stonewt(double lbs);Stonewt Mycat;myCat = 19.6;//构造函数作为转换函数//只有一个参数的构造函数或者有默认参数才行explicit Stonewt(double lbs); //关闭自动转换特性Stonewt myCat;myCat = 19.6; //not allowmyCat = Stonewt(19.6); //validmyCat = (Stonewt) 19.6; //old style 编译器在什么时候将使用Stonewt(double)函数呢？如果在声明中使用了关键字explicit，则Stonewt(double)将只用于显式强制类型转换，否则还可以用于下面的隐式转换。 将Stonewt对象初始化为double值时。将double值赋给Stonewt对象时。将double值传递给接受Stonewt参数的函数时。返回值被声明为Stonewt的函数试图返回double值时。在上述任意一种情况下，使用可转换为double类型的内置类型时。 转换函数构造函数只用于从某种类型到类类型的转换。要进行相反的转换，必须使用特殊的C++运算符函数——转换函数。创建转换函数呢？要转换为typeName类型，需要使用这种形式的转换函数： operator typeName(); 请注意以下几点： 转换函数必须是类方法； 转换函数不能指定返回类型； 转换函数不能有参数。 12345operator int() const;STonewt::operator int () const &#123; return int (pounds + 0.5);&#125; 应谨慎地使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的函数。总之，C++为类提供了下面的类型转换。 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。例如，将int值赋给Stonewt对象时，接受int参数的Stonewt类构造函数将自动被调用。然而，在构造函数声明中使用explicit可防止隐式转换，而只允许显式转换。 被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。转换函数是类成员，没有返回类型、没有参数、名为operator typeName( )，其中，typeName是对象将被转换成的类型。将类对象赋给typeName变量或将其强制转换为typeName类型时，该转换函数将自动被调用。 转换和友元函数总结一般来说，访问私有类成员的唯一方法是使用类方法。C++使用友元函数来避开这种限制。要让函数成为友元，需要在类声明中声明该函数，并在声明前加上关键字friend。 C++扩展了对运算符的重载，允许自定义特殊的运算符函数，这种函数描述了特定的运算符与类之间的关系。运算符函数可以是类成员函数，也可以是友元函数（有一些运算符函数只能是类成员函数）。要调用运算符函数，可以直接调用该函数，也可以以通常的句法使用被重载的运算符。对于运算符op，其运算符函数的格式如下：operatorop (argument-list)argument-list表示该运算符的操作数。如果运算符函数是类成员函数，则第一个操作数是调用对象，它不在argument-list中。例如，本章通过为Vector类定义operator +( )成员函数重载了加法。如果up、right和result都是Vector对象，则可以使用下面的任何一条语句来调用矢量加法：result = up.operator + (right);result = up + right;在第二条语句中，由于操作数up和right的类型都是Vector，因此C++将使用Vector的加法定义。 当运算符函数是成员函数时，则第一个操作数将是调用该函数的对象。例如，在前面的语句中，up对象是调用函数的对象。定义运算符函数时，如果要使其第一个操作数不是类对象，则必须使用友元函数。这样就可以将操作数按所需的顺序传递给函数了。 最常见的运算符重载任务之一是定义&lt;&lt;运算符，使之可与cout一起使用，来显示对象的内容。要让ostream对象成为第一个操作数，需要将运算符函数定义为友元；要使重新定义的运算符能与其自身拼接，需要将返回类型声明为ostream &amp;。下面的通用格式能够满足这种要求：1234ostream &amp; operator &lt;&lt;(ostream &amp; os,const c_name &amp; obj) &#123; os&lt;&lt;...; return os;&#125; 然而，如果类包含这样的方法，它返回需要显示的数据成员的值，则可以使用这些方法，无需在operator&lt;&lt;( )中直接访问这些成员。在这种情况下，函数不必（也不应当）是友元。 C++允许指定在类和基本类型之间进行转换的方式。首先，任何接受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。例如，假设有一个String类，它包含一个将char 值作为其唯一参数的构造函数，那么如果bean是String对象，则可以使用下面的语句：`bean = “pinto”;//converts type char to type string然而，如果在该构造函数的声明前加上了关键字explicit，则该构造函数将只能用于显式转换：bean = String(“pinto”); //converts type char * to type string explicitly` 要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。将类对象转换为typeName类型的转换函数的原型如下：operator typeName();注意，转换函数没有返回类型、没有参数，但必须返回转换后的值（虽然没有声明返回类型）。例如，下面是将Vector转换为double类型的函数： 123Vector::operator double() &#123; return a_double_value;&#125; 经验表明，最好不要依赖于这种隐式转换函数。 您可能已经注意到了，与简单的C-风格结构相比，使用类时，必须更谨慎、更小心，但作为补偿，它们为我们完成的工作也更多。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手和四次分手]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FTCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP的三次握手和四次分手]]></content>
      <categories>
        <category>C++面试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP的区别]]></title>
    <url>%2F2018%2F08%2F27%2FC%2B%2B%E9%9D%A2%E8%AF%95%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FTCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[TCP和UDP区别TCP协议和UDP协议特性区别总结： TCP协议在传送数据段的时候要给段标号；UDP协议不 TCP协议可靠；UDP协议不可靠 TCP协议是面向连接；UDP协议采用无连接 TCP协议负载较高，采用虚电路；UDP采用无连接 TCP协议的发送方要确认接收方是否收到数据段（3次握手协议） TCP协议采用窗口技术和流控制OSI 和 TCP/IP 模型在传输层定义两种传输协议：TCP（或传输控制协议）和 UDP（或用户数据报协议）。UDP UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用 UDP。ICQ 短消息使用 UDP 协议发送消息。 许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。TCP TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。 为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。TCP与UDP的选择 如果比较UDP包和TCP包的结构，很明显UDP包不具备TCP包复杂的可靠性与控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。） 很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。]]></content>
      <categories>
        <category>C++面试</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16.string类和标准模板库]]></title>
    <url>%2F2018%2F08%2F23%2FC%2B%2B%20Prime%20Plus%2Fchapter16%2F</url>
    <content type="text"><![CDATA[string类string版本的getline( )函数从输入中读取字符，并将其存储到目标string中，直到发生下列三种情况之一： 到达文件尾，在这种情况下，输入流的eofbit将被设置，这意味着方法fail( )和eof( )都将返回true； 遇到分界字符（默认为\n），在这种情况下，将把分界字符从输入流中删除，但不存储它；读取的字符数达到最大允许值（string::npos和可供分配的内存字节数中较小的一个），在这种情况下，将设置输入流的failbit，这意味着方法fail( )将返回true。 输入流对象有一个统计系统，用于跟踪流的错误状态。在这个系统中，检测到文件尾后将设置eofbit寄存器，检测到输入错误时将设置failbit寄存器，出现无法识别的故障（如硬盘故障）时将设置badbit寄存器，一切顺利时将设置goodbit寄存器。 string版本的operator&gt;&gt;( )函数的行为与此类似，只是它不断读取，直到遇到空白字符并将其留在输入队列中，而不是不断读取，直到遇到分界字符并将其丢弃。空白字符指的是空格、换行符和制表符，更普遍地说，是任何将其作为参数来调用isspace( )时，该函数返回ture的字符。 string 方法 方法原型 描述 size_type find(const string &amp; str, size_type pos = 0)const 从字符串的pos位置开始，查找子字符串str。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回string :: npos size_type find(const char * s, size_type pos = 0)const 从字符串的pos位置开始，查找子字符串s。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回string :: npos size_type find(const char * s, size_type pos = 0, size_type n) 从字符串的pos位置开始，查找s的前n个字符组成的子字符串。如果找到，则返回该子字符串首次出现时其首字符的索引；否则，返回string :: npos size_type find(char ch, size_type pos = 0)const 从字符串的pos位置开始，查找字符ch。如果找到，则返回该字符首次出现的位置；否则，返回string :: npos string库还提供了相关的方法：rfind( )、find_first_of( )、find_last_of( )、find_first_not_of( )和find_last_not_of( )，它们的重载函数特征标都与find( )方法相同。rfind( )方法查找子字符串或字符最后一次出现的位置；find_first_of( )方法在字符串中查找参数中任何一个字符首次出现的位置。 find_last_of( )方法的功能与此相同，只是它查找的是最后一次出现的位置。find_first_not_of( )方法在字符串中查找第一个不包含在参数中的字符 string 的其他功能string库提供了很多其他的工具，包括完成下述功能的函数：删除字符串的部分或全部内容、用一个字符串的部分或全部内容替换另一个字符串的部分或全部内容、将数据插入到字符串中或删除字符串中的数据、将一个字符串的部分或全部内容与另一个字符串的部分或全部内容进行比较、从字符串中提取子字符串、将一个字符串中的内容复制到另一个字符串中、交换两个字符串的内容。 自动调整大小每当程序将一个字母附加到字符串末尾时将发生什么呢？不能仅仅将已有的字符串加大，因为相邻的内存可能被占用了。因此，可能需要分配一个新的内存块，并将原来的内容复制到新的内存单元中。如果执行大量这样的操作，效率将非常低，因此很多C++实现分配一个比实际字符串大的内存块，为字符串提供了增大空间。然而，如果字符串不断增大，超过了内存块的大小，程序将分配一个大小为原来两倍的新内存块，以提供足够的增大空间，避免不断地分配新的内存块。方法capacity( )返回当前分配给字符串的内存块的大小，而reserve( )方法让您能够请求内存块的最小长度。 字符串种类智能指针模板类智能指针三个智能指针模板（auto_ptr、unique_ptr和shared_ptr）都定义了类似指针的对象，可以将new获得（直接或间接）的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。因此，如果将new返回的地址赋给这些对象，将无需记住稍后释放这些内存：在智能指针过期时，这些内存将自动被释放。要创建智能指针对象，必须包含头文件memory，该文件模板定义。然后使用通常的模板语法来实例化所需类型的指针。12345#include&lt;memory&gt;auto_ptr&lt;double&gt; pd(new double);auto_ptr&lt;string&gt; ps(new string);unique_ptr&lt;double&gt; pdu(new double);shared_ptr&lt;string&gt; pss(new string); 智能指针模板位于名称空间std中所有智能指针类都一个explicit构造函数，该构造函数将指针作为参数。因此不需要自动将指针转换为智能指针对象： 下面代码:123auto_ptr&lt;string&gt; ps (new string("I reigned lonely as a cloud."));auto_ptr&lt;string&gt; vocation;vocation = ps; 如果ps和vocation是常规指针，则两个指针将指向同一个string对象。这是不能接受的，因为程序将试图删除同一个对象两次——一次是ps过期时，另一次是vocation过期时。要避免这种问题，方法有多种。 定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本。 建立所有权（ownership）概念，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的构造函数会删除该对象。然后，让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr的策略，但unique_ptr的策略更严格。 创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数（reference counting）。例如，赋值时，计数将加1，而指针过期时，计数将减1。仅当最后一个指针过期时，才调用delete。这是shared_ptr采用的策略。当然，同样的策略也适用于复制构造函数。 auto_ptr的问题pwin = filem[2];//film[2] loses ownership这导致films[2]不再引用该字符串。在auto_ptr放弃对象的所有权后，便可能使用它来访问该对象。当程序打印films[2]指向的字符串时，却发现这是一个空指针，这显然讨厌的意外。这导致films[2]不再引用该字符串。在auto_ptr放弃对象的所有权后，便可能使用它来访问该对象。当程序打印films[2]指向的字符串时，却发现这是一个空指针，这显然讨厌的意外。 有时候，将一个智能指针赋给另一个并不会留下危险的悬挂指针。假设有如下函数定义： 1234567unique_ptr&lt;string&gt; demo(const char * s) &#123; unique_ptr&lt;string&gt; temp&lt;new string(s)&gt;; return temp;&#125;unique_ptr&lt;string&gt; ps;ps = demp("uniquely special"); demo( )返回一个临时unique_ptr，然后ps接管了原本归返回的unique_ptr所有的对象，而返回的unique_ptr被销毁。这没有问题，因为ps拥有了string对象的所有权。但这里的另一个好处是，demo( )返回的临时unique_ptr很快被销毁，没有机会使用它来访问无效的数据。换句话说，没有理由禁止这种赋值。神奇的是，编译器确实允许这种赋值！ 程序试图将一个unique_ptr赋给另一个时，如果源unique_ptr是个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器将禁止这样做：123456using namespace std;unique_ptr&lt;string&gt; pul(new string "Hi ho!");unique_ptr&lt;string&gt; pu2;pu2 = pu1; //#1 not allowedunique_ptr&lt;string&gt; pu3;pu3 = nuique_ptr&lt;string&gt; (new string "Yo:!"); //allowed 当然，您可能确实想执行类似于语句#1的操作。仅当以非智能的方式使用遗弃的智能指针（如解除引用时），这种赋值才不安全。要安全地重用这种指针，可给它赋新值。C++有一个标准库函数std::move( )，让您能够将一个unique_ptr赋给另一个。下面是一个使用前述demo( )函数的例子，该函数返回一个unique_ptr对象： 12345unique_ptr&lt;string&gt; ps1,ps2;ps1 = demo("Uniquely special");ps2 = move(ps1);ps1 = demo("and more");cout&lt;&lt;*ps1&lt;&lt;*ps2&lt;&lt;endl; 相比于auto_ptr，unique_ptr还有另一个优点。它有一个可用于数组的变体。别忘了，必须将delete和new配对，将delete []和new [ ]配对。模板auto_ptr使用delete而不是delete [ ]，因此只能与new一起使用，而不能与new [ ]一起使用。 警告 使用new分配内存时，才能使用auto_ptr和shared_ptr，使用new [ ]分配内存时，不能使用它们。不使用new分配内存时，不能使用auto_ptr或shared_ptr；不使用new或new []分配内存时，不能使用unique_ptr。 选择智能指针如果程序要使用多个指向同一个对象的指针，应选择shared_ptr。这样的情况包括：有一个指针数组，并使用一些辅助指针来标识特定的元素，如最大的元素和最小的元素；两个对象包含都指向第三个对象的指针；STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出警告）和auto_ptr（行为不确定）。如果您的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。 标准模板库STL提供了一组表示容器、迭代器、函数对象和算法的模板。容器是一个与数组类似的单元，可以存储若干个值。STL容器是同质的，即存储的值的类型相同；算法是完成特定任务（如对数组进行排序或在链表中查找特定值）的处方；迭代器能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针；函数对象是类似于函数的对象，可以是类对象或函数指针（包括函数名，因为函数名被用作指针）。STL使得能够构造各种容器（包括数组、队列和链表）和执行各种操作（包括搜索、排序和随机排列）。 vector要创建vector模板对象，可使用通常的表示法来指出要使用的类型。另外，vector模板使用动态内存分配，因此可以用初始化参数来指出需要多少矢量：123456#include &lt;vector&gt;using namespace std;vector&lt;int&gt; ratings(5);int n;cin&gt;&gt;n;vector&lt;double&gt; scores(n); 除分配存储空间外，vector模板还可以完成哪些任务呢？所有的STL容器都提供了一些基本方法，其中包括size( )——返回容器中元素数目、swap( )——交换两个容器的内容、begin( )——返回一个指向容器中第一个元素的迭代器、end( )——返回一个表示超过容器尾的迭代器。 1234vecotr&lt;double&gt;::iterator pd; //pd an iteratorfor(pd = scores.begin();pd != scores.end();pd++) cout&lt;&lt;*pd&lt;&lt;endl; push_back()方法将元素添加到末尾 下述代码删除第一个和第二个元素，即删除begin( )和begin( )+1指向的元素（由于vector提供了随机访问功能，因此vector类迭代器定义了诸如begin( )+2等操作）：1socres.erase(scores.begin(),scores.begin() +2); insert( )方法的功能与erase( )相反。它接受3个迭代器参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，该区间通常是另一个容器对象的一部分。例如，下面的代码将矢量new_v中除第一个元素外的所有元素插入到old_v矢量的第一个元素前面：1234vector&lt;int&gt; old_v;vector&lt;int&gt; new_v;old_v.insert(old_v.begin(),new_v.begin()+1,new_v.end()); 超尾 对矢量的其他操作即使有执行相同任务的非成员函数，STL有时也会定义一个成员函数。这是因为对有些操作来说，类特定算法的效率比通用算法高，因此，vector的成员函数swap( )的效率比非成员函数swap( )高，但非成员函数让您能够交换两个类型不同的容器的内容。 3个具有代表性的STL函数：for_each( )、random_shuffle( )和sort( )。for_each( )函数可用于很多容器类，它接受3个参数。前两个是定义容器中区间的迭代器，最后一个是指向函数的指针（更普遍地说，最后一个参数是一个函数对象，函数对象将稍后介绍）。for_each( )函数将被指向的函数应用于容器区间中的各个元素。被指向的函数不能修改容器元素的值。可以用for_each( )函数来代替for循环。 如果容器元素是用户定义的对象，则要使用sort( )，必须定义能够处理该类型对象的operator&lt;( )函数。例如，如果为Review提供了成员或非成员函数operator&lt;( )，则可以对包含Review对象的矢量进行排序。由于Review是一个结构，因此其成员是公有的，这样的非成员函数将为： 123456789bool operator&lt;(const Review &amp; r1,const Review &amp;r2) &#123; if(r1.title &lt; r2.title) return true; else if(r1.title == r2.title &amp;&amp; r1.rating &lt; r2.ratig) return true; else return false;&#125; 有了这样的函数后，就可以对包含Review对象（如books）的矢量进行排序了： 1sort(books.begin(),books.end()); 可以使用另一种格式的sort( )。它接受3个参数，前两个参数也是指定区间的迭代器，最后一个参数是指向要使用的函数的指针（函数对象），而不是用于比较的operator&lt;( )。 1234567bool WorseThan(const Review &amp; r1,const Review &amp; r2) &#123; if(r1.rating &lt; r2.rating) return true; else return false;&#125; 1sort(books.begin(),books.end(),worsethan); 基于范围的for循环123for_each(books.begin(),books.end(),showReview());//可将其替换为下述基于范围的for循环for(auto x:books) showReview(x); 不同于for_each( )，基于范围的for循环可修改容器的内容，诀窍是指定一个引用参数。123void InflateReview&#123;Review &amp;r)&#123;r.rating++&#125;for(auto &amp; x:books) InflateReview(x0; 泛型编程模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。 迭代器类型层次结构概念改进和模型容器复杂度 编译时间 固定时间 线性时间类型 vector简单地说，vector是数组的一种类表示，它提供了自动内存管理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。vector还是可反转容器（reversible container）概念的模型两个类方法：rbegin( )和rend( )，前者返回一个指向反转序列的第一个元素的迭代器，后者返回反转序列的超尾迭代器。 dequedeque模板类（在deque头文件中声明）表示双端队列（double-ended queue），通常被简称为deque。在STL中，其实现类似于vector容器，支持随机访问。主要区别在于，从deque对象的开始位置插入和删除元素的时间是固定的，而不像vector中那样是线性时间的。所以，如果多数操作发生在序列的起始和结尾处，则应考虑使用deque数据结构。为实现在deque两端执行插入和删除操作的时间为固定的这一目的，deque对象的设计比vector对象更为复杂。因此，尽管二者都提供对元素的随机访问和在序列中部执行线性时间的插入和删除操作，但vector容器执行这些操作时速度要快些。 listlist模板类（在list头文件中声明）表示双向链表。除了第一个和最后一个元素外，每个元素都与前后的元素相链接，这意味着可以双向遍历链表。list和vector之间关键的区别在于，list在链表中任一位置进行插入和删除的时间都是固定的（vector模板提供了除结尾处外的线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除）。因此，vector强调的是通过随机访问进行快速访问，而list强调的是元素的快速插入和删除。与vector相似，list也是可反转容器。与vector不同的是，list不支持数组表示法和随机访问。与矢量迭代器不同，从容器中插入或删除元素之后，链表迭代器指向元素将不变。 1void sort() //使用&lt;操作符来比较 forward_list(C++11)单链表 queue队列的基本操作不允许随机访问,不允许遍历 priority_queue支持的操作和queue相同.区别在于,最大的元素被移到队首,内部区别,默认底层是vector. stack不允许随机访问.不允许遍历 array非容器 关联容器4种关联容器set multiset map multimap set关联集合,可反转,可排序,且键是唯一的,不能存储多个相同的值与vector和list相似,set也使用模板参数来指定要存储的数据12set&lt;string&gt; A;set&lt;string less&lt;string&gt; &gt; A; 12345const int N = 6;string s1[N] = &#123;"buffoon","thinkers","for","heavy","can","for"&#125;;set&lt;string&gt; A(s1,s1 + N);ostream_iterator&lt;string,char&gt; out(cout," ");copy(A.begin(),A.end(),out); 1buffoon can for heavy thinkers multimap与set相似,multimap也是可以反转,经过排序的关联容器,但键和值的类型不同.且一个键可能和多个值相关联. 123multimap&lt;int,string&gt; codes;pair&lt;const int,string&gt; item(213,&quot;Los Angeles&quot;);codes.insert(item); 数据项按键排序对于pair对象可以使用first和second来访问其两个部分]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14. C++中的代码重用]]></title>
    <url>%2F2018%2F08%2F23%2FC%2B%2B%20Prime%20Plus%2Fchapter14%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git_clone_加速]]></title>
    <url>%2F2018%2F08%2F22%2Flinux%2Fgit%2Fgit-clone-%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[git clone 特别慢是因为github.global.ssl.fastly.Net域名被限制了。只要找到这个域名对应的ip地址，然后在hosts文件中加上ip–&gt;域名的映射，刷新DNS缓存就可以了：1.查找ip：1nslookup github.global.ssl.fastly.Net。 要的就是Address的ip（151. ｘｘｘｘ）２、打开hosts文件1sudo vim /etc/hosts 2.在该文件末尾空一行填入151.xxx github.global.ssl.fastly.netgithub.com 上有两种源码获取方式，一是 git clone，一是直接下载 master.zip，后者明显速度快于前者，可以考虑；1）用 proxychains 这类透明代理，间接走系统中运行的代理工具中转；2）用 git 内置代理，直接走系统中运行的代理工具中转，比如，你的 SS 本地端口是 1080，那么可以如下方式走代理12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 也可以如下方式停走代理12git config --global http.proxy ""git config --global https.proxy ""]]></content>
      <categories>
        <category>linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13. 类继承]]></title>
    <url>%2F2018%2F08%2F22%2FC%2B%2B%20Prime%20Plus%2Fchapter13%2F</url>
    <content type="text"><![CDATA[类继承使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。 派生类对象存储了基类的数据成员（派生类继承了基类的实现）； 派生类对象可以使用基类的方法（派生类继承了基类的接口）。 派生类需要自己的构造函数。 派生类可以根据需要添加额外的数据成员和成员函数。构造函数必须给新成员（如果有的话）和继承的成员提供数据。访问权限派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表语法来完成这种工作。 派生类构造函数有关派生类构造函数的要点如下： 首先创建基类对象； 派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数； 派生类构造函数应初始化派生类新增的数据成员。 创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。 如果愿意，也可以对派生类成员使用成员初始化列表语法。在这种情况下，应在列表中使用成员名，而不是类名。 特殊关系 派生类与基类之间有一些特殊关系。其中之一是派生类对象可以使用基类的方法，条件是方法不是私有的： 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象 基类指针或引用只能用于调用基类方法不可以将基类对象和地址赋给派生类引用和指针 13.3 多态公有继承有两种重要的机制可用于实现多态公有继承； 在派生类中重新定义基类的方法。使用虚方法。 virtual如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法。如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。 在派生类方法中，标准技术是使用作用域解析运算符来调用基类方法。如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。因此，使用虚析构函数可以确保正确的析构函数序列被调用。 静态联编和动态联编将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。 在编译过程中进行联编被称为静态联编（static binding）编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。 虚成员函数和动态联编效率和概念模型。首先来看效率。为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的处理开销（稍后将介绍一种动态联编方法）。C++的指导原则之一是，不要为不使用的特性付出代价（内存或者处理时间）。 虚函数的工作原理编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table，vtbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中（参见图13.5）。注意，无论类中包含的虚函数是1个还是10个，都只需要在对象中添加1个地址成员，只是表的大小不同而已。 调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。 总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括： 每个对象都将增大，增大量为存储地址的空间； 对于每个类，编译器都创建一个虚函数地址表（数组）； 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。 虚函数 在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。 析构函数应当是虚函数，除非类不用做基类。 如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的（稍后将介绍）。 重新定义将隐藏方法 第一，如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）。这种特性被称为返回类型协变（covariance of return type），因为允许返回类型随类类型的变化而变化 protected关键字protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员。private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。 纯虚函数1virtual int function() const = 0; 继承和动态内存分配如果基类使用动态内存分配，并重新定义赋值和复制构造函数当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。 这种要求是通过三种不同的方式来满足的。对于析构函数，这是自动完成的；对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；如果不这样做，将自动调用基类的默认构造函数。 对于赋值运算符，这是通过使用作用域解析运算符显式地调用基类的赋值运算符来完成的。 使用动态内存分配和友元的继承示例类设计回顾p405 总结继承通过使用已有的类（基类）定义新的类（派生类），使得能够根据需要修改编程代码。公有继承建立is-a关系，这意味着派生类对象也应该是某种基类对象。作为is-a模型的一部分，派生类继承基类的数据成员和大部分方法，但不继承基类的构造函数、析构函数和赋值运算符。派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的公有方法和保护方法访问基类的私有成员。可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。每个派生类都必须有自己的构造函数。程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；程序删除对象时，将首先调用派生类的析构函数，然后调用基类的析构函数。 如果要将类用作基类，则可以将成员声明为保护的，而不是私有的，这样，派生类将可以直接访问这些成员。然而，使用私有成员通常可以减少出现编程问题的可能性。如果希望派生类可以重新定义基类的方法，则可以使用关键字virtual将它声明为虚的。这样对于通过指针或引用访问的对象，能够根据对象类型来处理，而不是根据引用或指针的类型来处理。具体地说，基类的析构函数通常应当是虚的。 可以考虑定义一个ABC：只定义接口，而不涉及实现。例如，可以定义抽象类Shape，然后使用它派生出具体的形状类，如Circle和Square。ABC必须至少包含一个纯虚方法，可以在声明中的分号前面加上=0来声明纯虚方法。 1virtual double area() const = 0; 不一定非得定义纯虚方法。对于包含纯虚成员的类，不能使用它来创建对象。纯虚方法用于定义派生类的通用接口。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>类继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12 .类和动态内存分配]]></title>
    <url>%2F2018%2F08%2F22%2FC%2B%2B%20Prime%20Plus%2Fchapter12%2F</url>
    <content type="text"><![CDATA[特殊成员函数C++自动提供了下面这些成员函数： 默认构造函数，如果没有定义构造函数；默认析构函数，如果没有定义；复制构造函数，如果没有定义；赋值运算符，如果没有定义；地址运算符，如果没有定义。 隐式地址运算符返回调用对象的地址（即this指针的值）。 默认构造函数2．复制构造函数复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程中类的复制构造函数原型通常如下1Class_name(const Class_name &amp;); 它接受一个指向类对象的常量引用作为参数。对于复制构造函数，需要知道两点：何时调用和有何功能。一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。每当程序生成了对象副本时，编译器都将使用复制构造函数。具体地说，当函数按值传递对象（如程序清单12.3中的callme2()）或函数返回对象时，都将使用复制构造函数。记住，按值传递意味着创建原始变量的一个副本。编译器生成临时对象时，也将使用复制构造函数。无论是哪种编译器，当按值传递和返回对象时，都将调用复制构造函数。默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。 12345StringBad sailor = sports;//与下面的代码等效StringBad sailor;sailor.str = sports.str;sailor.len = sports.len; 解决类设计中这种问题的方法是进行深度复制（deep copy）。复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅是复制字符串地址。这样每个对象都有自己的字符串，而不是引用另一个对象的字符串。调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这被称为深度复制。复制的另一种形式（成员复制或浅复制）只是复制指针值。浅复制仅浅浅地复制指针信息，而不会深入“挖掘”以复制指针引用的结构。 赋值运算符这是通过自动为类重载赋值运算符实现的。这种运算符的原型如下：1Class_name &amp; Class_name::operator=(const Class_name &amp;); 赋值运算符的功能以及何时使用它将已有的对象赋给另一个对象时，将使用重载的赋值运算符：初始化总是会调用复制构造函数，而使用=运算符时也可能调用赋值运算符。与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制。 对于由于默认赋值运算符不合适而导致的问题，解决办法是提供赋值运算符（进行深度复制）定义。其实现与复制构造函数相似，但也有一些差别。 由于目标对象可能引用了以前分配的数据，所以函数应使用delete[ ]来释放这些数据。 函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容。 函数返回一个指向调用对象的引用。 C++11空指针C++11提供了更好的解决方案：引入新关键字nullptr，用于表示空指针。您仍可像以前一样使用0——否则大量现有的代码将非法，但建议您使用nullptr： 静态类成员函数首先，不能通过对象调用静态成员函数；实际上，静态成员函数甚至不能使用this指针。如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它。 构造函数中使用new时应注意的事项 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。 new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[ ]。 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空（0或C++11中的nullptr），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。 具体地说，该方法应完成这些操作：检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用。有关返回对象的说明当成员函数或独立的函数返回对象时，有几种返回方式可供选择。可以返回指向对象的引用、指向对象的const引用或const对象。返回指向const对象的引用使用const引用的常见原因是旨在提高效率，但对于何时可以采用这种方式存在一些限制。如果函数返回（通过调用对象的方法或将对象作为参数）传递给它的对象，可以通过返回引用来提高其效率。首先，返回对象将调用复制构造函数，而返回引用不会。引用指向的对象应该在调用函数执行时存在。返回指向非const对象的引用两种常见的返回非const对象情形是，重载赋值运算符以及重载与cout一起使用的&lt;&lt;运算符。前者这样做旨在提高效率，而后者必须这样做。返回对象如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。返回const对象总之，如果方法或函数要返回局部对象，则应返回对象，而不是指向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对象。如果方法或函数要返回一个没有公有复制构造函数的类（如ostream类）的对象，它必须返回一个指向这种对象的引用。最后，有些方法和函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为其效率更高。使用指向对象的指针使用new初始化对象通常，如果Class_name是类，value的类型为Type_name，则下面的语句：* pclass 123456//将调用如下构造函数:Class_name(Type_name);//可能存在转换Class_name(cosnt Type_name &amp;);//如果不存在二义性,则将发生由原型匹配导致的转换(如从int到double).Class_name *pstr = new Class_name; //将调用默认的构造函数 在如下情况下析构函数将被调用 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数. 如果对象是静态变量（外部、静态、静态外部或来自名称空间），则在程序结束时将调用对象的析构函数。 如果对象是用new创建的，则仅当您显式使用delete删除对象时，其析构函数才会被调用。 定位new运算符定位new运算符使用一个新对象来覆盖用于第一个对象的内存单元。显然，如果类动态地为其成员分配内存这将引发问题。将delete[]用于buffer时，不会为使用定位new运算符创建的对象调用析构函数。放使用常规new运算符分配的整个内存块，但它没有为定位new运算符在该内存块中创建的对象调用析构函数。显式地为使用定位new运算符创建的对象调用析构函数。正常情况下将自动调用析构函数，这是需要显式调用析构函数的少数几种情形之一。显式地调用析构函数时，必须指定要销毁的对象。由于有指向对象的指针，因此可以使用这些指针：仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。 复习各种技术如果类使用new运算符来分配类成员指向的内存，在设计时应采取一些预防措施（前面总结了这些预防措施，应牢记这些规则，这是因为编译器并不知道这些规则，因此无法发现错误）。 对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete，该运算符将释放分配的内存。如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将它设置为空指针。构造函数中要么使用new []，要么使用new，而不能混用。如果构造函数使用的是new[]，则析构函数应使用delete []；如果构造函数使用的是new，则析构函数应使用delete。应定义一个分配内存（而不是将指针指向已有内存）的复制构造函数。这样程序将能够将类对象初始化为另一个类对象。这种构造函数的原型通常如下：1className(const className &amp;) 成员初始化列表成员初始化列表由逗号分隔的初始化列表组成（前面带冒号）。它位于参数列表的右括号之后、函数体左括号之前。如果数据成员的名称为mdata，并需要将它初始化为val，则初始化器为mdata（val）。只有构造函数可以使用这种初始化列表语法。如上所示，对于const类成员，必须使用这种语法。另外，对于被声明为引用的类成员，也必须使用这种语法： 这种格式只能用于构造函数； 必须用这种格式来初始化非静态const数据成员（至少在C++11之前是这样的）； 必须用这种格式来初始化引用数据成员。 数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的排列顺序无关。C++11提供了另一种禁用方法的方式——使用关键字delete当对象被按值传递（或返回）时，复制构造函数将被调用。然而，如果遵循优先采用按引用传递对象的惯例，将不会有任何问题。另外，复制构造函数还被用于创建其他的临时对象， 总结在类构造函数中，可以使用new为数据分配内存，然后将内存地址赋给类成员。这样，类便可以处理长度不同的字符串，而不用在类设计时提前固定数组的长度。在类构造函数中使用new，也可能在对象过期时引发问题。如果对象包含成员指针，同时它指向的内存是由new分配的，则释放用于保存对象的内存并不会自动释放对象成员指针指向的内存。因此在类构造函数中使用new类来分配内存时，应在类析构函数中使用delete来释放分配的内存。这样，当对象过期时，将自动释放其指针成员指向的内存。 如果对象包含指向new分配的内存的指针成员，则将一个对象初始化为另一个对象，或将一个对象赋给另一个对象时，也会出现问题。在默认情况下，C++逐个对成员进行初始化和赋值，这意味着被初始化或被赋值的对象的成员将与原始对象完全相同。如果原始对象的成员指向一个数据块，则副本成员将指向同一个数据块。当程序最终删除这两个对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。解决方法是：定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符。在上述任何一种情况下，新的定义都将创建指向数据的副本，并使新对象指向这些副本。这样，旧对象和新对象都将引用独立的、相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算符。对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而不仅仅是复制指向数据的指针。 对象的存储持续性为自动或外部时，在它不再存在时将自动调用其析构函数。如果使用new运算符为对象分配内存，并将其地址赋给一个指针，则当您将delete用于该指针时将自动为对象调用析构函数。然而，如果使用定位new运算符（而不是常规new运算符）为类对象分配内存，则必须负责显式地为该对象调用析构函数，方法是使用指向该对象的指针调用析构函数方法。C++允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类，这意味着它们被局限于类中，不会与其他地方定义的同名结构、类和枚举发生冲突。 C++为类构造函数提供了一种可用来初始化数据成员的特殊语法。这种语法包括冒号和由逗号分隔的初始化列表，被放在构造函数参数的右括号后，函数体的左括号之前。每一个初始化器都由被初始化的成员的名称和包含初始值的括号组成。如果数据成员是非静态const成员或引用，则必须采用这种格式，但可将C++11新增的类内初始化用于非静态const成员。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
